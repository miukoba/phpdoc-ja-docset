<html><!-- Mirrored from php.net/manual/en/function.unpack.php by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 28 Aug 2014 16:05:09 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->


  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 

  <title>unpack</title>

 <link rel="shortcut icon" href="../../favicon.ico">
 <link rel="search" type="application/opensearchdescription+xml" href="http://php.net/phpnetimprovedsearch.src" title="Add PHP.net search">
 <link rel="alternate" type="application/atom+xml" href="http://php.net/releases/feed.php" title="PHP Release feed">
 <link rel="alternate" type="application/atom+xml" href="http://php.net/feed.atom" title="PHP: Hypertext Preprocessor">

 <link rel="canonical" href="function.unpack.html">
 <link rel="shorturl" href="http://php.net/unpack">
 <link rel="alternate" href="http://php.net/unpack" hreflang="x-default">

 <link rel="contents" href="index-2.html">
 <link rel="index" href="ref.misc.html">
 <link rel="prev" href="function.uniqid.html">
 <link rel="next" href="function.usleep.html">

 <link rel="alternate" href="function.unpack.html" hreflang="en">
 <link rel="alternate" href="http://php.net/manual/pt_BR/function.unpack.php" hreflang="pt_BR">
 <link rel="alternate" href="http://php.net/manual/zh/function.unpack.php" hreflang="zh">
 <link rel="alternate" href="http://php.net/manual/fr/function.unpack.php" hreflang="fr">
 <link rel="alternate" href="http://php.net/manual/de/function.unpack.php" hreflang="de">
 <link rel="alternate" href="http://php.net/manual/it/function.unpack.php" hreflang="it">
 <link rel="alternate" href="http://php.net/manual/ja/function.unpack.php" hreflang="ja">
 <link rel="alternate" href="http://php.net/manual/ro/function.unpack.php" hreflang="ro">
 <link rel="alternate" href="http://php.net/manual/ru/function.unpack.php" hreflang="ru">
 <link rel="alternate" href="http://php.net/manual/es/function.unpack.php" hreflang="es">
 <link rel="alternate" href="http://php.net/manual/tr/function.unpack.php" hreflang="tr">

<link rel="stylesheet" type="text/css" href="../../cached8fe1.css?t=1401250819&amp;f=/fonts/Fira/fira.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached4b8d.css?t=1404368420&amp;f=/fonts/Font-Awesome/css/fontello.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached5065.css?t=1403329232&amp;f=/styles/theme-base.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cachedc78d.css?t=1401249623&amp;f=/styles/theme-medium.css" media="screen">

 <!--[if lte IE 7]>
 <link rel="stylesheet" type="text/css" href="http://php.net/styles/workarounds.ie7.css" media="screen">
 <![endif]-->

 <!--[if lte IE 8]>
 <script type="text/javascript">
  window.brokenIE = true;
 </script>
 <![endif]-->

 <!--[if lte IE 9]>
 <link rel="stylesheet" type="text/css" href="http://php.net/styles/workarounds.ie9.css" media="screen">
 <![endif]-->

 <!--[if IE]>
 <script type="text/javascript" src="http://php.net/js/ext/html5.js"></script>
 <![endif]-->

 <base>

</head>
<body class="docs " style="">


<div class="headsup"><a href="http://php.net/index.php#id2014-08-28-1">PHP 5.6.0 released</a></div>
<nav id="trick"><div><dl>
<dt><a href="getting-started.html">Getting Started</a></dt>
	<dd><a href="introduction.html">Introduction</a></dd>
	<dd><a href="tutorial.html">A simple tutorial</a></dd>
<dt><a href="langref.html">Language Reference</a></dt>
	<dd><a href="language.basic-syntax.html">Basic syntax</a></dd>
	<dd><a href="language.types.html">Types</a></dd>
	<dd><a href="language.variables.html">Variables</a></dd>
	<dd><a href="language.constants.html">Constants</a></dd>
	<dd><a href="language.expressions.html">Expressions</a></dd>
	<dd><a href="language.operators.html">Operators</a></dd>
	<dd><a href="language.control-structures.html">Control Structures</a></dd>
	<dd><a href="language.functions.html">Functions</a></dd>
	<dd><a href="language.oop5.html">Classes and Objects</a></dd>
	<dd><a href="language.namespaces.html">Namespaces</a></dd>
	<dd><a href="language.exceptions.html">Exceptions</a></dd>
	<dd><a href="language.generators.html">Generators</a></dd>
	<dd><a href="language.references.html">References Explained</a></dd>
	<dd><a href="reserved.variables.html">Predefined Variables</a></dd>
	<dd><a href="reserved.exceptions.html">Predefined Exceptions</a></dd>
	<dd><a href="reserved.interfaces.html">Predefined Interfaces and Classes</a></dd>
	<dd><a href="context.html">Context options and parameters</a></dd>
	<dd><a href="wrappers.html">Supported Protocols and Wrappers</a></dd>
</dl>
<dl>
<dt><a href="security.html">Security</a></dt>
	<dd><a href="security.intro.html">Introduction</a></dd>
	<dd><a href="security.general.html">General considerations</a></dd>
	<dd><a href="security.cgi-bin.html">Installed as CGI binary</a></dd>
	<dd><a href="security.apache.html">Installed as an Apache module</a></dd>
	<dd><a href="security.filesystem.html">Filesystem Security</a></dd>
	<dd><a href="security.database.html">Database Security</a></dd>
	<dd><a href="security.errors.html">Error Reporting</a></dd>
	<dd><a href="security.globals.html">Using Register Globals</a></dd>
	<dd><a href="security.variables.html">User Submitted Data</a></dd>
	<dd><a href="security.magicquotes.html">Magic Quotes</a></dd>
	<dd><a href="security.hiding.html">Hiding PHP</a></dd>
	<dd><a href="security.current.html">Keeping Current</a></dd>
<dt><a href="features.html">Features</a></dt>
	<dd><a href="features.http-auth.html">HTTP authentication with PHP</a></dd>
	<dd><a href="features.cookies.html">Cookies</a></dd>
	<dd><a href="features.sessions.html">Sessions</a></dd>
	<dd><a href="features.xforms.html">Dealing with XForms</a></dd>
	<dd><a href="features.file-upload.html">Handling file uploads</a></dd>
	<dd><a href="features.remote-files.html">Using remote files</a></dd>
	<dd><a href="features.connection-handling.html">Connection handling</a></dd>
	<dd><a href="features.persistent-connections.html">Persistent Database Connections</a></dd>
	<dd><a href="features.safe-mode.html">Safe Mode</a></dd>
	<dd><a href="features.commandline.html">Command line usage</a></dd>
	<dd><a href="features.gc.html">Garbage Collection</a></dd>
	<dd><a href="features.dtrace.html">DTrace Dynamic Tracing</a></dd>
</dl>
<dl>
<dt><a href="funcref.html">Function Reference</a></dt>
	<dd><a href="refs.basic.php.html">Affecting PHP's Behaviour</a></dd>
	<dd><a href="refs.utilspec.audio.html">Audio Formats Manipulation</a></dd>
	<dd><a href="refs.remote.auth.html">Authentication Services</a></dd>
	<dd><a href="refs.utilspec.cmdline.html">Command Line Specific Extensions</a></dd>
	<dd><a href="refs.compression.html">Compression and Archive Extensions</a></dd>
	<dd><a href="refs.creditcard.html">Credit Card Processing</a></dd>
	<dd><a href="refs.crypto.html">Cryptography Extensions</a></dd>
	<dd><a href="refs.database.html">Database Extensions</a></dd>
	<dd><a href="refs.calendar.html">Date and Time Related Extensions</a></dd>
	<dd><a href="refs.fileprocess.file.html">File System Related Extensions</a></dd>
	<dd><a href="refs.international.html">Human Language and Character Encoding Support</a></dd>
	<dd><a href="refs.utilspec.image.html">Image Processing and Generation</a></dd>
	<dd><a href="refs.remote.mail.html">Mail Related Extensions</a></dd>
	<dd><a href="refs.math.html">Mathematical Extensions</a></dd>
	<dd><a href="refs.utilspec.nontext.html">Non-Text MIME Output</a></dd>
	<dd><a href="refs.fileprocess.process.html">Process Control Extensions</a></dd>
	<dd><a href="refs.basic.other.html">Other Basic Extensions</a></dd>
	<dd><a href="refs.remote.other.html">Other Services</a></dd>
	<dd><a href="refs.search.html">Search Engine Extensions</a></dd>
	<dd><a href="refs.utilspec.server.html">Server Specific Extensions</a></dd>
	<dd><a href="refs.basic.session.html">Session Extensions</a></dd>
	<dd><a href="refs.basic.text.html">Text Processing</a></dd>
	<dd><a href="refs.basic.vartype.html">Variable and Type Related Extensions</a></dd>
	<dd><a href="refs.webservice.html">Web Services</a></dd>
	<dd><a href="refs.utilspec.windows.html">Windows Only Extensions</a></dd>
	<dd><a href="refs.xml.html">XML Manipulation</a></dd>
</dl>
<dl>
<dt>Keyboard Shortcuts</dt><dt>?</dt>
<dd>This help</dd>
<dt>j</dt>
<dd>Next menu item</dd>
<dt>k</dt>
<dd>Previous menu item</dd>
<dt>g p</dt>
<dd>Previous man page</dd>
<dt>g n</dt>
<dd>Next man page</dd>
<dt>G</dt>
<dd>Scroll to bottom</dd>
<dt>g g</dt>
<dd>Scroll to top</dd>
<dt>g h</dt>
<dd>Goto homepage</dd>
<dt>g s</dt>
<dd>Goto search<br>(current page)</dd>
<dt>/</dt>
<dd>Focus search box</dd>
</dl></div></nav>
<div id="goto">
    <div class="search">
         <div class="text"></div>
         <div class="results"><ul></ul></div>
   </div>
</div>

  <div id="breadcrumbs" class="row-fluid">
          
              
        <ul class="breadcrumbs-container">
            <li><a href="index-2.html">PHP Manual</a></li>      <li><a href="funcref.html">Function Reference</a></li>      <li><a href="refs.basic.other.html">Other Basic Extensions</a></li>      <li><a href="book.misc.html">Misc.</a></li>      <li><a href="ref.misc.html">Misc. Functions</a></li>    </ul>
  </div>




<div id="layout">
  <section id="layout-content">
  <div id="function.unpack" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">unpack</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">unpack</span> â€” <span class="dc-title">Unpack data from binary string</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.unpack-description">
  <h3 class="title">Description</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">array</span> <span class="methodname"><strong>unpack</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$format</code></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$data</code></span>
   )</div>

  <p class="para rdfs-comment">
   Unpacks from a binary string into an array according to the given
   <code class="parameter">format</code>. 
  </p>
  <p class="para">
   The unpacked data is stored in an associative array. To
   accomplish this you have to name the different format codes and
   separate them by a slash /. If a repeater argument is present,
   then each of the array keys will have a sequence number behind
   the given name.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.unpack-parameters">
  <h3 class="title">Parameters</h3>
  <p class="para">
   </p><dl>

    
     <dt>
<code class="parameter">format</code></dt>

     <dd>

      <p class="para">
       See <span class="function"><a href="function.pack.html" class="function">pack()</a></span> for an explanation of the format codes.
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">data</code></dt>

     <dd>

      <p class="para">
       The packed data.
      </p>
     </dd>

    
   </dl>

  <p></p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.unpack-returnvalues">
  <h3 class="title">Return Values</h3>
  <p class="para">
   Returns an associative array containing unpacked elements of binary
   string.
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.unpack-changelog">
  <h3 class="title">Changelog</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Version</th>
       <th>Description</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.5.0</td>
       <td>
        <p class="para">
         Changes were made to bring this function into line with Perl:
        </p>
        <p class="para">
         The "a" code now retains trailing NULL bytes.
        </p>
        <p class="para">
         The "A" code now strips all trailing ASCII whitespace (spaces, tabs,
         newlines, carriage returns, and NULL bytes).
        </p>
        <p class="para">
         The "Z" code was added for NULL-padded strings, and removes trailing
         NULL bytes.
        </p>
       </td>
      </tr>

     </tbody>
    
   </table>

  <p></p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.unpack-examples">
  <h3 class="title">Examples</h3>
  <p class="para">
   </p><div class="example" id="example-3913">
    <p><strong>Example #1 <span class="function"><strong>unpack()</strong></span> example</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br>$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"cchars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>
     The resulting array will contain the entries "chars" with value
     <em>4</em> and "int" with <em>160</em>.
    </p></div>
   </div>
  <p></p>

  <p class="para">
   </p><div class="example" id="example-3914">
    <p><strong>Example #2 <span class="function"><strong>unpack()</strong></span> example with a repeater</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br>$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2chars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>
      The resulting array will contain the entries "chars1",
      "chars2" and "int".
     </p></div>
    </div>
   <p></p>
  </div>


 <div class="refsect1 notes" id="refsect1-function.unpack-notes">
  <h3 class="title">Notes</h3>
  <div class="caution"><strong class="caution">Caution</strong>
   <p class="para">
    Note that PHP internally stores integral values as signed. If you
    unpack a large unsigned long and it is of the same size as PHP
    internally stored values the result will be a negative number
    even though unsigned unpacking was specified.
   </p>
  </div>
  <div class="caution"><strong class="caution">Caution</strong>
   <p class="para">
    Be aware that if you do not name an element, an empty string is used.
    If you do not name more than one element, this means
    that some data is overwritten as the keys are the same such as in:
   </p>
   <p class="para">
    </p><div class="example" id="example-3915">
     <p><strong>Example #3 <span class="function"><strong>unpack()</strong></span> example with unnamed keys</strong></p>
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br>$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x32\x42\x00\xa0"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2/n"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>
      The resulting array will contain the entries "1" with value
      <em>160</em> and "2" with <em>66</em>. The
      first value from the <em>c</em> specifier is 
      overwritten by the first value from the <em>n</em>
      specifier.
     </p></div>
    </div>
   <p></p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.unpack-seealso">
  <h3 class="title">See Also</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li class="member"><span class="function"><a href="function.pack.html" class="function" rel="rdfs-seeAlso">pack()</a> - Pack data into binary string</span></li>
   </ul>
  <p></p>
 </div>


</div>
<section id="usernotes">
 <div class="head"><h3 class="title">User Contributed Notes</h3></div><div id="allnotes">
  <div class="note" id="43945">  
  <a class="name">
  <strong class="user"><em>Sergio Santana: ssantana at tlaloc dot imta dot mx</em></strong></a><div class="date" title="2004-07-09 10:54"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom43945">
<div class="phpcode"><code><span class="html">
This is about the last example of my previous post. For the sake of clarity, I'm including again here the example, which expands the one given in the formal documentation:<br><br>&lt;?<br>&nbsp; $binarydata = "AA\0A";<br>&nbsp; $array = unpack("c2chars/nint", $binarydata);<br>&nbsp; foreach ($array as $key =&gt; $value)<br>&nbsp; &nbsp;&nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br>?&gt;<br><br>This outputs:<br><br>$array[chars1] = 65 <br>$array[chars2] = 65 <br>$array[int] = 65 <br><br>Here, we assume that the ascii code for character 'A' is decimal 65.<br><br>Remebering that the format string structure is:<br>&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...],<br>in this example, the format string instructs the function to<br>&nbsp; 1. ("c2...") Read two chars from the second argument ("AA ...), <br>&nbsp; 2. (...chars...) Use the array-keys "chars1", and "chars2" for <br>&nbsp; &nbsp; &nbsp; these two chars read,<br>&nbsp; 3. (.../n...) Read a short int from the second argument (...\0A"),<br>&nbsp; 4. (...int") Use the word "int" as the array key for the just read<br>&nbsp; &nbsp; &nbsp; short.<br><br>I hope this is clearer now,<br><br>Sergio.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="46725">  
  <a class="name">
  <strong class="user"><em>jjfoerch at earthlink dot net</em></strong></a><div class="date" title="2004-10-21 04:57"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom46725">
<div class="phpcode"><code><span class="html">
I had a situation where I had to unpack a file filled with little-endian order double-floats in a way that would work on either little-endian or big-endian machines.&nbsp; PHP doesn't have a formatting code that will change the byte order of doubles, so I wrote this workaround.<br><br><span class="default">&lt;?php<br></span><span class="comment">/*The following code is a workaround for php's unpack function<br>which does not have the capability of unpacking double precision<br>floats that were packed in the opposite byte order of the current<br>machine.<br>*/<br></span><span class="keyword">function </span><span class="default">big_endian_unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">$ar </span><span class="keyword">= </span><span class="default">unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">$vals </span><span class="keyword">= </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">explode </span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$format</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br>&nbsp; &nbsp; foreach (</span><span class="default">$f </span><span class="keyword">as </span><span class="default">$f_k </span><span class="keyword">=&gt; </span><span class="default">$f_v</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">intval </span><span class="keyword">(</span><span class="default">substr </span><span class="keyword">(</span><span class="default">$f_v</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">));<br>&nbsp; &nbsp; if (</span><span class="default">$repeater </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br>&nbsp; &nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">1</span><span class="keyword">} == </span><span class="string">'*'</span><span class="keyword">)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">count </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">) - </span><span class="default">$i</span><span class="keyword">;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">} != </span><span class="string">'d'</span><span class="keyword">) { </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">$repeater</span><span class="keyword">; continue; }<br>&nbsp; &nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$repeater</span><span class="keyword">;<br>&nbsp; &nbsp; for (</span><span class="default">$a </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">; </span><span class="default">$a </span><span class="keyword">&lt; </span><span class="default">$j</span><span class="keyword">; ++</span><span class="default">$a</span><span class="keyword">)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'d'</span><span class="keyword">,</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">strrev </span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; list (</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'d1d'</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">));<br>&nbsp; &nbsp; &nbsp; &nbsp; ++</span><span class="default">$i</span><span class="keyword">;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br>&nbsp; &nbsp; foreach (</span><span class="default">$ar </span><span class="keyword">as </span><span class="default">$ar_k </span><span class="keyword">=&gt; </span><span class="default">$ar_v</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">$ar</span><span class="keyword">[</span><span class="default">$ar_k</span><span class="keyword">] = </span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$a</span><span class="keyword">];<br>&nbsp; &nbsp; ++</span><span class="default">$a</span><span class="keyword">;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return </span><span class="default">$ar</span><span class="keyword">;<br>}<br><br>list (</span><span class="default">$endiantest</span><span class="keyword">) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'L1L'</span><span class="keyword">, </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'V'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)));<br>if (</span><span class="default">$endiantest </span><span class="keyword">!= </span><span class="default">1</span><span class="keyword">) </span><span class="default">define </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">);<br>if (</span><span class="default">defined </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">)) </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'big_endian_unpack'</span><span class="keyword">;<br>else </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'unpack'</span><span class="keyword">;<br></span><span class="default">?&gt;<br></span><br>This workaround is used like this:<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">() {<br>&nbsp; &nbsp; &nbsp; &nbsp; global </span><span class="default">$unpack_workaround</span><span class="keyword">;<br>&nbsp; &nbsp; </span><span class="default">$bar </span><span class="keyword">= </span><span class="default">$unpack_workaround</span><span class="keyword">(</span><span class="string">'N7N/V2V/d8d'</span><span class="keyword">,</span><span class="default">$my_data</span><span class="keyword">);<br></span><span class="comment">//...<br></span><span class="keyword">}<br><br></span><span class="default">?&gt;<br></span><br>On a little endian machine, $unpack_workaround will simply point to the function unpack.&nbsp; On a big endian machine, it will call the workaround function.<br><br>Note, this solution only works for doubles.&nbsp; In my project I had no need to check for single precision floats.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="43930">  
  <a class="name">
  <strong class="user"><em>Sergio Santana: ssantana at tlaloc dot imta dot mx</em></strong></a><div class="date" title="2004-07-08 07:41"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom43930">
<div class="phpcode"><code><span class="html">
Suppose we need to get some kind of internal representation of an integer, say 65, as a four-byte long. Then we use, something like:<br><br>&lt;?<br>&nbsp; $i = 65;<br>&nbsp; $s = pack("l", $i); // long 32 bit, machine byte order<br>&nbsp; echo strlen($s) . "&lt;br&gt;\n";<br>&nbsp; echo "***$s***&lt;br&gt;\n";<br>?&gt;<br><br>The output is:<br><br>X-Powered-By: PHP/4.1.2<br>Content-type: text/html<br><br>4<br>***A*** <br><br>(That is the string "A\0\0\0")<br><br>Now we want to go back from string "A\0\0\0" to number 65. In this case we can use:<br><br>&lt;?<br>&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number 65<br>&nbsp; $arr = unpack("l", $s);<br>&nbsp; foreach ($arr as $key =&gt; $value)<br>&nbsp; &nbsp;&nbsp; echo "\$arr[$key] = $value&lt;br&gt;\n";<br>?&gt;<br><br>And this outpus:<br>X-Powered-By: PHP/4.1.2<br>Content-type: text/html<br><br>$arr[] = 65<br><br>Let's give the array key a name, say "mykey". In this case, we can use: <br><br>&lt;?<br>&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number&nbsp; 65<br>&nbsp; $arr = unpack("lmykey", $s);<br>&nbsp; foreach ($arr as $key =&gt; $value)<br>&nbsp; &nbsp;&nbsp; echo "\$arr[$key] = $value\n";<br>?&gt;<br><br>An this outpus:<br>X-Powered-By: PHP/4.1.2<br>Content-type: text/html<br><br>$arr[mykey] = 65<br><br>The "unpack" documentation is a little bit confusing. I think a more complete example could be:<br><br>&lt;?<br>&nbsp; $binarydata = "AA\0A";<br>&nbsp; $array = unpack("c2chars/nint", $binarydata);<br>&nbsp; foreach ($array as $key =&gt; $value)<br>&nbsp; &nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br>?&gt;<br><br>whose output is:<br><br>X-Powered-By: PHP/4.1.2<br>Content-type: text/html<br><br>$array[chars1] = 65 &lt;br&gt;<br>$array[chars2] = 65 &lt;br&gt;<br>$array[int] = 65 &lt;br&gt;<br><br>Note that the format string is something like<br>&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...]<br><br>I hope this clarifies something<br><br>Sergio</span>
</code></div>
  </div>
 </div>
  <div class="note" id="103634">  
  <a class="name">
  <strong class="user"><em>David Gero dave at havidave dot com</em></strong></a><div class="date" title="2011-04-25 07:50"><strong>3 years ago</strong></div>
  <div class="text" id="Hcom103634">
<div class="phpcode"><code><span class="html">
You might find these functions useful:<br><br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">byteStr2byteArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br>}<br>function </span><span class="default">byteArray2byteStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"C*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br>}<br>function </span><span class="default">lsbStr2ushortArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"v*"</span><span class="keyword">, </span><span class="string">"\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br>}<br>function </span><span class="default">ushortArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"v*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br>}<br>function </span><span class="default">lsbStr2ulongArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V*"</span><span class="keyword">, </span><span class="string">"\0\0\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br>}<br>function </span><span class="default">ulongArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"V*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br>}<br></span><span class="default">?&gt;<br></span><br>Of course, you can address byte strings as if they're arrays with numerical indexes, but the other functions are helpful.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="83349">  
  <a class="name">
  <strong class="user"><em>Nhon</em></strong></a><div class="date" title="2008-05-21 01:42"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom83349">
<div class="phpcode"><code><span class="html">
As stated above, "if you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br><br>To restore the original unsigned value, you could do this :<br><br>if ($unpackedVal &lt;0)<br>{<br>&nbsp; &nbsp; &nbsp; $unpackedVal += 4294967296;<br>}<br><br>Hope this helps !<br><br>Cheers</span>
</code></div>
  </div>
 </div>
  <div class="note" id="45188">  
  <a class="name">
  <strong class="user"><em>kennwhite dot nospam at hotmail dot com</em></strong></a><div class="date" title="2004-08-28 12:32"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom45188">
<div class="phpcode"><code><span class="html">
If having a zero-based index is useful/necessary, then instead of:<br><br>$int_list = unpack("s*", $some_binary_data);<br><br> try:<br><br>$int_list = array_merge(unpack("s*", $some_binary_data));<br><br>This will return a 0-based array:<br><br>$int_list[0] = x<br>$int_list[1] = y<br>$int_list[2] = z<br>...<br><br>rather than the default 1-based array returned from unpack when no key is supplied:<br><br>$int_list[1] = x<br>$int_list[2] = y<br>$int_list[3] = z<br>...<br><br>It's not used often, but array_merge() with only one parameter will compress a sequentially-ordered numeric-index, starting with an index of [0].</span>
</code></div>
  </div>
 </div>
  <div class="note" id="106041">  
  <a class="name">
  <strong class="user"><em>rogier</em></strong></a><div class="date" title="2011-10-05 07:19"><strong>2 years ago</strong></div>
  <div class="text" id="Hcom106041">
<div class="phpcode"><code><span class="html">
be aware of the behavior of your system that PHP resides on.
<br>
<br>On x86, unpack MAY not yield the result you expect for UInt32
<br>
<br>This is due to the internal nature of PHP, being that integers are internally stored as SIGNED!
<br>
<br>For x86 systems, unpack('N', "\xff\xff\xff\xff") results in -1
<br>For (most?) x64 systems, unpack('N', "\xff\xff\xff\xff") results in 4294967295.
<br>
<br>This can be verified by checking the value of PHP_INT_SIZE.
<br>If this value is 4, you have a PHP that internally stores 32-bit.
<br>A value of 8 internally stores 64-bit.
<br>
<br>To work around this 'problem', you can use the following code to avoid problems with unpack.
<br>The code is for big endian order but can easily be adjusted for little endian order (also, similar code works for 64-bit integers):
<br>
<br><span class="default">&lt;?php
<br></span><span class="keyword">function </span><span class="default">_uint32be</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">)
<br>{
<br>&nbsp; &nbsp; </span><span class="comment">// $bin is the binary 32-bit BE string that represents the integer
<br>&nbsp; &nbsp; </span><span class="keyword">if (</span><span class="default">PHP_INT_SIZE </span><span class="keyword">&lt;= </span><span class="default">4</span><span class="keyword">){
<br>&nbsp; &nbsp; &nbsp; &nbsp; list(,</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$l</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'n*'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; return (</span><span class="default">$l </span><span class="keyword">+ (</span><span class="default">$h</span><span class="keyword">*</span><span class="default">0x010000</span><span class="keyword">));
<br>&nbsp; &nbsp; }
<br>&nbsp; &nbsp; else{
<br>&nbsp; &nbsp; &nbsp; &nbsp; list(,</span><span class="default">$int</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);
<br>&nbsp; &nbsp; &nbsp; &nbsp; return </span><span class="default">$int</span><span class="keyword">;
<br>&nbsp; &nbsp; }
<br>}
<br></span><span class="default">?&gt;
<br></span>
<br>Do note that you *could* also use sprintf('%u', $x) to show the unsigned real value.
<br>Also note that (at least when PHP_INT_SIZE = 4) the result WILL be a float value when the input is larger then 0x7fffffff (just check with gettype);
<br>
<br>Hope this helps people.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="100548">  
  <a class="name">
  <strong class="user"><em>zac at picolink dot net</em></strong></a><div class="date" title="2010-10-22 08:33"><strong>3 years ago</strong></div>
  <div class="text" id="Hcom100548">
<div class="phpcode"><code><span class="html">
The documentation is clear that an integer read using an unsigned format character will still be stored as a signed integer.&nbsp; The often-cited work-around is to use sprintf('%u', $bigint) to properly display integers with the MSB set.<br><br>In the case where the numeric value is more important than how it's displayed, you can still work with other large integers using intval() to "upgrade" your existing unsigned integers.<br><br>I had a problem comparing 32-bit integers read from files with hard-coded constants (file signatures tend to need this).&nbsp; Here's what I did to avoid converting everything into strings:<br><br><span class="default">&lt;?php<br><br>$bigint </span><span class="keyword">= </span><span class="default">0x89504E47</span><span class="keyword">;<br><br></span><span class="default">$packed </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bigint</span><span class="keyword">);<br><br>list(</span><span class="default">$unpacked</span><span class="keyword">) = </span><span class="default">array_values</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$packed</span><span class="keyword">));<br><br></span><span class="comment">//The $bigint remains an unsigned integer.<br>//Even though their bit-wise values are identical, comparison fails.<br><br></span><span class="keyword">echo </span><span class="string">'bigint '</span><span class="keyword">,<br>&nbsp; (</span><span class="default">$bigint </span><span class="keyword">== </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br>&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br><br></span><span class="comment">//intval() triggers a re-interpretation of $bigint.<br>//$bigint is internally compared as a signed integer.<br>//Since the bit-wise value of $bigint never changes, comparison succeeds.<br><br></span><span class="keyword">echo </span><span class="string">'intval(bigint) '</span><span class="keyword">,<br>&nbsp; (</span><span class="default">intval</span><span class="keyword">(</span><span class="default">$bigint</span><span class="keyword">) == </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br>&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br><br></span><span class="default">?&gt;<br></span><br>It works, but it's a little backwards.&nbsp; If anyone has any ideas on how to "downgrade" a signed integer into an unsigned integer without using strings, that would be a valuable note to add to the documentation.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="87546">  
  <a class="name">
  <strong class="user"><em>jlarsen at fsu dot edu</em></strong></a><div class="date" title="2008-12-09 03:40"><strong>5 years ago</strong></div>
  <div class="text" id="Hcom87546">
<div class="phpcode"><code><span class="html">
As with perl, the count for hex is number of nybbles or half-bytes, this differs from the other options which count in full bytes.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="113359">  
  <a class="name">
  <strong class="user"><em>yvan dot burrie at hotmail dot com</em></strong></a><div class="date" title="2013-10-01 11:03"><strong>10 months ago</strong></div>
  <div class="text" id="Hcom113359">
<div class="phpcode"><code><span class="html">
Here's a demonstration concerning the speed of unpacking files:<br>So let's see which method is fastest between FREAD or SUBSTR?<br><br>I was creating a script that could read scenario files from a game, and render a preview of its terrain. The terrain structure within each file was huge (between 100,000 - 1,000,000 blocks containing 3 bits of data each). Therefore, I spent much effort to ensure it was fast and robust.<br><br>Method 1: This method retrieves the 3 bits of data found in each block. It uses the loop of widthxheight and implode+unpack+substr each block:<br><span class="default">&lt;?php<br></span><span class="keyword">for ( </span><span class="default">$Y </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$Y </span><span class="keyword">&lt; ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) ; </span><span class="default">$Y </span><span class="keyword">++ ) {<br>&nbsp; &nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">TerrainID </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br>&nbsp; &nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">Elevation </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br>&nbsp; &nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">Unknown </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br>}<br></span><span class="comment">//The average microtime was: 2.9 sec<br></span><span class="default">?&gt;<br></span>Note that it takes even more time if you use a custom function to implement the implode+unpack+substr functions.<br><br>Now... This method uses the FREAD function:<br><span class="default">&lt;?php<br></span><span class="keyword">for ( </span><span class="default">$Y </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$Y </span><span class="keyword">&lt; ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) ; </span><span class="default">$Y </span><span class="keyword">++ ) {<br>&nbsp; &nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] = </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c3' </span><span class="keyword">, </span><span class="default">fread </span><span class="keyword">( </span><span class="default">$sc </span><span class="keyword">, </span><span class="default">3 </span><span class="keyword">) ) ;<br>}<br></span><span class="comment">//Average microtime was: 0.7 sec<br></span><span class="default">?&gt;<br></span>I recommend using the FREAD method instead of SUBSTR.<br><br>Another test!!! This method is 10x faster than the above. This does not use the FOR loop:<br><span class="default">&lt;?php<br>$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">Data </span><span class="keyword">] = </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c' </span><span class="keyword">. ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) , </span><span class="default">stream_get_contents </span><span class="keyword">( </span><span class="default">$sc </span><span class="keyword">) ) ;<br></span><span class="comment">//Average microtime: 0.08 - 0.05 sec<br></span><span class="default">?&gt;<br></span><br>If you want to read files much faster, you should try to reduce the number of loops and use the unpack function to its simplest and robust method.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="110102">  
  <a class="name">
  <strong class="user"><em>googlybash24 at aol dot com</em></strong></a><div class="date" title="2012-09-19 05:20"><strong>1 year ago</strong></div>
  <div class="text" id="Hcom110102">
<div class="phpcode"><code><span class="html">
To convert big endian to little endian or to convert little endian to big endian, use the following approach as an example:<br><br><span class="default">&lt;?php<br></span><span class="comment">// file_get_contents() returns a binary value, unpack("V*", _ ) returns an unsigned long 32-bit little endian decimal value, but bin2hex() after that would just give the hex data in the file if alone, so instead we use:<br>// file_get_contents(), unpack("V*", _ ), then dechex(), in that order, to get the byte-swapping effect.<br></span><span class="default">?&gt;<br></span><br>With the logic of the approach in this example, you can discover how to swap the endian byte order as you need.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="100326">  
  <a class="name">
  <strong class="user"><em>Aaron Wells</em></strong></a><div class="date" title="2010-10-08 03:06"><strong>3 years ago</strong></div>
  <div class="text" id="Hcom100326">
<div class="phpcode"><code><span class="html">
Another option for converting binary data into PHP data types, is to use the Zend Framework's Zend_Io_Reader class:<br><a rel="nofollow" target="_blank">http://bit.ly/9zAhgz</a><br><br>There's also a Zend_Io_Writer class that does the reverse.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="97177">  
  <a class="name">
  <strong class="user"><em>norwood at computer dot org</em></strong></a><div class="date" title="2010-04-06 02:15"><strong>4 years ago</strong></div>
  <div class="text" id="Hcom97177">
<div class="phpcode"><code><span class="html">
Reading a text cell from an Excel spreadsheet returned a string with low-order embedded nulls: 0x4100 0x4200 etc. To remove the nulls, used
<br>
<br><span class="default">&lt;?php
<br>$strWithoutNulls </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">( </span><span class="string">''</span><span class="keyword">, </span><span class="default">explode</span><span class="keyword">( </span><span class="string">"\0"</span><span class="keyword">, </span><span class="default">$strWithNulls </span><span class="keyword">) );
<br></span><span class="default">?&gt;
<br></span>
<br>(unpack() didn't seem to help much here; needed chars back to re-constitute the string, not integers.)</span>
</code></div>
  </div>
 </div>
  <div class="note" id="93714">  
  <a class="name">
  <strong class="user"><em>Anonymous</em></strong></a><div class="date" title="2009-09-23 08:02"><strong>4 years ago</strong></div>
  <div class="text" id="Hcom93714">
<div class="phpcode"><code><span class="html">
Functions I found useful when dealing with fixed width file processing, related to unpack/pack functions.<br><span class="default">&lt;?php<br></span><span class="comment">/**<br>* funpack<br>* format: array of key, length pairs<br>* data: string to unpack<br>*/<br></span><span class="keyword">function </span><span class="default">funpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">){<br>&nbsp; &nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$result</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">trim</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">));<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$pos</span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return </span><span class="default">$result</span><span class="keyword">;<br>}<br><br></span><span class="comment">/**<br>* fpack<br>* format: array of key, length pairs<br>* data: array of key, value pairs to pack<br>* pad: padding direction<br>*/<br></span><span class="keyword">function </span><span class="default">fpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pad </span><span class="keyword">= </span><span class="default">STR_PAD_RIGHT</span><span class="keyword">){<br>&nbsp; &nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">){<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$result </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">], </span><span class="default">$len</span><span class="keyword">, </span><span class="default">$pad</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return </span><span class="default">$result</span><span class="keyword">;<br>}<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="92344">  
  <a class="name">
  <strong class="user"><em>sica at wnet com br</em></strong></a><div class="date" title="2009-07-20 12:45"><strong>5 years ago</strong></div>
  <div class="text" id="Hcom92344">
<div class="phpcode"><code><span class="html">
The script following is a example how to save more than one values on file separating its with "\r\n" and how to recovering its values.<br><br><span class="default">&lt;?php<br></span><span class="comment">// Save two integer values in a binary file<br></span><span class="default">$nomearq </span><span class="keyword">= </span><span class="string">"./teste.bin"</span><span class="keyword">;<br></span><span class="default">$valor </span><span class="keyword">= </span><span class="default">123</span><span class="keyword">;<br></span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"wb"</span><span class="keyword">);<br></span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br>echo </span><span class="string">"First value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br>echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br>echo </span><span class="string">"Separator \\r\\n with "</span><span class="keyword">;<br>echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br></span><span class="default">$valor </span><span class="keyword">= </span><span class="default">456</span><span class="keyword">;<br></span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br>echo </span><span class="string">"Second value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br>echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br></span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br><br></span><span class="comment">// Recover the saved values<br></span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">);<br></span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">file</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">,</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">));<br>echo </span><span class="string">"&lt;br&gt;The reading values is:&lt;br&gt;"</span><span class="keyword">;<br>foreach(</span><span class="default">$valorBin </span><span class="keyword">as </span><span class="default">$valor</span><span class="keyword">){<br>&nbsp; </span><span class="default">$valor </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br>&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$valor</span><span class="keyword">);<br>&nbsp; echo </span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br>}<br></span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span><br>Results:<br>First value (123) packed with 4 bytes<br>Separator \r\n with 2 bytes<br>Second value (456) packed with 4 bytes<br><br>The reading values is:<br>Array ( [1] =&gt; 123 ) <br>Array ( [1] =&gt; 456 )</span>
</code></div>
  </div>
 </div>
  <div class="note" id="82146">  
  <a class="name">
  <strong class="user"><em>Anonymous Coward</em></strong></a><div class="date" title="2008-03-28 10:52"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom82146">
<div class="phpcode"><code><span class="html">
Warning: This unpack function makes the array with keys starting at 1 instead of starting at 0.<br><br>For example:<br><span class="default">&lt;?php<br> </span><span class="keyword">function </span><span class="default">read_field</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">) {<br>&nbsp; </span><span class="default">$a</span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">,</span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">));<br>&nbsp; return </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br> }<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="80972">  
  <a class="name">
  <strong class="user"><em>joe dot nemeth @ palg dot com</em></strong></a><div class="date" title="2008-02-08 10:29"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom80972">
<div class="phpcode"><code><span class="html">
A simpler solution is to mask the value with 0xffffffff. For instance:<br><br><span class="default">&lt;?php<br>$rec </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(<br>&nbsp; </span><span class="string">"Vvalue/"</span><span class="keyword">.<br>&nbsp; </span><span class="string">"Vhash32/"</span><span class="keyword">,<br>&nbsp; </span><span class="default">$recbin</span><span class="keyword">);<br></span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'hash32'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br></span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'value'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br></span><span class="default">?&gt;<br></span><br>Unlike sprintf(), which converts the value to a string, this preserves the numeric type of the value.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="80914">  
  <a class="name">
  <strong class="user"><em>Shawn Kelly</em></strong></a><div class="date" title="2008-02-06 12:14"><strong>6 years ago</strong></div>
  <div class="text" id="Hcom80914">
<div class="phpcode"><code><span class="html">
Above it says this:<br><br>&nbsp; "Note that PHP internally stores integral values as signed. If&nbsp; you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br><br>This happened to me.&nbsp; I wanted to get a big number from a unsigned long, but it kept coming returning a negative.&nbsp; Happened to notice that sprintf('%u',$dta) will take the useless negative and restore it into its large unsigned proper magnitude.<br><br>Hope this saves someone a little time...</span>
</code></div>
  </div>
 </div>
  <div class="note" id="22398">  
  <a class="name">
  <strong class="user"><em>adam at adeptsoftware dot com</em></strong></a><div class="date" title="2002-06-16 09:01"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom22398">
<div class="phpcode"><code><span class="html">
If you just want to extract a dword/long int from a binary string, the following code works beautifully (intel endian):<br><br>$Number = ord($Buffer{0}) | (ord($Buffer{1})&lt;&lt;8) | (ord($Buffer{2})&lt;&lt;16) | (ord($Buffer{3})&lt;&lt;24);</span>
</code></div>
  </div>
 </div>
  <div class="note" id="12395">  
  <a class="name">
  <strong class="user"><em>DanRichter.at.programmer.dot.net</em></strong></a><div class="date" title="2001-04-10 11:26"><strong>13 years ago</strong></div>
  <div class="text" id="Hcom12395">
<div class="phpcode"><code><span class="html">
If no key name is given [e.g., unpack('C*',$data)], the keys are simply integers starting at 1, and you have a standard array. (I know of no way to get the array to start at zero.)
<br>
<br>If you use multiple types, you must give a key name for all of them (except optionally one), because the key counter is reset with each slash. For example, in unpack('n2/C*',$data), indices 1 and 2 of the returned array are filled by integers ('n'), then overwritten with characters ('C').</span>
</code></div>
  </div>
 </div>
  <div class="note" id="4319">  
  <a class="name">
  <strong class="user"><em>iredden at redden dot on dot ca</em></strong></a><div class="date" title="2000-03-11 04:34"><strong>14 years ago</strong></div>
  <div class="text" id="Hcom4319">
<div class="phpcode"><code><span class="html">
<span class="default">&lt;?php
<br>
<br></span><span class="keyword">function </span><span class="default">parse_pascalstr</span><span class="keyword">(</span><span class="default">$bytes_parsed</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">) { 
<br>&nbsp; &nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/cstr_len"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">);
<br>&nbsp; &nbsp; </span><span class="default">$str_len </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str_len"</span><span class="keyword">]; 
<br>&nbsp; &nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">; 
<br>&nbsp; &nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/A"</span><span class="keyword">.</span><span class="default">$str_len</span><span class="keyword">.</span><span class="string">"str"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">); 
<br>&nbsp; &nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str"</span><span class="keyword">]; 
<br>&nbsp; &nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); 
<br>
<br>&nbsp; &nbsp; return array(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$bytes_parsed</span><span class="keyword">); 
<br>}
<br>
<br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div>
  <div class="note" id="108599">  
  <a class="name">
  <strong class="user"><em>kobrasrealm at gmail dot com</em></strong></a><div class="date" title="2012-05-09 05:50"><strong>2 years ago</strong></div>
  <div class="text" id="Hcom108599">
<div class="phpcode"><code><span class="html">
I wrote a quick pair of functions using pack/unpack for converting between raw binary (e.g. openssl_random_pseudo_bytes() output) and hexadecimal (e.g. hash() output):<br><br><span class="default">&lt;?php<br></span><span class="keyword">function </span><span class="default">raw2hex</span><span class="keyword">(</span><span class="default">$raw</span><span class="keyword">) {<br>&nbsp; </span><span class="default">$m </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">$raw</span><span class="keyword">);<br>&nbsp; return </span><span class="default">$m</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br>}<br><br>function </span><span class="default">hex2raw</span><span class="keyword">(</span><span class="default">$hex</span><span class="keyword">) { <br>&nbsp; return </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">$hex</span><span class="keyword">);<br>}<br></span><span class="default">?&gt;<br></span><br>Feel free to suggest any improvements, but I thought this was worth sharing.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="57612">  
  <a class="name">
  <strong class="user"><em>Justin dot SpahrSummers at gmail dot com</em></strong></a><div class="date" title="2005-10-08 12:10"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom57612">
<div class="phpcode"><code><span class="html">
I hadn't realized that if the number after the unpack type was 1 (i.e. "V1page"), that it would behave as if there was no number at all. I had been using a variable and didn't think to watch for this. For instance,<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">if (</span><span class="default">$something</span><span class="keyword">)<br>&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">;<br>else<br>&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br><br></span><span class="default">$arr </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V" </span><span class="keyword">. </span><span class="default">$get </span><span class="keyword">. </span><span class="string">"page"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br><br></span><span class="default">?&gt;<br></span><br>Now if $something was FALSE, then $arr will only have one entry named "page". If $something was TRUE, $arr would have "page1" and "page2".</span>
</code></div>
  </div>
 </div>
  <div class="note" id="52527">  
  <a class="name">
  <strong class="user"><em>info at dreystone dot com</em></strong></a><div class="date" title="2005-05-04 11:31"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom52527">
<div class="phpcode"><code><span class="html">
Here is my solution to reading a Big-Endian formatted double on an Little-Endian machine.<br><br><span class="default">&lt;?php<br><br></span><span class="keyword">function </span><span class="default">ToDouble</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">) {<br>&nbsp; &nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"S*"</span><span class="keyword">, </span><span class="default">256</span><span class="keyword">));<br>&nbsp; &nbsp; if(</span><span class="default">$t</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] == </span><span class="default">1</span><span class="keyword">) {<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br>&nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">strrev</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">));<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return (double)</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br>}<br><br></span><span class="default">?&gt;</span>
</span>
</code></div>
  </div>
 </div></div>

 
</section>    </section><!-- layout-content -->
        


  </div><!-- layout -->
         
  

    
 <!-- External and third party libraries. -->
 







<a id="toTop" href="javascript:;"><span id="toTopHover"></span><img width="40" height="40" alt="To Top" src="../../images/to-top%402x.png"></a>



<!-- Mirrored from php.net/manual/en/function.unpack.php by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 28 Aug 2014 16:05:09 GMT -->


</body></html>