<html><!-- Mirrored from php.net/manual/en/function.fpassthru.php by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 28 Aug 2014 16:04:27 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->


  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 

  <title>fpassthru</title>

 <link rel="shortcut icon" href="../../favicon.ico">
 <link rel="search" type="application/opensearchdescription+xml" href="http://php.net/phpnetimprovedsearch.src" title="Add PHP.net search">
 <link rel="alternate" type="application/atom+xml" href="http://php.net/releases/feed.php" title="PHP Release feed">
 <link rel="alternate" type="application/atom+xml" href="http://php.net/feed.atom" title="PHP: Hypertext Preprocessor">

 <link rel="canonical" href="function.fpassthru.html">
 <link rel="shorturl" href="http://php.net/fpassthru">
 <link rel="alternate" href="http://php.net/fpassthru" hreflang="x-default">

 <link rel="contents" href="index-2.html">
 <link rel="index" href="ref.filesystem.html">
 <link rel="prev" href="function.fopen.html">
 <link rel="next" href="function.fputcsv.html">

 <link rel="alternate" href="function.fpassthru.html" hreflang="en">
 <link rel="alternate" href="http://php.net/manual/pt_BR/function.fpassthru.php" hreflang="pt_BR">
 <link rel="alternate" href="http://php.net/manual/zh/function.fpassthru.php" hreflang="zh">
 <link rel="alternate" href="http://php.net/manual/fr/function.fpassthru.php" hreflang="fr">
 <link rel="alternate" href="http://php.net/manual/de/function.fpassthru.php" hreflang="de">
 <link rel="alternate" href="http://php.net/manual/it/function.fpassthru.php" hreflang="it">
 <link rel="alternate" href="http://php.net/manual/ja/function.fpassthru.php" hreflang="ja">
 <link rel="alternate" href="http://php.net/manual/ro/function.fpassthru.php" hreflang="ro">
 <link rel="alternate" href="http://php.net/manual/ru/function.fpassthru.php" hreflang="ru">
 <link rel="alternate" href="http://php.net/manual/es/function.fpassthru.php" hreflang="es">
 <link rel="alternate" href="http://php.net/manual/tr/function.fpassthru.php" hreflang="tr">

<link rel="stylesheet" type="text/css" href="../../cached8fe1.css?t=1401250819&amp;f=/fonts/Fira/fira.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached4b8d.css?t=1404368420&amp;f=/fonts/Font-Awesome/css/fontello.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cached5065.css?t=1403329232&amp;f=/styles/theme-base.css" media="screen">
<link rel="stylesheet" type="text/css" href="../../cachedc78d.css?t=1401249623&amp;f=/styles/theme-medium.css" media="screen">

 <!--[if lte IE 7]>
 <link rel="stylesheet" type="text/css" href="http://php.net/styles/workarounds.ie7.css" media="screen">
 <![endif]-->

 <!--[if lte IE 8]>
 <script type="text/javascript">
  window.brokenIE = true;
 </script>
 <![endif]-->

 <!--[if lte IE 9]>
 <link rel="stylesheet" type="text/css" href="http://php.net/styles/workarounds.ie9.css" media="screen">
 <![endif]-->

 <!--[if IE]>
 <script type="text/javascript" src="http://php.net/js/ext/html5.js"></script>
 <![endif]-->

 <base>

</head>
<body class="docs " style="">


<div class="headsup"><a href="http://php.net/index.php#id2014-08-28-1">PHP 5.6.0 released</a></div>
<nav id="trick"><div><dl>
<dt><a href="getting-started.html">Getting Started</a></dt>
	<dd><a href="introduction.html">Introduction</a></dd>
	<dd><a href="tutorial.html">A simple tutorial</a></dd>
<dt><a href="langref.html">Language Reference</a></dt>
	<dd><a href="language.basic-syntax.html">Basic syntax</a></dd>
	<dd><a href="language.types.html">Types</a></dd>
	<dd><a href="language.variables.html">Variables</a></dd>
	<dd><a href="language.constants.html">Constants</a></dd>
	<dd><a href="language.expressions.html">Expressions</a></dd>
	<dd><a href="language.operators.html">Operators</a></dd>
	<dd><a href="language.control-structures.html">Control Structures</a></dd>
	<dd><a href="language.functions.html">Functions</a></dd>
	<dd><a href="language.oop5.html">Classes and Objects</a></dd>
	<dd><a href="language.namespaces.html">Namespaces</a></dd>
	<dd><a href="language.exceptions.html">Exceptions</a></dd>
	<dd><a href="language.generators.html">Generators</a></dd>
	<dd><a href="language.references.html">References Explained</a></dd>
	<dd><a href="reserved.variables.html">Predefined Variables</a></dd>
	<dd><a href="reserved.exceptions.html">Predefined Exceptions</a></dd>
	<dd><a href="reserved.interfaces.html">Predefined Interfaces and Classes</a></dd>
	<dd><a href="context.html">Context options and parameters</a></dd>
	<dd><a href="wrappers.html">Supported Protocols and Wrappers</a></dd>
</dl>
<dl>
<dt><a href="security.html">Security</a></dt>
	<dd><a href="security.intro.html">Introduction</a></dd>
	<dd><a href="security.general.html">General considerations</a></dd>
	<dd><a href="security.cgi-bin.html">Installed as CGI binary</a></dd>
	<dd><a href="security.apache.html">Installed as an Apache module</a></dd>
	<dd><a href="security.filesystem.html">Filesystem Security</a></dd>
	<dd><a href="security.database.html">Database Security</a></dd>
	<dd><a href="security.errors.html">Error Reporting</a></dd>
	<dd><a href="security.globals.html">Using Register Globals</a></dd>
	<dd><a href="security.variables.html">User Submitted Data</a></dd>
	<dd><a href="security.magicquotes.html">Magic Quotes</a></dd>
	<dd><a href="security.hiding.html">Hiding PHP</a></dd>
	<dd><a href="security.current.html">Keeping Current</a></dd>
<dt><a href="features.html">Features</a></dt>
	<dd><a href="features.http-auth.html">HTTP authentication with PHP</a></dd>
	<dd><a href="features.cookies.html">Cookies</a></dd>
	<dd><a href="features.sessions.html">Sessions</a></dd>
	<dd><a href="features.xforms.html">Dealing with XForms</a></dd>
	<dd><a href="features.file-upload.html">Handling file uploads</a></dd>
	<dd><a href="features.remote-files.html">Using remote files</a></dd>
	<dd><a href="features.connection-handling.html">Connection handling</a></dd>
	<dd><a href="features.persistent-connections.html">Persistent Database Connections</a></dd>
	<dd><a href="features.safe-mode.html">Safe Mode</a></dd>
	<dd><a href="features.commandline.html">Command line usage</a></dd>
	<dd><a href="features.gc.html">Garbage Collection</a></dd>
	<dd><a href="features.dtrace.html">DTrace Dynamic Tracing</a></dd>
</dl>
<dl>
<dt><a href="funcref.html">Function Reference</a></dt>
	<dd><a href="refs.basic.php.html">Affecting PHP's Behaviour</a></dd>
	<dd><a href="refs.utilspec.audio.html">Audio Formats Manipulation</a></dd>
	<dd><a href="refs.remote.auth.html">Authentication Services</a></dd>
	<dd><a href="refs.utilspec.cmdline.html">Command Line Specific Extensions</a></dd>
	<dd><a href="refs.compression.html">Compression and Archive Extensions</a></dd>
	<dd><a href="refs.creditcard.html">Credit Card Processing</a></dd>
	<dd><a href="refs.crypto.html">Cryptography Extensions</a></dd>
	<dd><a href="refs.database.html">Database Extensions</a></dd>
	<dd><a href="refs.calendar.html">Date and Time Related Extensions</a></dd>
	<dd><a href="refs.fileprocess.file.html">File System Related Extensions</a></dd>
	<dd><a href="refs.international.html">Human Language and Character Encoding Support</a></dd>
	<dd><a href="refs.utilspec.image.html">Image Processing and Generation</a></dd>
	<dd><a href="refs.remote.mail.html">Mail Related Extensions</a></dd>
	<dd><a href="refs.math.html">Mathematical Extensions</a></dd>
	<dd><a href="refs.utilspec.nontext.html">Non-Text MIME Output</a></dd>
	<dd><a href="refs.fileprocess.process.html">Process Control Extensions</a></dd>
	<dd><a href="refs.basic.other.html">Other Basic Extensions</a></dd>
	<dd><a href="refs.remote.other.html">Other Services</a></dd>
	<dd><a href="refs.search.html">Search Engine Extensions</a></dd>
	<dd><a href="refs.utilspec.server.html">Server Specific Extensions</a></dd>
	<dd><a href="refs.basic.session.html">Session Extensions</a></dd>
	<dd><a href="refs.basic.text.html">Text Processing</a></dd>
	<dd><a href="refs.basic.vartype.html">Variable and Type Related Extensions</a></dd>
	<dd><a href="refs.webservice.html">Web Services</a></dd>
	<dd><a href="refs.utilspec.windows.html">Windows Only Extensions</a></dd>
	<dd><a href="refs.xml.html">XML Manipulation</a></dd>
</dl>
<dl>
<dt>Keyboard Shortcuts</dt><dt>?</dt>
<dd>This help</dd>
<dt>j</dt>
<dd>Next menu item</dd>
<dt>k</dt>
<dd>Previous menu item</dd>
<dt>g p</dt>
<dd>Previous man page</dd>
<dt>g n</dt>
<dd>Next man page</dd>
<dt>G</dt>
<dd>Scroll to bottom</dd>
<dt>g g</dt>
<dd>Scroll to top</dd>
<dt>g h</dt>
<dd>Goto homepage</dd>
<dt>g s</dt>
<dd>Goto search<br>(current page)</dd>
<dt>/</dt>
<dd>Focus search box</dd>
</dl></div></nav>
<div id="goto">
    <div class="search">
         <div class="text"></div>
         <div class="results"><ul></ul></div>
   </div>
</div>

  <div id="breadcrumbs" class="row-fluid">
          
              
        <ul class="breadcrumbs-container">
            <li><a href="index-2.html">PHP Manual</a></li>      <li><a href="funcref.html">Function Reference</a></li>      <li><a href="refs.fileprocess.file.html">File System Related Extensions</a></li>      <li><a href="book.filesystem.html">Filesystem</a></li>      <li><a href="ref.filesystem.html">Filesystem Functions</a></li>    </ul>
  </div>




<div id="layout">
  <section id="layout-content">
  <div id="function.fpassthru" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">fpassthru</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">fpassthru</span> â€” <span class="dc-title">Output all remaining data on a file pointer</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.fpassthru-description">
  <h3 class="title">Description</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">int</span> <span class="methodname"><strong>fpassthru</strong></span>
    ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$handle</code></span>
   )</div>

  <p class="para rdfs-comment">
   Reads to EOF on the given file pointer from the current position and
   writes the results to the output buffer.
  </p>
  <p class="para">
   You may need to call <span class="function"><a href="function.rewind.html" class="function">rewind()</a></span> to reset the file
   pointer to the beginning of the file if you have already written data
   to the file.
  </p>
  <p class="para">
   If you just want to dump the contents of a file to the output buffer,
   without first modifying it or seeking to a particular offset, you may
   want to use the <span class="function"><a href="function.readfile.html" class="function">readfile()</a></span>, which saves you
   the <span class="function"><a href="function.fopen.html" class="function">fopen()</a></span> call.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.fpassthru-parameters">
  <h3 class="title">Parameters</h3>
  <p class="para">
   </p><dl>

    
     <dt>
<code class="parameter">handle</code></dt>

     <dd>

      <p class="para">The file pointer must be valid, and must point to
a file successfully opened by <span class="function"><a href="function.fopen.html" class="function">fopen()</a></span> or
<span class="function"><a href="function.fsockopen.html" class="function">fsockopen()</a></span> (and not yet closed by
<span class="function"><a href="function.fclose.html" class="function">fclose()</a></span>).</p>
     </dd>

    
   </dl>

  <p></p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.fpassthru-returnvalues">
  <h3 class="title">Return Values</h3>
  <p class="para">
   If an error occurs, <span class="function"><strong>fpassthru()</strong></span> returns
   <strong><code>FALSE</code></strong>.  Otherwise, <span class="function"><strong>fpassthru()</strong></span> returns
   the number of characters read from <code class="parameter">handle</code>
   and passed through to the output.
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.fpassthru-examples">
  <h3 class="title">Examples</h3>
  <p class="para">
   </p><div class="example" id="example-2480">
    <p><strong>Example #1 Using <span class="function"><strong>fpassthru()</strong></span> with binary files</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br><br></span><span style="color: #FF8000">//&nbsp;open&nbsp;the&nbsp;file&nbsp;in&nbsp;a&nbsp;binary&nbsp;mode<br></span><span style="color: #0000BB">$name&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'./img/ok.png'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$fp&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">fopen</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'rb'</span><span style="color: #007700">);<br><br></span><span style="color: #FF8000">//&nbsp;send&nbsp;the&nbsp;right&nbsp;headers<br></span><span style="color: #0000BB">header</span><span style="color: #007700">(</span><span style="color: #DD0000">"Content-Type:&nbsp;image/png"</span><span style="color: #007700">);<br></span><span style="color: #0000BB">header</span><span style="color: #007700">(</span><span style="color: #DD0000">"Content-Length:&nbsp;"&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">filesize</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">));<br><br></span><span style="color: #FF8000">//&nbsp;dump&nbsp;the&nbsp;picture&nbsp;and&nbsp;stop&nbsp;the&nbsp;script<br></span><span style="color: #0000BB">fpassthru</span><span style="color: #007700">(</span><span style="color: #0000BB">$fp</span><span style="color: #007700">);<br>exit;<br><br></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  <p></p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.fpassthru-notes">
  <h3 class="title">Notes</h3>
  <blockquote class="note"><p><strong class="note">Note</strong>: 
   </p><p class="para">
    When using <span class="function"><strong>fpassthru()</strong></span> on a binary file on Windows
    systems, you should make sure to open the file in binary mode by
    appending a <em>b</em> to the mode used in the call to
    <span class="function"><a href="function.fopen.html" class="function">fopen()</a></span>.
   </p>
   <p class="para">
    You are encouraged to use the <em>b</em> flag when dealing
    with binary files, even if your system does not require it, so that
    your scripts will be more portable.
   </p>
  <p></p></blockquote>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.fpassthru-seealso">
  <h3 class="title">See Also</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li class="member"><span class="function"><a href="function.readfile.html" class="function" rel="rdfs-seeAlso">readfile()</a> - Outputs a file</span></li>
    <li class="member"><span class="function"><a href="function.fopen.html" class="function" rel="rdfs-seeAlso">fopen()</a> - Opens file or URL</span></li>
    <li class="member"><span class="function"><a href="function.popen.html" class="function" rel="rdfs-seeAlso">popen()</a> - Opens process file pointer</span></li>
    <li class="member"><span class="function"><a href="function.fsockopen.html" class="function" rel="rdfs-seeAlso">fsockopen()</a> - Open Internet or Unix domain socket connection</span></li>
   </ul>
  <p></p>
 </div>


</div>
<section id="usernotes">
 <div class="head"><h3 class="title">User Contributed Notes</h3></div><div id="allnotes">
  <div class="note" id="112360">  
  <a class="name">
  <strong class="user"><em>RaulentRoi</em></strong></a><div class="date" title="2013-06-06 02:55"><strong>1 year ago</strong></div>
  <div class="text" id="Hcom112360">
<div class="phpcode"><code><span class="html">
Passthru didn't work for me for files greater than about 5Mb. Just adding "ob_end_clean()", all works fine now, including &gt; 50Mb files.<br><br>$ToProtectedFile=$pathUnder.$filename<br>$handle = @fopen($ToProtectedFile, "rb");<br><br>@header("Cache-Control: no-cache, must-revalidate"); <br>@header("Pragma: no-cache"); //keeps ie happy<br>@header("Content-Disposition: attachment; filename= ".$NomFichier);<br>@header("Content-type: application/octet-stream");<br>@header("Content-Length: ".$SizeOfFile);<br>@header('Content-Transfer-Encoding: binary');<br><br>ob_end_clean();//required here or large files will not work<br>@fpassthru($handle);//works fine now</span>
</code></div>
  </div>
 </div>
  <div class="note" id="30740">  
  <a class="name">
  <strong class="user"><em>Omega2k at web dot de</em></strong></a><div class="date" title="2003-03-27 05:07"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom30740">
<div class="phpcode"><code><span class="html">
To throttle download-speed of specific files this works fine in my board hosted on my local machine:<br><br>//#######################################<br> $big_file=filesize($completeFilePath)/1024; //size of file in kb<br> header('Content-Type: '.$mime_type);<br> header('Content-disposition: '.$content_disp.'filename="'.$attachment_name.'"');<br> header('Cache-Control: no-cache');<br> header('Pragma: no-cache');<br> header('Expires: 0');<br> header('Content-Length: '.(string)(filesize($completeFilePath))); <br> $fp=fopen($completeFilePath,'r');<br> while(!feof($fp)) {<br>&nbsp; &nbsp;&nbsp; $buffer = fread($fp, 1024*6); //speed-limit 6kb/s<br>&nbsp; &nbsp;&nbsp; if ($big_file&gt;32 &amp;&amp; <br>&nbsp; &nbsp;&nbsp; $extension!="jpg" &amp;&amp; <br>&nbsp; &nbsp;&nbsp; $extension!="jpeg" &amp;&amp; <br>&nbsp; &nbsp;&nbsp; $extension!="gif" &amp;&amp; <br>&nbsp; &nbsp;&nbsp; $extension!="png" &amp;&amp; <br>&nbsp; &nbsp;&nbsp; $extension!="txt")<br>&nbsp; &nbsp;&nbsp; sleep(1); //if filesize&gt;32kb and no smallfile like jpg,gif or so - wait 1 second<br>&nbsp; &nbsp;&nbsp; print $buffer;<br> }<br> fclose($fp);<br> header ("Connection: close");<br>//#######################################<br><br>I think it's the easiest way to slow down downloading files without using a loop or for-next - this really saves performace of php and is quite exact by using 1024*number_of_kb in one second...<br><br>Thats all<br><br>Greetings, omega2k.dynu.com</span>
</code></div>
  </div>
 </div>
  <div class="note" id="48244">  
  <a class="name">
  <strong class="user"><em>webmaster at hardcorehoneyz dot com</em></strong></a><div class="date" title="2004-12-16 05:20"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom48244">
<div class="phpcode"><code><span class="html">
In relation to using sessions and fpassthru together.<br><br>Try adding: session_write_close()<br><br>somewhere near the top of the download script, before you start sending the video, and that should take care of it.<br><br>I've implemented and tested session_write_close() and it works like a dream. Other links can now be clicked and loaded whilst a big file is being passed using fpassthru.<br><br>Big thanks to Greg for this tip. What a helpful community we live in :0)</span>
</code></div>
  </div>
 </div>
  <div class="note" id="26414">  
  <a class="name">
  <strong class="user"><em>claude_minette at hotmail dot com</em></strong></a><div class="date" title="2002-10-30 03:51"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom26414">
<div class="phpcode"><code><span class="html">
This code works fine with a download manager... maybe not the best solution, but the only one that works with IE!!!!!<br><br>It forces download, but gif file don't want to be downloaded!!! so I need to simply display them in browser...<br><br>NB $file is the result of a query on the file table...<br><br>require_once("auth.inc.php");<br>$attachment = (strstr($HTTP_USER_AGENT, "MSIE")) ? "" : " attachment"; // IE 5.5 fix.<br>//Content of file<br>if (!headers_sent()){<br>&nbsp;&nbsp; $ficexp=explode('.',$file["orig_name"]);<br>&nbsp;&nbsp; $ext=$ficexp[sizeof($ficexp)-1];<br>&nbsp;&nbsp; if ($ext!='gif'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header('Cache-Control: no-cache, must-revalidate');<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header('Pragma: no-cache');<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header("Content-Type: application/force-download");<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header("Content-Length: ".filesize("files/".$file["save_name"]));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header("Content-Disposition: ".$attachment."; filename=".$file["orig_name"]);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; $fn=fopen("files/".$file["save_name"], "rb");<br>&nbsp;&nbsp; fpassthru($fn);<br>}<br>else {<br>&nbsp; &nbsp; MessageBox('Headers already sent, cannot force download!');<br>}<br><br>Min's</span>
</code></div>
  </div>
 </div>
  <div class="note" id="42557">  
  <a class="name">
  <strong class="user"><em>nexz2004 at yahoo dot com</em></strong></a><div class="date" title="2004-05-21 12:30"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom42557">
<div class="phpcode"><code><span class="html">
also it is possible to make your php script resume downloads, to do this you need to check $_SERVER['HTTP_RANGE'] which may contain something like this<br> "bytes=10-" - resume from position 10, and to end of file<br><br>when sending response it is also needed to send with headers<br>Accept-Ranges: bytes<br>Content-Length: {filesize}<br>Content-Range: bytes 10-{filesize-1}/{ffilesize}<br><br>hope its usefull</span>
</code></div>
  </div>
 </div>
  <div class="note" id="31899">  
  <a class="name">
  <strong class="user"><em>DarkAngela_ at hotmail dot com</em></strong></a><div class="date" title="2003-05-08 04:48"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom31899">
<div class="phpcode"><code><span class="html">
Just a little thing more from the ssharma's script (thx to him for his great help ...) :<br><br>Don't forget to put the fopen with the "rb" argument and not just with the "r" <br>or you won't be able to make the script work with all pdf file.<br><br>My final script (working for Open and Save on a 1.9 Mb complex PDF file) :<br><br><span class="default">&lt;?php<br></span><span class="comment">//The filename is stored in the $produitFilename variable in my script (the only thing you need)<br><br>// You need to specify the REAL path for your file and not the URL<br></span><span class="default">$fullPath&nbsp; &nbsp; </span><span class="keyword">= </span><span class="default">getcwd</span><span class="keyword">().</span><span class="string">"./directory_where_the_file_is/"</span><span class="keyword">.</span><span class="default">$produitFilename</span><span class="keyword">;<br><br>if (</span><span class="default">$fd </span><span class="keyword">= </span><span class="default">fopen </span><span class="keyword">(</span><span class="default">$fullPath</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">)) {<br>&nbsp; &nbsp; </span><span class="default">$fsize&nbsp; &nbsp; </span><span class="keyword">=</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$fullPath</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">$fname&nbsp; &nbsp;&nbsp; </span><span class="keyword">= </span><span class="default">basename </span><span class="keyword">(</span><span class="default">$fullPath</span><span class="keyword">);<br><br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Pragma: "</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Cache-Control: "</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-type: application/octet-stream"</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-Disposition: attachment; filename=\""</span><span class="keyword">.</span><span class="default">$fname</span><span class="keyword">.</span><span class="string">"\""</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-length: </span><span class="default">$fsize</span><span class="string">"</span><span class="keyword">);<br><br>&nbsp; &nbsp; </span><span class="default">fpassthru</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">);<br>}<br></span><span class="default">?&gt;<br></span><br>Have fun and thx u all 4 ur great help ...<br><br>Simon (from Paris - France)</span>
</code></div>
  </div>
 </div>
  <div class="note" id="24649">  
  <a class="name">
  <strong class="user"><em>mikek at muonics dot nospam dot c dot o dot m</em></strong></a><div class="date" title="2002-08-24 09:14"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom24649">
<div class="phpcode"><code><span class="html">
A few notes on using fpassthru() to php-driven download links that pop up a "Save As.." dialog:<br><br>1. I found that the download progress dialog was remaining up for several seconds after the transfer was completed, before telling the user it was complete.&nbsp; This was fixed by adding the following header:<br><br>header ("Connection: close");<br><br>This will cause the connection to be closed as soon as the transfer is complete, rather than waiting for a timeout.<br><br>2. If you have multiple periods in the filename, you might wind up with a filename with numbers in brackets (such as myfile-[1][0]-windows.zip when you put myfile-1.0-windows.zip in the headers) with MSIE.&nbsp; According to Microsoft's KB, his is a "known" bug having to due with MSIE's cache and there's no workaround that I was able to find.<br><br>3. Through no amount of futzing of headers was I able to get the filename to be set properly when the actual transfer was initiated via a refresh (META or via headers).&nbsp; I don't know if this is also an MSIE only issue or not.&nbsp; If 'download.php?dl=now' (for example) had a refresh back to 'download.php', such that it was intended to show some information (e.g. install instructions) as well as launch the download, then the MSIE insisted that the downloaded file was supposed to be named 'download.php?dl=now' or 'download.php', ignoring the filename in the headers.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="29162">  
  <a class="name">
  <strong class="user"><em>brett at NOSPAM dot brettbrewer dot com</em></strong></a><div class="date" title="2003-02-04 02:49"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom29162">
<div class="phpcode"><code><span class="html">
The above method worked for me after trying everything else imaginable to get Explorer to download a file via PHP. However, I had to change the content-length line. No need to "stringify" the $size variable as in the above post. The method below works for both small and very large file (tested on files larger than 30MB with no probs)...<br><br><span class="default">&lt;?php<br>$distribution</span><span class="keyword">=</span><span class="string">"/path/to/a/file.exe"<br></span><span class="keyword">if (</span><span class="default">$fd </span><span class="keyword">= </span><span class="default">fopen </span><span class="keyword">(</span><span class="default">$distribution</span><span class="keyword">, </span><span class="string">"r"</span><span class="keyword">)){<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$size</span><span class="keyword">=</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$distribution</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">$fname </span><span class="keyword">= </span><span class="default">basename </span><span class="keyword">(</span><span class="default">$distribution</span><span class="keyword">);<br><br></span><span class="comment">//This is some really weak code I used just to redirect to the file before I fixed<br>//this problem...it makes the browser handle the download via Apache instead of PHP<br>//but it would be really easy to then find out the true location of the file<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //header("Location: $distribution");<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //fclose ($fd);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //exit;<br><br>//below is a much better way to do it...<br><br>&nbsp; &nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Pragma: "</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Cache-Control: "</span><span class="keyword">);<br>&nbsp; &nbsp;&nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-type: application/octet-stream"</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-Disposition: attachment; filename=\""</span><span class="keyword">.</span><span class="default">$fname</span><span class="keyword">.</span><span class="string">"\""</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-length: </span><span class="default">$size</span><span class="string">"</span><span class="keyword">);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$buffer </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">, </span><span class="default">2048</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print </span><span class="default">$buffer</span><span class="keyword">;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">fclose </span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit;<br>}<br></span><span class="default">?&gt;<br></span><br>Good luck.<br>Brett Brewer.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="25758">  
  <a class="name">
  <strong class="user"><em>mikek at muonics dot nospam dot c dot o</em></strong></a><div class="date" title="2002-10-04 08:48"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom25758">
<div class="phpcode"><code><span class="html">
If your downloaded files are getting corrupted, one of the scripts included/required in your download script or page may have whitespace around the <span class="default">&lt;?php ?&gt;</span> tags.&nbsp; A common enough problem, but most often recognized when header() fails, due to headers already being sent, but one worth mention here.<br><br>This one bit me just recently with my download script.&nbsp; Somewhere along the way adding functionality to my website, I wound up with a space (not a blank line, which I usually spot right away, but a single space character) after the closing ?&gt; tag in one of the require()'d files.&nbsp; Oddly enough, all the downloads seemed to work ok, but the files were corrupted: that space character wound up at the beginning of each file.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="23681">  
  <a class="name">
  <strong class="user"><em>-</em></strong></a><div class="date" title="2002-07-24 04:37"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom23681">
<div class="phpcode"><code><span class="html">
If you trying to output a user-written file on a page for verifying, editing, etc, you'll want to use fopen(), fread(), htmlentities() to avoid malicious code. Text from fpassthru, while not parsed per se can still mess up the display of a page (or at least it did for me!) --mt.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="20474">  
  <a class="name">
  <strong class="user"><em>php at brayra dot com</em></strong></a><div class="date" title="2002-04-04 12:25"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom20474">
<div class="phpcode"><code><span class="html">
Here is a final working copy that won't freak out Microsoft Explorer if you are using sessions. Thanks to everyone else who came before. This is not as simple as I thought it would be.<br><br>the user would pass a call to the page:<br><a rel="nofollow" target="_blank">http://mysite/getfile.php?file=products.pdf</a><br><br>include 'base.inc'; // inlcude base code, start session&nbsp; and manage users<br><br>// This loads the file global from the post/get variables<br>// For security reasons register globals is disabled<br>LoadPostGet('file');<br><br>$filename = '/data/files/' . $file;<br>if(file_exists($filename)){<br>&nbsp; $FILECMD = '/usr/bin/file';<br>&nbsp; $contentType = '';<br>&nbsp; $fp=popen("$FILECMD -bin $filename", 'r');<br>&nbsp; if (!$fp) $contentType='application/octet-stream';<br>&nbsp; else {<br>&nbsp; &nbsp; while($string=fgets($fp, 1024)) $contentType .= $string;<br>&nbsp; &nbsp; pclose($fp);<br>&nbsp; }<br>&nbsp; if(strpos($HTTP_SERVER_VARS['HTTP_USER_AGENT'], 'MSIE')){<br>&nbsp; &nbsp; // IE cannot download from sessions without a cache<br>&nbsp; &nbsp; header('Cache-Control: public');<br>&nbsp; }<br>&nbsp; header("Content-type: $contentType");<br>&nbsp; header("Content-Disposition:inline; filename=\"".$file."\"");<br>&nbsp; header("Content-length:".(string)(filesize($filename)));<br>&nbsp; $fd=fopen($filename,'rb');<br>&nbsp; while(!feof($fd)) {<br>&nbsp; &nbsp; print fread($fd, 4096);<br>&nbsp; }<br>&nbsp; fclose($fd);<br>}else{<br>&nbsp; print "File Not Found";<br>}</span>
</code></div>
  </div>
 </div>
  <div class="note" id="18445">  
  <a class="name">
  <strong class="user"><em>mirko at mcaserta dot com</em></strong></a><div class="date" title="2002-01-23 05:07"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom18445">
<div class="phpcode"><code><span class="html">
Update to the above. This also sets the correct mime type for the file you're sending. It's a small hack since it relies on the "file" system command but it should work well.<br><br>&lt;?<br>// full path to the file command<br>$FILECMD='/usr/bin/file';<br>// directory where the file resides<br>$fileDir='/home/mcaserta';<br>// full file name<br>$fileName='test.sh';<br><br>// END CONFIG<br><br>$completeFilePath=$fileDir.'/'.$fileName;<br>$fp=popen("$FILECMD -bin $completeFilePath", 'r');<br><br>if (! $fp) $contentType='application/octet-stream';<br>else {<br>&nbsp; while($string=fgets($fp, 1024)) $contentType .= $string;<br>&nbsp; pclose($fp);<br>}<br><br>header('Content-type: '.($contentType));<br>header('Content-Disposition: inline; filename="'.($fileName).'"');<br>header('Content-length: '.(string)(filesize($completeFilePath)));<br>$fd=fopen($completeFilePath,'r');<br>fpassthru($fd); <br>?&gt;</span>
</code></div>
  </div>
 </div>
  <div class="note" id="74080">  
  <a class="name">
  <strong class="user"><em>sarabas at itstudio dot pl</em></strong></a><div class="date" title="2007-03-23 02:55"><strong>7 years ago</strong></div>
  <div class="text" id="Hcom74080">
<div class="phpcode"><code><span class="html">
In case of multiple buffering possibility try running ob_end_clean() from the example below in a loop:<br><br>while (@ob_end_clean());<br><br>It will help for example in case of automatic gz compression of output.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="58042">  
  <a class="name">
  <strong class="user"><em>file downloads verified by session vars</em></strong></a><div class="date" title="2005-10-21 08:36"><strong>8 years ago</strong></div>
  <div class="text" id="Hcom58042">
<div class="phpcode"><code><span class="html">
here is my code, i tried several combinations, but most of them didnt work, and had all kinds of unnecessary headers in them, etc. this has additional good features, such as it stops sending the file if the connection stops (hopefully it does anyways), and it fixes IE filename problems when sending files that contain more than one dot in them by using a simple&nbsp; preg_replace (IE likes to terminate the filename and messes everything up):<br><br>&lt;?<br>function send_file($path) {<br>&nbsp; &nbsp; session_write_close();<br>&nbsp; &nbsp; ob_end_clean();<br>&nbsp; &nbsp; if (!is_file($path) || connection_status()!=0)<br>&nbsp; &nbsp; &nbsp; &nbsp; return(FALSE);<br><br>&nbsp; &nbsp; //to prevent long file from getting cut off from&nbsp; &nbsp;&nbsp; //max_execution_time<br><br>&nbsp; &nbsp; set_time_limit(0);<br><br>&nbsp; &nbsp; $name=basename($path);<br><br>&nbsp; &nbsp; //filenames in IE containing dots will screw up the<br>&nbsp; &nbsp; //filename unless we add this<br><br>&nbsp; &nbsp; if (strstr($_SERVER['HTTP_USER_AGENT'], "MSIE"))<br>&nbsp; &nbsp; &nbsp; &nbsp; $name = preg_replace('/\./', '%2e', $name, substr_count($name, '.') - 1);<br><br>&nbsp; &nbsp; //required, or it might try to send the serving&nbsp; &nbsp;&nbsp; //document instead of the file<br><br>&nbsp; &nbsp; header("Cache-Control: ");<br>&nbsp; &nbsp; header("Pragma: ");<br>&nbsp; &nbsp; header("Content-Type: application/octet-stream");<br>&nbsp; &nbsp; header("Content-Length: " .(string)(filesize($path)) );<br>&nbsp; &nbsp; header('Content-Disposition: attachment; filename="'.$name.'"');<br>&nbsp; &nbsp; header("Content-Transfer-Encoding: binary\n");<br><br>&nbsp; &nbsp; if($file = fopen($path, 'rb')){<br>&nbsp; &nbsp; &nbsp; &nbsp; while( (!feof($file)) &amp;&amp; (connection_status()==0) ){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(fread($file, 1024*8));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flush();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; fclose($file);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return((connection_status()==0) and !connection_aborted());<br>}<br><br>?&gt;</span>
</code></div>
  </div>
 </div>
  <div class="note" id="55519">  
  <a class="name">
  <strong class="user"><em>jonathan at corporacionlinux dot cl</em></strong></a><div class="date" title="2005-08-05 08:58"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom55519">
<div class="phpcode"><code><span class="html">
While trying to "passthru" a file to the browser via PHP, but using the FEOF loop, the script tried to buffer the entire file before passing it to the browser. This is my original script. When calling it with a 15M PHP memory limit and a 16M file, apache killed the script.<br><br><span class="default">&lt;?php<br>&nbsp; &nbsp; $name </span><span class="keyword">= </span><span class="default">$tempDir </span><span class="keyword">. </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"file"</span><span class="keyword">];<br>&nbsp; &nbsp; </span><span class="default">$fd </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">, </span><span class="string">'rb'</span><span class="keyword">);<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; if(</span><span class="default">$fd </span><span class="keyword">== </span><span class="default">false</span><span class="keyword">)<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; die(</span><span class="string">"&lt;font color=red&gt;ERROR: File not found.&lt;/font&gt;"</span><span class="keyword">);<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; </span><span class="comment">// send the right headers<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Cache-Control: "</span><span class="keyword">);</span><span class="comment">// leave blank to avoid IE errors<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Pragma: "</span><span class="keyword">);</span><span class="comment">// leave blank to avoid IE errors<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-type: application/octet-stream"</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-Disposition: attachment; filename=\"" </span><span class="keyword">. </span><span class="default">$_GET</span><span class="keyword">[</span><span class="string">"file"</span><span class="keyword">] . </span><span class="string">"\""</span><span class="keyword">);<br>&nbsp; &nbsp; </span><span class="default">header</span><span class="keyword">(</span><span class="string">"Content-length:"</span><span class="keyword">.(string)(</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$name</span><span class="keyword">)));<br>&nbsp; &nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br><br>&nbsp; &nbsp; </span><span class="default">session_write_close</span><span class="keyword">();<br>&nbsp; &nbsp; </span><span class="default">ob_flush</span><span class="keyword">();<br>&nbsp; &nbsp; </span><span class="default">flush</span><span class="keyword">();<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while(!</span><span class="default">feof</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">)) {<br>&nbsp; &nbsp;&nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$buffer </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">, </span><span class="default">2048</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print </span><span class="default">$buffer</span><span class="keyword">;<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br>&nbsp; &nbsp;&nbsp; <br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose </span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">);<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exit;<br></span><span class="default">?&gt;<br></span><br>Apache error log read:<br>Allowed memory size of 15728640 bytes exhausted (tried to allocate 10240 bytes)<br><br>I tried everything, including a flush() inside the loop. But the solution was forcing the flush other way: <br><br><span class="default">&lt;?php<br><br>&nbsp; &nbsp; $buffer </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$fd</span><span class="keyword">, </span><span class="default">32 </span><span class="keyword">* </span><span class="default">1024</span><span class="keyword">);<br><br></span><span class="default">?&gt;<br></span><br>voila... works just fine for me.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="47411">  
  <a class="name">
  <strong class="user"><em>lbaudrillard at hotmail dot com</em></strong></a><div class="date" title="2004-11-15 12:45"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom47411">
<div class="phpcode"><code><span class="html">
The way the PHP page is generated (buffered or not, and how if buffered) has an impact of the download function made using fpassthru (or fread, ...). I mean a download function may work just fine when it is called from a simple php file (no buffering here): <br><br><span class="default">&lt;?php<br>&nbsp; &nbsp; </span><span class="keyword">function </span><span class="default">download</span><span class="keyword">(</span><span class="default">$file</span><span class="keyword">) { ... }<br>&nbsp; &nbsp; <br>&nbsp; &nbsp; </span><span class="default">$filename </span><span class="keyword">= </span><span class="string">"/tmp/test.zip"</span><span class="keyword">;<br>&nbsp; &nbsp; </span><span class="default">download</span><span class="keyword">(</span><span class="default">$filename</span><span class="keyword">);<br></span><span class="default">?&gt;</span>&nbsp; &nbsp; <br><br>but may fails "in the real life" when the page is buffered:<br><br><span class="default">&lt;?php<br>&nbsp; &nbsp; ob_start</span><span class="keyword">(</span><span class="string">"ob_gzhandler"</span><span class="keyword">);<br>&nbsp; &nbsp; ...<br>&nbsp; &nbsp; require_once(</span><span class="default">download</span><span class="keyword">.</span><span class="default">php</span><span class="keyword">);<br>&nbsp; &nbsp; ...<br>&nbsp; &nbsp; </span><span class="default">$filename </span><span class="keyword">= </span><span class="string">"/files/file.zip"</span><span class="keyword">;<br>&nbsp; &nbsp; </span><span class="default">download</span><span class="keyword">(</span><span class="default">$filename</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span><br>In my particular case, only Firefox 1.0 English did not perform the download, because of the ob_start("ob_gzhandler"). Replacing it by ob_start() solved the problem.<br><br>Hope that helps <br>Laurent from Paris, France</span>
</code></div>
  </div>
 </div>
  <div class="note" id="47110">  
  <a class="name">
  <strong class="user"><em>phpnet at -remove-me-uchange dot co dot uk</em></strong></a><div class="date" title="2004-11-03 05:11"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom47110">
<div class="phpcode"><code><span class="html">
I've modified the example given by straz at -removethispart-mac dot com to count each byte of the file out.&nbsp; This can then be compared with the filesize once the file sending is complete to determine whether the file was sent succesfully or not.<br><br>Of course, this doesn't guarantee that the user actually recieved the file successfully though will let us know if something goes wrong half way through reading/sending the file at our end.<br><br>&lt;?<br>/* fpassthru is apparantly a memory-hog. Use this instead */<br>&nbsp; &nbsp; while(!feof($fp)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; $buf = fread($fp, 4096);<br>&nbsp; &nbsp; &nbsp; &nbsp; echo $buf;<br>&nbsp; &nbsp; &nbsp; &nbsp; $bytesSent+=strlen($buf);&nbsp; &nbsp; /* We know how many bytes were sent to the user */<br>&nbsp; &nbsp; }<br>?&gt;<br><br>I've then got this code to update my database to say that the file was downloaded successfully.<br><br>&lt;?<br>&nbsp; &nbsp; if($bytesSent==filesize($file)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; /* Do some cool stuff here! */<br>&nbsp; &nbsp; }<br>?&gt;</span>
</code></div>
  </div>
 </div>
  <div class="note" id="39916">  
  <a class="name">
  <strong class="user"><em>axx at axxess dot ca</em></strong></a><div class="date" title="2004-02-15 01:04"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom39916">
<div class="phpcode"><code><span class="html">
I have also perused this list of examples which I am sure work for that person, but, as others have mentioned here, do not work for me or (anyone else).<br><br>So what I did was try out all of these examples, check other sources of information, and put together what I think to be an example of what works on 'more than a few' systems.&nbsp; The following example works for me wherever I need to create a download using fpassthru(), which works with IE6 (among other browsers):<br><br>&lt;?<br>/*/<br>Download a file using fpassthru()<br>/*/<br>$fileDir = "/home/pathto/myfiles"; // supply a path name.<br>$fileName = "myfile.zip"; // supply a file name.<br>$fileString=$fileDir.'/'.$fileName; // combine the path and file<br>// translate file name properly for Internet Explorer.<br>if (strstr($_SERVER['HTTP_USER_AGENT'], "MSIE")){<br>&nbsp; $fileName = preg_replace('/\./', '%2e', $fileName, substr_count($fileName, '.') - 1);<br>}<br>// make sure the file exists before sending headers<br>if(!$fdl=@fopen($fileString,'r')){<br>&nbsp; &nbsp; die("Cannot Open File!");<br>} else {<br>&nbsp; header("Cache-Control: ");// leave blank to avoid IE errors<br>&nbsp; header("Pragma: ");// leave blank to avoid IE errors<br>&nbsp; header("Content-type: application/octet-stream");<br>&nbsp; header("Content-Disposition: attachment; filename=\"".$fileName."\"");<br>&nbsp; header("Content-length:".(string)(filesize($fileString)));<br>&nbsp; &nbsp; sleep(1);<br>&nbsp; &nbsp; fpassthru($fdl);<br>}<br>?&gt;<br><br>All that should require editing is the $fileDir and $fileName variables.&nbsp; Upload the file and point to it with your browser to see if the script will prompt you for a download.<br><br>NOTE : Regarding File Types : Leaving the 'Content-type' header as-is should allow you to download pretty much any file.&nbsp; I have tested it on some of the more popular file types including zip, css, php, inc, htm, png, gif and jpg.&nbsp; During these tests, I did note that if I selected 'cancel' or 'open' when prompted to download either a gif or jpg, that it would indeed cancel or open in my image browser as it should, but subsequent attempts at 'downloading only' yielded a web page view of the image.&nbsp; Closing the window and opening a new one reset this, allowing me save a jpeg or gif to the hard drive directly.&nbsp; I believe the problem lies in the way the caching headers are treated, since if any info is specified in the 'cache-control' header, the browser download fails completely (in IE, anyways).<br><br>Enjoy! Mail me if it works!&nbsp; ;-)</span>
</code></div>
  </div>
 </div>
  <div class="note" id="39097">  
  <a class="name">
  <strong class="user"><em>mm at tbwachiat dot com</em></strong></a><div class="date" title="2004-01-16 05:00"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom39097">
<div class="phpcode"><code><span class="html">
I've tried all of these renditions of this elusive task.&nbsp; NONE of them have worked for me.&nbsp; And when i say work, i mean where i can click some sort of link and have a file Save As... dialog box come up on MSIE 6.0.&nbsp; In every other browser i've tried (Safari,Firebird,Netscape pc and mac) all have worked where it downloads to my desktop or asks me to save it in a certain place.<br><br>on MSIE 6.0.&nbsp; the file i'm trying to download appears in it's own window. it's an image. BUT, the only thing i can do with it is SAVE IT AS A BMP. ugh.<br><br>I'm using the fpassthru function because i have files that must not be served by the webserver.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="38896">  
  <a class="name">
  <strong class="user"><em>The Otter</em></strong></a><div class="date" title="2004-01-10 09:57"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom38896">
<div class="phpcode"><code><span class="html">
In reply to spam at flatwan dot net<br>This might save someone some time. I created a program to list some rather large files and create links for the end user to click on in order to download them (using the php function fpassthru()).<br><br>The problem I was having was it would make it half way through the download (about 377 megs) and the script would terminate and the download would stop.<br><br>After doing some shotgun troubleshooting I discovered the php config option 'max_execution_time = 30'. Upon changing it to 'max_execution_time = -1' the files &gt;370 megs can be downloaded without the script aborting.<br><br>The best way to do this would to be:<br><span class="default">&lt;?php<br></span><span class="keyword">@</span><span class="default">ignore_user_abort</span><span class="keyword">();<br>@</span><span class="default">set_time_limit</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">);<br></span><span class="default">?&gt;<br></span>This only changes these settings for the script that calls them. (Thanks to (I don't remember who) who wrote a form mail script that used these two lines)</span>
</code></div>
  </div>
 </div>
  <div class="note" id="37526">  
  <a class="name">
  <strong class="user"><em>spam at flatwan dot net</em></strong></a><div class="date" title="2003-11-18 04:07"><strong>10 years ago</strong></div>
  <div class="text" id="Hcom37526">
<div class="phpcode"><code><span class="html">
This might save someone some time. I created a program to list some rather large files and create links for the end user to click on in order to download them (using the php function fpassthru()).<br><br>The problem I was having was it would make it half way through the download (about 377 megs) and the script would terminate and the download would stop.<br><br>After doing some shotgun troubleshooting I discovered the php config option 'max_execution_time = 30'. Upon changing it to 'max_execution_time = -1' the files &gt;370 megs can be downloaded without the script aborting.<br><br>Jon</span>
</code></div>
  </div>
 </div>
  <div class="note" id="32066">  
  <a class="name">
  <strong class="user"><em>arabold AT nero DOT com</em></strong></a><div class="date" title="2003-05-15 04:11"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom32066">
<div class="phpcode"><code><span class="html">
Here's a summary the different headers you need to set to make downloads *always* work with IE and Mozilla:<br><br>[SNIP]<br>&nbsp; $disposition = "inline"; // "inline" to view file in browser or "attachment" to download to hard disk<br>&nbsp; $mime = "image/jpeg"; // or whatever the mime type is<br>&nbsp; $name = "foo.jpg"; // file name<br>&nbsp; $path = "/path/to/foo.jpg"; // full path and file name<br> <br>&nbsp; if (isset($_SERVER["HTTPS"])) {<br>&nbsp; &nbsp; &nbsp; /**<br>&nbsp; &nbsp; &nbsp;&nbsp; * We need to set the following headers to make downloads work using IE in HTTPS mode.<br>&nbsp; &nbsp; &nbsp;&nbsp; */<br>&nbsp; &nbsp; &nbsp; header("Pragma: ");<br>&nbsp; &nbsp; &nbsp; header("Cache-Control: ");<br>&nbsp; &nbsp; &nbsp; header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");<br>&nbsp; &nbsp; &nbsp; header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");<br>&nbsp; &nbsp; &nbsp; header("Cache-Control: no-store, no-cache, must-revalidate"); // HTTP/1.1<br>&nbsp; &nbsp; &nbsp; header("Cache-Control: post-check=0, pre-check=0", false);<br>&nbsp; }<br>&nbsp; &nbsp; &nbsp; else if ($disposition == "attachment") {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header("Cache-control: private");<br>&nbsp; }<br>&nbsp; else {<br>&nbsp; &nbsp; &nbsp; header("Cache-Control: no-cache, must-revalidate");<br>&nbsp; &nbsp; &nbsp; header("Pragma: no-cache");<br>&nbsp; }<br>&nbsp; header("Content-Type: $mime");<br>&nbsp; header("Content-Disposition:$disposition; filename=\"".trim(htmlentities($name))."\"");<br>&nbsp; header("Content-Description: ".trim(htmlentities($name)));<br>&nbsp; header("Content-Length: ".(string)(filesize($path)));<br>&nbsp; header("Connection: close");<br>[/SNIP]<br><br>This way all kinds of download work for me. Hope that helps</span>
</code></div>
  </div>
 </div>
  <div class="note" id="27274">  
  <a class="name">
  <strong class="user"><em>shaun at nospam dot phplabs dot com</em></strong></a><div class="date" title="2002-11-29 04:41"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom27274">
<div class="phpcode"><code><span class="html">
Note that if you use these two headers from a previous example:<br><br>header('Cache-Control: no-cache, must-revalidate');<br>header('Pragma: no-cache');<br><br>before sending a file to the browser, the "Open" option on Internet Explorer's file download dialog will not work properly. If the user clicks "Open" instead of "Save," the target application will open an empty file, because the downloaded file was not cached. The user will have to save the file to their hard drive in order to use it. <br><br>Make sure to leave these headers out if you'd like your visitors to be able to use IE's "Open" option.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="27066">  
  <a class="name">
  <strong class="user"><em>john at bvstudios dot com</em></strong></a><div class="date" title="2002-11-21 12:05"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom27066">
<div class="phpcode"><code><span class="html">
In reply to:<br><br>"3. Through no amount of futzing of headers was I able to get the filename to be set properly when the actual transfer was initiated via a refresh (META or via headers).&nbsp; I don't know if this is also an MSIE only issue or not.&nbsp; If 'download.php?dl=now' (for example) had a refresh back to 'download.php', such that it was intended to show some information (e.g. install instructions) as well as launch the download, then the MSIE insisted that the downloaded file was supposed to be named 'download.php?dl=now' or 'download.php', ignoring the filename in the headers."<br><br>I recently had the exact same issue.&nbsp; What I found is that this was due to my session initialization on the page.&nbsp; For some reason doing a session_start() caused the script to try and download itself, not what I was indicating through various header() calls.<br><br>The solution was to move the download portion above the session initialization.&nbsp; At first glance this may seem dangerous, but I only process it if there are POST vars and the script is reloading itself.&nbsp; This way I know the form was submitted by that page and before they can submit it, they have to have a session!&nbsp; Adding an .htaccess rule to deny all for the directory where the files are stored also helps because then only my script can access the files.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="26563">  
  <a class="name">
  <strong class="user"><em>mikek at nospam dot muonics dot c o m</em></strong></a><div class="date" title="2002-11-05 02:07"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom26563">
<div class="phpcode"><code><span class="html">
Found a workaround to another headache that just cropped up tonight.&nbsp; Apparently Opera 6.1 on Linux (unsure of other versions/platforms) has problems downloading files using the above methods if you have enabled compression via zlib.output_compression in php.ini.<br><br>It seems that Opera sees that the actual transfer size is less than the size in the "Content-length" header for the download and decides that the transfer was incomplete or corrupted.&nbsp; It then either continuously retries the download or else leaves you with a corrupted file.<br><br>Solution:&nbsp; Make sure your download script/section is off in its own directory. and add the following to your .htaccess file for that directory:<br><br>php_flag zlib.output_compression off</span>
</code></div>
  </div>
 </div>
  <div class="note" id="25801">  
  <a class="name">
  <strong class="user"><em>mikek at muonics dot nospam dot c dot o</em></strong></a><div class="date" title="2002-10-07 03:44"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom25801">
<div class="phpcode"><code><span class="html">
Found a workaround for the MSIE cache bug that puts brackets around dotted items I posted about a while back (e.g. "somefile1.0-xyz.zip" becoming "somefile[1][0]-xyz.zip").<br><br>It turns out if you encode all but the last dot as %2e, then MSIE won't do this.&nbsp; If you encode all of them (including the last dot), then MSIE sticks an extra bracketed number at the end of the file (e.g. "somefile1.0-xyz.zip[1]").&nbsp; Unfortunately, however, some other browsers then want to save the file with the %2e in the filename instead of the dots.<br><br>if (strstr($_SERVER['HTTP_USER_AGENT'], "MSIE"))<br>{<br>&nbsp; &nbsp; $fileName = preg_replace('/\./', '%2e', $fileName,<br>&nbsp; &nbsp; &nbsp; &nbsp; substr_count($fileName, '.') - 1);<br>}<br><br>Viola.&nbsp; Properly named files.&nbsp; This works at least with MSIE 6.0.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="25087">  
  <a class="name"><strong class="user"><em>Anonymous</em></strong></a><div class="date" title="2002-09-10 05:17"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom25087">
<div class="phpcode"><code><span class="html">
Note that the above comment about the "Connection: close" header is incorrect: it does not guarantee that the connection will be closed immediately after the transfer is complete. Instead, it informs the client that it can no longer use the existing HTTP connection to perform other HTTP requests on the same server, and that the client MUST close the connection as soon as it has finished handling the current request.<br><br>If the client (for example an old HTTP proxy) is using HTTP/1.0, it may not recognize this header, and could could the connection open; the web server should detect this and close the connection and ignore any further request attempt on that connection.<br><br>HTTP/1.1 clients MUST honor this header and close their connection as soon as they detect the end of the answer.<br><br>In any case, the web server will initiate a watchdog after script completion, and will force the deconnection after about 15 to 30 seconds if the client does not honor this header.<br><br>The exact time to wait for the "socket closed by remote" event is configurable in the web server.<br><br>It is generally smaller when the "Connection: close" header has been sent by the server, than when no "Connection:close" has been sent (in which case the connection persists for longer time, to let the client navigate on the server without enduring new connection costs in terms of: connection delays, number of socket control blocks in final wait state, number of used ports).<br><br>Don't abuse "Connection: close" on your server for every hosted page: this creates more incoming TCP connection attempts than necessary, and slows the navigation on your site. Use it only if your script cannot generate explicit content length in the result header, as the client will have difficulties to determine the end of the results.<br><br>If you want to save connection resources to your server, always send an Explicit "Content-Length" header within your script, or use the "chunked" transfer-encoding to explicitly send the result by delimited fragments (if the client is using HTTP/1.1, it MUST support this chunked transfer encoding, per specification). See RFC2616 for details.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="25085">  
  <a class="name"><strong class="user"><em>Anonymous</em></strong></a><div class="date" title="2002-09-10 04:38"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom25085">
<div class="phpcode"><code><span class="html">
fpassthru() works best for small files. In download manager scripts, it's best to determine the URL of the file to download (you may generate it locally in your session data if you need so), and then use HTTP __temporary__ redirects (302 status code, with a "Location:" header specifying the effective download URL).<br><br>This saves your web server from maintaining PHP scripts running for long times during the file downloadn and instead the download will be managed directly by the web server without scripting support (consequence: less memory resources used by parallel downloads)...</span>
</code></div>
  </div>
 </div>
  <div class="note" id="24843">  
  <a class="name">
  <strong class="user"><em>me at gavinadams dot org</em></strong></a><div class="date" title="2002-08-29 07:06"><strong>11 years ago</strong></div>
  <div class="text" id="Hcom24843">
<div class="phpcode"><code><span class="html">
Interesting results using fpassthru() vs. fread() under UNIX.<br><br>Using fread(fp, length) to read from a valid, open pointer, in which the filename has a special character (single quote, comma, open paren, etc) fails on the read (no debug statements written after that). However, using fpassthru() works like a champ.<br><br>Thanks for the helpful notes on IE session info, have seen this before but didn't know what was causing it.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="20967">  
  <a class="name">
  <strong class="user"><em>josh at trutwins dot homeip dot net</em></strong></a><div class="date" title="2002-04-23 05:03"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom20967">
<div class="phpcode"><code><span class="html">
I could not get the above examples to work.&nbsp; This is what I used instead:<br><br>header("Content-Disposition: attachment; filename=$file");<br>header("Content-Description: Image File");<br>$fd = fopen($file,'r');<br>fpassthru($fd);</span>
</code></div>
  </div>
 </div>
  <div class="note" id="18224">  
  <a class="name">
  <strong class="user"><em>straz at -removethispart-mac dot com</em></strong></a><div class="date" title="2002-01-15 12:22"><strong>12 years ago</strong></div>
  <div class="text" id="Hcom18224">
<div class="phpcode"><code><span class="html">
I wrote a page which authenticates the user, then calls fpassthru() to download an Acrobat document. It worked great up to about 1MB, but for larger files, the script was dying in the middle. My ISP told me they were killing my script because it was a memory hog. I tried readfile() instead, to no avail.<br><br>I replaced the fpassthru() with this workaround. It works great:<br><br> while(!feof($fn)) {<br>&nbsp;&nbsp; $buffer = fread($fn, 4096);<br>&nbsp;&nbsp; print $buffer;<br> }</span>
</code></div>
  </div>
 </div>
  <div class="note" id="2100">  
  <a class="name">
  <strong class="user"><em>cgriffin at websales dot com</em></strong></a><div class="date" title="1999-10-30 04:56"><strong>14 years ago</strong></div>
  <div class="text" id="Hcom2100">
<div class="phpcode"><code><span class="html">
If you open a new file, write to it and then call fpassthru() it doesn't work. You need to call rewind() first to set the file pointer to the begining of the file.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="47937">  
  <a class="name">
  <strong class="user"><em>webmaster at hardcorehoneyz dot com</em></strong></a><div class="date" title="2004-12-06 05:33"><strong>9 years ago</strong></div>
  <div class="text" id="Hcom47937">
<div class="phpcode"><code><span class="html">
I believe the following problem is a result of using sessions and fpassthru together.<br><br>I have a subscription based site which protects large video files (WMV format between 100-120MB) by storing them beneath web root. Downloading a video file requires the user to click a HTML link which requests a PHP script e.g. download-video.php?video_id=123. If the user is valid (session vars created from sucessful login) the script then creates the necessary headers to trigger a 'Save As' download box, opens the file from beneath web root and sends it using fpassthru.<br><br>The problem is as follows:<br><br>The user should be able to click other links on the site whilst a file is downloading. But when they do so, the requested page won't load until the download is complete.<br><br>As this download script is a seperate PHP request, the user should be able to load other pages on the site whilst the file is downloading.<br><br>At time of writing, I've tried almost everything to remove this bug. There must be a problem with using a PHP script rather than a direct web server link to download files.</span>
</code></div>
  </div>
 </div>
  <div class="note" id="74373">  
  <a class="name">
  <strong class="user"><em>public at telcontar dot net</em></strong></a><div class="date" title="2007-04-08 01:26"><strong>7 years ago</strong></div>
  <div class="text" id="Hcom74373">
<div class="phpcode"><code><span class="html">
(Do not delete this, it is NOT a bug report. It is a *follow up* to vague comments on the page about fpassthru() using excessive memory, and a usage tip that if you want to use pass-through processing, PHP 5 is strongly advised. It may LOOK like a bug report because unlike earlier tips, I've tried to clarify the situation. It is not a bug report because the problem is RESOLVED in PHP 5. Rather, anyone still using PHP 4 (for example, for compatibility reasons) should simply be aware that the problem is now resolved.)<br><br>In PHP 4 (4.4.4 tested as a CGI, Apache 2, Linux), use of both fpassthru() and fread() in a loop suffer the SAME memory "leakage". This is characterised by all data that is sent to the client also being kept inside PHP and not released. It would appear to be a failure to garbage collect the data.<br><br>In PHP 5 (5.2.1 tested as a CGI, Apache 2, Linux) this flaw is resolved in both cases. Neither fpassthru() nor fread() in a loop "leak" memory during execution.<br><br>The issue of which one to use appears not to be an issue of memory as both were equally flawed in PHP 4 and both are equally fixed in PHP 5.<br><br>Speed, is left to a reader exercise to test in the latest PHPs.</span>
</code></div>
  </div>
 </div></div>

 
</section>    </section><!-- layout-content -->
        


  </div><!-- layout -->
         
  

    
 <!-- External and third party libraries. -->
 







<a id="toTop" href="javascript:;"><span id="toTopHover"></span><img width="40" height="40" alt="To Top" src="../../images/to-top%402x.png"></a>



<!-- Mirrored from php.net/manual/en/function.fpassthru.php by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 28 Aug 2014 16:04:27 GMT -->


</body></html>