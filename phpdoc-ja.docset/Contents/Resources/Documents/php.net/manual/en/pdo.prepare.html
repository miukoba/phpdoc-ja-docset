<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>文を実行する準備を行い、文オブジェクトを返す</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="pdo.lastinsertid.html">≪ PDO::lastInsertId</a></li>
      <li style="float: right;"><a href="pdo.query.html">PDO::query ≫</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="class.pdo.html">PDO</a></li>
    <li>文を実行する準備を行い、文オブジェクトを返す</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="pdo.prepare" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">PDO::prepare</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.1.0, PECL pdo &gt;= 0.1.0)</p><p class="refpurpose"><span class="refname">PDO::prepare</span> &mdash; <span class="dc-title">
   文を実行する準備を行い、文オブジェクトを返す
  </span></p>

 </div>
 <div class="refsect1 description" id="refsect1-pdo.prepare-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="modifier">public</span> <span class="type"><a href="class.pdostatement.html" class="type PDOStatement">PDOStatement</a></span> <span class="methodname"><strong>PDO::prepare</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$statement</code></span>
   [, <span class="methodparam"><span class="type">array</span> <code class="parameter">$driver_options</code><span class="initializer"> = array()</span></span>
  ] )</div>


  <p class="para rdfs-comment">
   <span class="function"><a href="pdostatement.execute.html" class="function">PDOStatement::execute()</a></span>
   メソッドによって実行される SQL ステートメントを準備します。
   SQL ステートメントは、文が実行されるときに実際の値に置き換えられる 0
   個もしくはそれ以上の名前 (:name) もしくは疑問符 (?)
   パラメータマークを含むことができます。
   名前と疑問符パラメータを同一 SQL
   ステートメント中で使用することはできません。
   どちらか一方か、他のパラメータ形式を使用してください。
   ユーザーの入力をバインドする際にはこれらのパラメータを使います。
   ユーザーの入力を直接クエリに含めてはいけません。
  </p>
  <p class="para">
   <span class="function"><a href="pdostatement.execute.html" class="function">PDOStatement::execute()</a></span> をコールする際には、
   文に渡すパラメータにはそれぞれ固有のパラメータマークを設定する必要があります。
   エミュレーションモードが有効になっていない限り、
   ひとつのプリペアドステートメントの中で、同じ名前のパラメータマークを
   複数使用することはできません。
  </p>
  <blockquote class="note"><p><strong class="note">注意</strong>: 
   <p class="para">
    パラメータマーカーが表せるのは、データリテラルだけです。
    リテラルの一部やキーワード、識別子、その他のクエリのパーツをパラメータにバインドすることはできません。
    たとえば、SQL 文の IN() 句などで、
    ひとつのパラメータに複数の値を割り当てることはできません。
   </p>
  </p></blockquote>
  <p class="para">
   異なるパラメータを用いて複数回実行されるような文に対し
   <span class="function"><strong>PDO::prepare()</strong></span> と
   <span class="function"><a href="pdostatement.execute.html" class="function">PDOStatement::execute()</a></span> をコールすることで、
   ドライバがクライアントまたはサーバー側にクエリプランやメタ情報を
   キャッシュさせるよう調整するため、
   アプリケーションのパフォーマンスを最適化します。また、
   パラメータに手動でクオートする必要がなくなるので
   SQL インジェクション攻撃から保護する助けになります。
  </p>
  <p class="para">
   PDO は元々この機能をサポートしていないドライバに対して
   プリペアドステートメントとバインドパラメータをエミュレートします。
   このため、ある形式をサポートしているがその他の形式をサポートしていない
   ドライバの場合、名前もしくは疑問符形式のパラメータを他の適当な値に
   書き換えることも可能です。
  </p>
 </div>

 <div class="refsect1 parameters" id="refsect1-pdo.prepare-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">statement</code></dt>

     <dd>

      <p class="para">
       これは対象のデータベースサーバーに対して有効な SQL
       文でなければなりません。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">driver_options</code></dt>

     <dd>

      <p class="para">
       この配列は、このメソッドによって返される PDOStatement
       オブジェクトに対して 1
       もしくはそれ以上の key=&gt;value の組を含みます。
       通常、スクロール可能なカーソルを要求するために
       <em>PDO::ATTR_CURSOR</em> に
       <em>PDO::CURSOR_SCROLL</em>
       を設定する場合に使用することになるでしょう。
       いくつかのドライバには、準備する際に利用可能なドライバ固有の
       オプションがあります。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-pdo.prepare-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   もしデータベースサーバーが正常に文を準備する場合、
   <span class="function"><strong>PDO::prepare()</strong></span> は
   <a href="class.pdostatement.html" class="classname">PDOStatement</a> オブジェクトを返します。
   もしデータベースサーバーが文を準備できなかった場合、
   <span class="function"><strong>PDO::prepare()</strong></span> は <strong><code>FALSE</code></strong> を返すか
   <a href="class.pdoexception.html" class="classname">PDOException</a> を発行します
   (<a href="pdo.error-handling.html" class="link">エラー処理</a> の方法に依存します)。
  </p>
  <blockquote class="note"><p><strong class="note">注意</strong>: 
   <p class="para">
    プリペアドステートメントをエミュレートする際にデータベースサーバーとの通信は行いません。
    したがって <span class="function"><strong>PDO::prepare()</strong></span> はステートメントのチェックを行いません。
   </p>
  </p></blockquote>
 </div>


 <div class="refsect1 examples" id="refsect1-pdo.prepare-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-972"><p><strong>例1 名前付きパラメータを用いて SQL ステートメントを準備する</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/*&nbsp;値の配列を渡してプリペアドステートメントを実行する&nbsp;*/<br /></span><span style="color: #0000BB">$sql&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'SELECT&nbsp;name,&nbsp;colour,&nbsp;calories<br />&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;fruit<br />&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;calories&nbsp;&lt;&nbsp;:calories&nbsp;AND&nbsp;colour&nbsp;=&nbsp;:colour'</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$sth&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$dbh</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">prepare</span><span style="color: #007700">(</span><span style="color: #0000BB">$sql</span><span style="color: #007700">,&nbsp;array(</span><span style="color: #0000BB">PDO</span><span style="color: #007700">::</span><span style="color: #0000BB">ATTR_CURSOR&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #0000BB">PDO</span><span style="color: #007700">::</span><span style="color: #0000BB">CURSOR_FWDONLY</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #DD0000">':calories'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #0000BB">150</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">':colour'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">'red'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$red&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #DD0000">':calories'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #0000BB">175</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">':colour'&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">'yellow'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$yellow&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
   <div class="example" id="example-973">
    <p><strong>例2 疑問符パラメータを用いて SQL ステートメントを準備する</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">/*&nbsp;値の配列を渡してプリペアドステートメントを実行する&nbsp;*/<br /></span><span style="color: #0000BB">$sth&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$dbh</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">prepare</span><span style="color: #007700">(</span><span style="color: #DD0000">'SELECT&nbsp;name,&nbsp;colour,&nbsp;calories<br />&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;fruit<br />&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;calories&nbsp;&lt;&nbsp;?&nbsp;AND&nbsp;colour&nbsp;=&nbsp;?'</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #0000BB">150</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'red'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$red&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">execute</span><span style="color: #007700">(array(</span><span style="color: #0000BB">175</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'yellow'</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">$yellow&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">$sth</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">fetchAll</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-pdo.prepare-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="pdo.exec.html" class="function" rel="rdfs-seeAlso">PDO::exec()</a> - SQL ステートメントを実行し、作用した行数を返す</span></li>
    <li class="member"><span class="function"><a href="pdo.query.html" class="function" rel="rdfs-seeAlso">PDO::query()</a> - SQL ステートメントを実行し、結果セットを PDOStatement オブジェクトとして返す</span></li>
    <li class="member"><span class="function"><a href="pdostatement.execute.html" class="function" rel="rdfs-seeAlso">PDOStatement::execute()</a> - プリペアドステートメントを実行する</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="114616""></a>
  <div class="note">
   <strong class="user">bg at enativ dot com</strong>
   <a href="#114616" class="date">13-Mar-2014 12:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if you run queries in a loop, don't include $pdo-&gt;prepare() inside the loop, it will save you some resources (and time).<br />
<br />
prepare statement inside loop:<br />
for($i=0; $i&lt;1000; $i++) {<br />
&nbsp;&nbsp;&nbsp; $rs = $pdo-&gt;prepare("SELECT `id` FROM `admins` WHERE `groupID` = :groupID AND `id` &lt;&gt; :id");<br />
&nbsp;&nbsp;&nbsp; $rs-&gt;execute([':groupID' =&gt; $group, ':id' =&gt; $id]);<br />
}<br />
<br />
// took 0.066626071929932 microseconds<br />
<br />
prepare statement outside loop:<br />
$rs = $pdo-&gt;prepare("SELECT `id` FROM `admins` WHERE `groupID` = :groupID AND `id` &lt;&gt; :id");<br />
for($i=0; $i&lt;1000; $i++) {<br />
&nbsp;&nbsp;&nbsp; $rs-&gt;execute([':groupID' =&gt; $group, ':id' =&gt; $id]);<br />
}<br />
<br />
// took 0.064448118209839 microseconds<br />
<br />
for 1,000 (simple) queries it took 0.002 microseconds less.<br />
not much, but it worth mention.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="114251""></a>
  <div class="note">
   <strong class="user">pbakhuis</strong>
   <a href="#114251" class="date">30-Jan-2014 12:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Noteworthy in my opinion is that if you prepare a statement but do not bind a value to the markers it will insert null by default. e.g.<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/** @var PDO $db */<br />
</span><span class="default">$prep </span><span class="keyword">= </span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">'INSERT INTO item(title, link) VALUES(:title, :link)'</span><span class="keyword">);<br />
</span><span class="default">$prep</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span>Will attempt to insert null, null into the item table.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112626""></a>
  <div class="note">
   <strong class="user">php dot chaska at xoxy dot net</strong>
   <a href="#112626" class="date">06-Jul-2013 05:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that for Postgres, even though Postgres does support prepared statements, PHP's PDO driver NEVER sends the prepared statement to the Postgres server in advance of the call to PDO::execute().&nbsp; <br />
<br />
Therefore, PDO::prepare() will never throw an error for things like faulty SQL syntax.&nbsp; <br />
<br />
It also means the server will not parse and plan the SQL until the first time PDO::execute() is called, which may or may not adversely affect your optimization plans.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112277""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#112277" class="date">27-May-2013 10:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is possible to prepare in advance several statements against a single connection. As long as that connection remains open the statements can be executed and fetched from as often as you like in any order; their "prepare-execute-fetch" steps can be interleaved in whichever way is best.<br />
<br />
So if you're likely to be using several statements often (perhaps within a loop of transactions), you may like to consider preparing all the statements you'll be using up front.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111977""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#111977" class="date">19-Apr-2013 02:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To those wondering why adding quotes to around a placeholder is wrong, and why you can't use placeholders for table or column names:<br />
<br />
There is a common misconception about how the placeholders in prepared statements work: they are not simply substituted in as (escaped) strings, and the resulting SQL executed. Instead, a DBMS asked to "prepare" a statement comes up with a complete query plan for how it would execute that query, including which tables and indexes it would use, which will be the same regardless of how you fill in the placeholders.<br />
<br />
The plan for "SELECT name FROM my_table WHERE id = :value" will be the same whatever you substitute for ":value", but the seemingly similar "SELECT name FROM :table WHERE id = :value" cannot be planned, because the DBMS has no idea what table you're actually going to select from.<br />
<br />
Even when using "emulated prepares", PDO cannot let you use placeholders anywhere, because it would have to work out what you meant: does "Select :foo From some_table" mean ":foo" is going to be a column reference, or a literal string?<br />
<br />
When your query is using a dynamic column reference, you should be explicitly white-listing the columns you know to exist on the table, e.g. using a switch statement with an exception thrown in the default: clause.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111798""></a>
  <div class="note">
   <strong class="user">Kjetil H</strong>
   <a href="#111798" class="date">29-Mar-2013 06:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that the correct internal method signature is:<br />
<span class="default">&lt;?php </span><span class="keyword">public function </span><span class="default">prepare </span><span class="keyword">(</span><span class="default">$statement</span><span class="keyword">, </span><span class="default">$driver_options </span><span class="keyword">= array()) </span><span class="default">?&gt;</span> <br />
<br />
and NOT:<br />
<span class="default">&lt;?php </span><span class="keyword">public function </span><span class="default">prepare </span><span class="keyword">(</span><span class="default">$statement</span><span class="keyword">, array </span><span class="default">$driver_options </span><span class="keyword">= array()) </span><span class="default">?&gt;</span>.<br />
<br />
Redeclaring the method using the latter method signature throws a Stricts Standards error.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111458""></a>
  <div class="note">
   <strong class="user">Simon Le Pine</strong>
   <a href="#111458" class="date">22-Feb-2013 02:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi All,<br />
<br />
First time posting to php.net, a little nervous.<br />
<br />
After a bunch of searching I've learned 2 things about prepared statements:<br />
1.) It fails if you enclose in a single quote (')<br />
This fails: "SELECT * FROM users WHERE email=':email'"<br />
This works: "SELECT * FROM users WHERE email=:email"<br />
2.) You cannot search with a prepared statement<br />
This fails: "SELECT * FROM users WHERE :search=:email"<br />
This succeeds: "SELECT * FROM users WHERE $search=:email"<br />
<br />
In my case I allow the user to enter their username or email, determine which they've entered and set $search to "username" or "email". As this value is not entered by the user there is no potential for SQL injection and thus safe to use as I have done.<br />
<br />
Hope that saves someone else from a lot of searching.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108481""></a>
  <div class="note">
   <strong class="user">orrd101 at gmail dot com</strong>
   <a href="#108481" class="date">30-Apr-2012 09:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Don't just automatically use prepare() for all of your queries.<br />
<br />
If you are only submitting one query, using PDO::query() with PDO::quote() is much faster (about 3x faster in my test results with MySQL).&nbsp; A prepared query is only faster if you are submitting thousands of identical queries at once (with different data).<br />
<br />
If you Google for performance comparisons you will find that this is generally consistently the case, or you can write some code and do your own comparison for your particular configuration and query scenario. But generally PDO::query() will always be faster except when submitting a large number of identical queries.&nbsp; Prepared queries do have the advantage of escaping the data for you, so you have to be sure to use quote() when using query().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107811""></a>
  <div class="note">
   <strong class="user">public at grik dot net</strong>
   <a href="#107811" class="date">07-Mar-2012 09:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
With PDO_MYSQL you need to remember about the PDO::ATTR_EMULATE_PREPARES option.<br />
<br />
The default value is TRUE, like<br />
$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,true); <br />
<br />
This means that no prepared statement is created with $dbh-&gt;prepare() call. With exec() call PDO replaces the placeholders with values itself and sends MySQL a generic query string.<br />
<br />
The first consequence is that the call&nbsp; $dbh-&gt;prepare('garbage');<br />
reports no error. You will get an SQL error during the $dbh-&gt;exec() call.<br />
The second one is the SQL injection risk in special cases, like using a placeholder for the table name.<br />
<br />
The reason for emulation is a poor performance of MySQL with prepared statements. Emulation works significantly faster.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99697""></a>
  <div class="note">
   <strong class="user">pascal dot buguet at laposte dot net</strong>
   <a href="#99697" class="date">31-Aug-2010 02:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PDO::CURSOR_SCROLL is ok with MSS.<br />
You must install SQL Server Driver for PHP 2.0 CTP2 : SQLSRV20.EXE<br />
and&nbsp; the native client "Microsoft SQL Server 2008 R2 Native Client" : sqlncli.msi.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96544""></a>
  <div class="note">
   <strong class="user">Robin</strong>
   <a href="#96544" class="date">04-Mar-2010 02:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Use prepared statements to ensure integrity of binary data during storage and retrieval. Escaping/quoting by f.e. sqlite_escape_string() or PDO::quote() is NOT suited for binary data - only for strings of text.<br />
<br />
A simple test verifies perfect storage and retrieval with prepared statements:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$num_values </span><span class="keyword">= </span><span class="default">10000</span><span class="keyword">;<br />
<br />
</span><span class="default">$db </span><span class="keyword">= new </span><span class="default">pdo</span><span class="keyword">( </span><span class="string">'sqlite::memory:' </span><span class="keyword">);<br />
<br />
</span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">exec</span><span class="keyword">( </span><span class="string">'CREATE TABLE data (binary BLOB(512));' </span><span class="keyword">);<br />
<br />
</span><span class="comment">// generate plenty of troublesome, binary data<br />
</span><span class="keyword">for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$num_values</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
{<br />
&nbsp;&nbsp;&nbsp; for( </span><span class="default">$val </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">, </span><span class="default">$c </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$c </span><span class="keyword">&lt; </span><span class="default">512</span><span class="keyword">/</span><span class="default">16</span><span class="keyword">; </span><span class="default">$c</span><span class="keyword">++ )<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val </span><span class="keyword">.= </span><span class="default">md5</span><span class="keyword">( </span><span class="default">mt_rand</span><span class="keyword">(), </span><span class="default">true </span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; @</span><span class="default">$binary</span><span class="keyword">[] = </span><span class="default">$val</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">// insert each value by prepared statement<br />
</span><span class="keyword">for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$num_values</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">( </span><span class="string">'INSERT INTO data VALUES (?);' </span><span class="keyword">)-&gt;</span><span class="default">execute</span><span class="keyword">( array(</span><span class="default">$binary</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) );<br />
<br />
</span><span class="comment">// fetch the entire row<br />
</span><span class="default">$data </span><span class="keyword">= </span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">query</span><span class="keyword">( </span><span class="string">'SELECT binary FROM data;' </span><span class="keyword">)-&gt;</span><span class="default">fetchAll</span><span class="keyword">( </span><span class="default">PDO</span><span class="keyword">::</span><span class="default">FETCH_COLUMN </span><span class="keyword">);<br />
<br />
</span><span class="comment">// compare with original array, noting any mismatch<br />
</span><span class="keyword">for( </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$num_values</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++ )<br />
&nbsp;&nbsp;&nbsp; if( </span><span class="default">$data</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] != </span><span class="default">$binary</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] ) echo </span><span class="string">"[</span><span class="default">$i</span><span class="string">] mismatch\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">$db </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94354""></a>
  <div class="note">
   <strong class="user">sgirard at rossprint dot com</strong>
   <a href="#94354" class="date">30-Oct-2009 12:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Maybe everyone else already knows this but...<br />
<br />
If you have a routine that prepares/executes many insert or update statements for a sqlite db then you may want to make use of the pdo transactions. <br />
<br />
On some old hardware my query set went from 12 seconds to 1/3-1/2 second. <br />
<br />
-sean</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93469""></a>
  <div class="note">
   <strong class="user">richard at codevanilla.com</strong>
   <a href="#93469" class="date">11-Sep-2009 01:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
beware
<br />
PDO will emulate prepared statements/bound parameters for drivers that do not natively support them, and can also rewrite named or question mark style parameter markers to something more appropriate, if the driver supports one style but not the other.
<br />

<br />
This includes mySQL it seems so
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">try{ 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sth1 </span><span class="keyword">= </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">db1</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="default">$t1</span><span class="keyword">, array(</span><span class="default">PDO</span><span class="keyword">::</span><span class="default">ATTR_CURSOR </span><span class="keyword">=&gt; </span><span class="default">PDO</span><span class="keyword">::</span><span class="default">CURSOR_FWDONLY</span><span class="keyword">));
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; catch(</span><span class="default">PDOException $e</span><span class="keyword">){
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">pack</span><span class="keyword">(</span><span class="string">'dbError'</span><span class="keyword">, </span><span class="default">$e</span><span class="keyword">-&gt;</span><span class="default">getMessage</span><span class="keyword">());
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;
<br />
</span>
<br />
does not and so will not throw the exception if your SQL is wrong.
<br />

<br />
You will need to check that $sth1 is not null.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91078""></a>
  <div class="note">
   <strong class="user">daniel dot egeberg at gmail dot com</strong>
   <a href="#91078" class="date">24-May-2009 10:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can also pass an array of values to PDOStatement::execute(). This is also secured against SQL injection. You don't necessarily have to use bindParam() or bindValue().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90209""></a>
  <div class="note">
   <strong class="user">admin at wdfa dot co dot uk</strong>
   <a href="#90209" class="date">10-Apr-2009 06:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note on the SQL injection properties of prepared statements.<br />
<br />
Prepared statements only project you from SQL injection IF you use the bindParam or bindValue option.<br />
<br />
For example if you have a table called users with two fields, username and email and someone updates their username you might run<br />
<br />
UPDATE `users` SET `user`='$var'<br />
<br />
where $var would be the user submitted text. <br />
<br />
Now if you did <br />
<span class="default">&lt;?php<br />
$a</span><span class="keyword">=new </span><span class="default">PDO</span><span class="keyword">(</span><span class="string">"mysql:host=localhost;dbname=database;"</span><span class="keyword">,</span><span class="string">"root"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">=</span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">"UPDATE `users` SET user='</span><span class="default">$var</span><span class="string">'"</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
and the user had entered&nbsp; User', email='test for a test the injection would occur and the email would be updated to test as well as the user being updated to User.<br />
<br />
Using bindParam as follows<br />
&nbsp;<span class="default">&lt;?php<br />
$var</span><span class="keyword">=</span><span class="string">"User', email='test"</span><span class="keyword">;<br />
</span><span class="default">$a</span><span class="keyword">=new </span><span class="default">PDO</span><span class="keyword">(</span><span class="string">"mysql:host=localhost;dbname=database;"</span><span class="keyword">,</span><span class="string">"root"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">=</span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">"UPDATE `users` SET user=:var"</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">bindParam</span><span class="keyword">(</span><span class="string">":var"</span><span class="keyword">,</span><span class="default">$var</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
The sql would be escaped and update the username to User', email='test'</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83281""></a>
  <div class="note">
   <strong class="user">ak_9jsz</strong>
   <a href="#83281" class="date">19-May-2008 07:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using cursors doesn't work with SQLite 3.5.9. I get an error message when it gets to the execute() method.<br />
<br />
Some of you might be saying "duh!" but i was surprised to see TRIGGER support in SQLite, so i had to try. :)<br />
<br />
I wanted to use Absolute referencing on a Scrollable cursor and i only wanted one column of data. So i used this instead of a cursor.<br />
<br />
<span class="default">&lt;?php<br />
<br />
$dbo </span><span class="keyword">= new </span><span class="default">PDO</span><span class="keyword">(</span><span class="string">'sqlite:tdb'</span><span class="keyword">);<br />
</span><span class="default">$sql </span><span class="keyword">= </span><span class="string">'SELECT F1, F2 FROM tblA WHERE F1 &lt;&gt; "A";'</span><span class="keyword">;<br />
</span><span class="default">$res </span><span class="keyword">= </span><span class="default">$dbo</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="default">$sql</span><span class="keyword">);<br />
</span><span class="default">$res</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">();<br />
</span><span class="default">$resColumn </span><span class="keyword">= </span><span class="default">$res</span><span class="keyword">-&gt;</span><span class="default">fetchAll</span><span class="keyword">(</span><span class="default">PDO</span><span class="keyword">::</span><span class="default">FETCH_COLUMN</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">);<br />
<br />
for(</span><span class="default">$r</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$r</span><span class="keyword">&lt;=</span><span class="default">3</span><span class="keyword">;</span><span class="default">$r</span><span class="keyword">++)<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">'Row '</span><span class="keyword">. </span><span class="default">$r </span><span class="keyword">. </span><span class="string">' returned: ' </span><span class="keyword">. </span><span class="default">$resColumn</span><span class="keyword">[</span><span class="default">$r</span><span class="keyword">] . </span><span class="string">"\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">$dbo </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br />
</span><span class="default">$res </span><span class="keyword">= </span><span class="default">null</span><span class="keyword">;<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79178""></a>
  <div class="note">
   <strong class="user">Stan</strong>
   <a href="#79178" class="date">14-Nov-2007 04:35</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using prepared SELECT statements on a MySQL database prior to MySQL 5.1.17 can lead to SERIOUS performance degradation.<br />
<br />
Quote from <a href="http://dev.mysql.com/doc/refman/5.1/en/query-cache.html :" rel="nofollow" target="_blank">http://dev.mysql.com/doc/refman/5.1/en/query-cache.html :</a><br />
<br />
&gt;&gt; The query cache is not used for server-side prepared statements before MySQL 5.1.17 &lt;&lt;<br />
<br />
The MySQL query cache buffers complete query results and is used to satisfy repeated identical queries if the underlying tables do not change in the meantime - just what happens all the time in a typical web application. It speeds up queries by a several hundred to a several thousand percent.<br />
<br />
Obviously, it doesn't make much sense to give up query caching for the relatively small performance benefit of prepared statements (i.e. the DBMS not having to parse and optimize the same query multiple times) - so using PDO-&gt;query() for SELECT statements is probably the better choice i you're connecting to MySQL &lt; 5.1.17.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74362""></a>
  <div class="note">
   <strong class="user">www.onphp5.com</strong>
   <a href="#74362" class="date">07-Apr-2007 03:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that the statement regarding driver_options is misleading:<br />
<br />
"This array holds one or more key=&gt;value pairs to set attribute values for the PDOStatement object that this method returns. You would most commonly use this to set the PDO::ATTR_CURSOR value to PDO::CURSOR_SCROLL to request a scrollable cursor. Some drivers have driver specific options that may be set at prepare-time"<br />
<br />
From this you might think that scrollable cursors work for all databases, but they don't! Check out this bug report:<br />
<a href="http://bugs.php.net/bug.php?id=34625" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=34625</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73421""></a>
  <div class="note">
   <strong class="user">johniskew</strong>
   <a href="#73421" class="date">22-Feb-2007 05:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to create variable sql statements in a prepare statement...for example you may need to construct a sql query with zero, one, two, etc numbers of arguments...here is a way to do it without a lot of if/else statements needed to glue the sql together:<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">public function </span><span class="default">matchCriteria</span><span class="keyword">(</span><span class="default">$field1</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">,</span><span class="default">$field2</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">,</span><span class="default">$field3</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$db</span><span class="keyword">=</span><span class="default">DB</span><span class="keyword">::</span><span class="default">conn</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">=array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">=array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(!empty(</span><span class="default">$field1</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">[]=</span><span class="string">'field1=?'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">[]=</span><span class="default">$field1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(!empty(</span><span class="default">$field2</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">[]=</span><span class="string">'field2=?'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">[]=</span><span class="default">$field2</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(!empty(</span><span class="default">$field3</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$sql</span><span class="keyword">[]=</span><span class="string">'field3=?'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$paramArray</span><span class="keyword">[]=</span><span class="default">$field3</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$rs</span><span class="keyword">=</span><span class="default">$db</span><span class="keyword">-&gt;</span><span class="default">prepare</span><span class="keyword">(</span><span class="string">'SELECT * FROM mytable'</span><span class="keyword">.(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$paramArray</span><span class="keyword">)&gt;</span><span class="default">0 </span><span class="keyword">? </span><span class="string">' WHERE '</span><span class="keyword">.</span><span class="default">join</span><span class="keyword">(</span><span class="string">' AND '</span><span class="keyword">,</span><span class="default">$sql</span><span class="keyword">) : </span><span class="string">''</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result</span><span class="keyword">=</span><span class="default">$rs</span><span class="keyword">-&gt;</span><span class="default">execute</span><span class="keyword">(</span><span class="default">$paramArray</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$result</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$rs</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69335""></a>
  <div class="note">
   <strong class="user">william dot clarke at gmail dot com</strong>
   <a href="#69335" class="date">01-Sep-2006 12:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Surely if you want to use prepared statements that way you should use the syntax in the second example:<br />
<br />
eg. <br />
<br />
instead of:<br />
select id,name from demo_de where name LIKE :name OR name=:name <br />
<br />
use:<br />
select id,name from demo_de where name LIKE ? OR name=?<br />
<br />
I believe you are supposed to either use distinct named parameters (name, name1) OR anonymous parameters (?s)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69291""></a>
  <div class="note">
   <strong class="user">roth at egotec dot com</strong>
   <a href="#69291" class="date">30-Aug-2006 10:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Attention using MySQL and prepared statements.<br />
Using a placeholder multiple times inside a statement doesn't work. PDO just translates the first occurance und leaves the second one as is.<br />
<br />
select id,name from demo_de where name LIKE :name OR name=:name<br />
<br />
You have to use<br />
<br />
select id,name from demo_de where name LIKE :name OR name=:name2<br />
<br />
and bind name two times. I don't know if other databases (for example Oracle or MSSQL) support multiple occurances. If that's the fact, then the PDO behaviour for MySQL should be changed.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
