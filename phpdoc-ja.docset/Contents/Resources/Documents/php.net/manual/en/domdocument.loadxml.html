<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>文字列から XML を読み込む</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="domdocument.loadhtmlfile.html">≪ DOMDocument::loadHTMLFile</a></li>
      <li style="float: right;"><a href="domdocument.normalizedocument.html">DOMDocument::normalizeDocument ≫</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="class.domdocument.html">DOMDocument</a></li>
    <li>文字列から XML を読み込む</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="domdocument.loadxml" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">DOMDocument::loadXML</h1>
  <p class="verinfo">(PHP 5)</p><p class="refpurpose"><span class="refname">DOMDocument::loadXML</span> &mdash; <span class="dc-title">
   文字列から XML を読み込む
  </span></p>

 </div>
 <div class="refsect1 description" id="refsect1-domdocument.loadxml-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="modifier">public</span> <span class="type"><a href="language.pseudo-types.html#language.types.mixed" class="type mixed">mixed</a></span> <span class="methodname"><strong>DOMDocument::loadXML</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$source</code></span>
   [, <span class="methodparam"><span class="type">int</span> <code class="parameter">$options</code><span class="initializer"> = 0</span></span>
  ] )</div>

  <p class="para rdfs-comment">
   XML ドキュメントを文字列から読み込みます。
  </p>
 </div>

 <div class="refsect1 parameters" id="refsect1-domdocument.loadxml-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">source</code></dt>

     <dd>

      <p class="para">
       XML を含む文字列。
      </p>
     </dd>

    
    
     <dt>
<code class="parameter">options</code></dt>

     <dd>

      <p class="para">
       <a href="libxml.constants.html" class="link">libxml オプション定数</a>
       を
       <a href="language.operators.bitwise.html" class="link">ビット <em>OR</em></a>
       で連結したもの。
      </p>
     </dd>

    

   </dl>

  </p>
 </div>

 <div class="refsect1 returnvalues" id="refsect1-domdocument.loadxml-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   成功した場合に <strong><code>TRUE</code></strong> を、失敗した場合に <strong><code>FALSE</code></strong> を返します。
   静的にコールされた場合には <a href="class.domdocument.html" class="classname">DOMDocument</a> を返します。
   失敗した場合に <strong><code>FALSE</code></strong> を返します
  </p>
 </div>

 <div class="refsect1 errors" id="refsect1-domdocument.loadxml-errors">
  <h3 class="title">エラー / 例外</h3>
  <p class="para">
   空の文字列を <code class="parameter">source</code> に渡すと、警告が発生します。
   この警告は libxml が発するものではないので、libxml
   のエラー処理関数では処理できません。
  </p>
  <p class="para">このメソッドは、静的にコールすることも
<em class="emphasis">できはしますが</em>、<strong><code>E_STRICT</code></strong> エラーが発生します。</p>
 </div>

 <div class="refsect1 examples" id="refsect1-domdocument.loadxml-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-5493">
    <p><strong>例1 ドキュメントを作成する</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$doc&nbsp;</span><span style="color: #007700">=&nbsp;new&nbsp;</span><span style="color: #0000BB">DOMDocument</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">$doc</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">loadXML</span><span style="color: #007700">(</span><span style="color: #DD0000">'&lt;root&gt;&lt;node/&gt;&lt;/root&gt;'</span><span style="color: #007700">);<br />echo&nbsp;</span><span style="color: #0000BB">$doc</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">saveXML</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
  <p class="para">
   <div class="example" id="example-5494">
    <p><strong>例2 <em>loadXML</em> の静的な起動</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;E_STRICT&nbsp;エラーが発生します<br /></span><span style="color: #0000BB">$doc&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">DOMDocument</span><span style="color: #007700">::</span><span style="color: #0000BB">loadXML</span><span style="color: #007700">(</span><span style="color: #DD0000">'&lt;root&gt;&lt;node/&gt;&lt;/root&gt;'</span><span style="color: #007700">);<br />echo&nbsp;</span><span style="color: #0000BB">$doc</span><span style="color: #007700">-&gt;</span><span style="color: #0000BB">saveXML</span><span style="color: #007700">();<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>

 <div class="refsect1 seealso" id="refsect1-domdocument.loadxml-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="methodname"><a href="domdocument.load.html" class="methodname" rel="rdfs-seeAlso">DOMDocument::load()</a> - ファイルから XML を読み込む</span></li>
    <li class="member"><span class="methodname"><a href="domdocument.save.html" class="methodname" rel="rdfs-seeAlso">DOMDocument::save()</a> - 内部の XML ツリーをファイルに出力する</span></li>
    <li class="member"><span class="methodname"><a href="domdocument.savexml.html" class="methodname" rel="rdfs-seeAlso">DOMDocument::saveXML()</a> - 内部の XML ツリーを文字列として出力する</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="113676""></a>
  <div class="note">
   <strong class="user">Gustavo L. Fabro</strong>
   <a href="#113676" class="date">15-Nov-2013 01:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Always remember that with the default parameters this function doesn't handle well large files, i.e. if a text node is longer than 10Mb it can raise an exception stating:<br />
<br />
DOMDocument::loadXML(): internal error Extra content at the end of the document in Entity<br />
<br />
even though the XML is fine.<br />
<br />
The cause is a definition in parserInternals.h of lixml:<br />
#define XML_MAX_TEXT_LENGTH 10000000<br />
<br />
To allow the function to process larger files, pass the LIBXML_PARSEHUGE as an option and it will work just fine:<br />
<br />
$domDocument-&gt;loadXML($xml, LIBXML_PARSEHUGE);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94291""></a>
  <div class="note">
   <strong class="user">szalma dot laszlo at zengo dot eu</strong>
   <a href="#94291" class="date">27-Oct-2009 05:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Loading from a string works fine without the &lt;?xml version="1.0" encoding="utf-8"?&gt; header, but in this case the xmlEncoding won't be set, and this makes the utf-8 characters (international, and special characters) to be encoded as hexa entities when saved with saveXML()!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="89212""></a>
  <div class="note">
   <strong class="user">remacg</strong>
   <a href="#89212" class="date">26-Feb-2009 04:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Instead of doing this:<br />
<br />
<span class="default">&lt;?php<br />
$str </span><span class="keyword">= &lt;&lt;&lt;XML<br />
</span><span class="string">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;<br />
&lt;!DOCTYPE root [<br />
&lt;!ENTITY nbsp "&amp;#160;"&gt;<br />
]&gt;<br />
&lt;div&gt;This&amp;nbsp;is a non-breaking space.&lt;/div&gt;<br />
</span><span class="keyword">XML;<br />
<br />
</span><span class="default">$dd2 </span><span class="keyword">= new </span><span class="default">DOMDocument</span><span class="keyword">();<br />
</span><span class="default">$dd2</span><span class="keyword">-&gt;</span><span class="default">loadXML</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
<br />
echo </span><span class="default">$dd2</span><span class="keyword">-&gt;</span><span class="default">saveXML</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
simply use:<br />
<br />
loadHTML() rather than loadXML().</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81976""></a>
  <div class="note">
   <strong class="user">olalonde at NOSPAM dot gmail dot com</strong>
   <a href="#81976" class="date">22-Mar-2008 02:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For some reason, when you set DOMDocument's property 'recover' to true, using '@' to mask errors thrown by loadXml() won't work.<br />
<br />
Here's my workaround:<br />
<br />
function maskErrors() {}<br />
set_error_handler('maskErrors');<br />
$dom-&gt;loadXml($xml);<br />
restore_error_handler();<br />
<br />
You could also simply do this: error_reporting(0); and then set back error_reporting to its original state.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76015""></a>
  <div class="note">
   <strong class="user">Stuart Grimshaw</strong>
   <a href="#76015" class="date">26-Jun-2007 10:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Possible values for the options parameter can be found here:<br />
<br />
<a href="http://us3.php.net/manual/en/ref.libxml.php#libxml.constants" rel="nofollow" target="_blank">http://us3.php.net/manual/en/ref.libxml.php#libxml.constants</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75837""></a>
  <div class="note">
   <strong class="user">Marc Liyanage</strong>
   <a href="#75837" class="date">18-Jun-2007 04:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The documentation states that loadXML can be called statically, but this is misleading. This feature seems to be a special case hack and its use seems to be discouraged according to <a href="http://bugs.php.net/bug.php?id=41398." rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=41398.</a><br />
<br />
Calling the method statically will fail with an error if the code runs with E_STRICT error reporting enabled.<br />
<br />
The documentation should be changed to make it clear that a static call is against recommended practice and won't work with E_STRICT.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74848""></a>
  <div class="note">
   <strong class="user">jazzslider at hotmail dot com</strong>
   <a href="#74848" class="date">30-Apr-2007 10:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When using loadXML() to parse a string that contains entity references (e.g., &amp;nbsp;), be sure that those entity references are properly declared through the use of a DOCTYPE declaration; otherwise, loadXML() will not be able to interpret the string.<br />
<br />
Example:<br />
<span class="default">&lt;?php<br />
$str </span><span class="keyword">= &lt;&lt;&lt;XML<br />
</span><span class="string">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;<br />
&lt;div&gt;This&amp;nbsp;is a non-breaking space.&lt;/div&gt;<br />
</span><span class="keyword">XML;<br />
<br />
</span><span class="default">$dd1 </span><span class="keyword">= new </span><span class="default">DOMDocument</span><span class="keyword">();<br />
</span><span class="default">$dd1</span><span class="keyword">-&gt;</span><span class="default">loadXML</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
<br />
echo </span><span class="default">$dd1</span><span class="keyword">-&gt;</span><span class="default">saveXML</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
Given the above code, PHP will issue a Warning about the entity 'nbsp' not being properly declared.&nbsp; Also, the call to saveXML() will return nothing but a trimmed-down version of the original processing instruction...everything else is gone, and all because of the undeclared entity.<br />
<br />
Instead, explicitly declare the entity first:<br />
<span class="default">&lt;?php<br />
$str </span><span class="keyword">= &lt;&lt;&lt;XML<br />
</span><span class="string">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;<br />
&lt;!DOCTYPE root [<br />
&lt;!ENTITY nbsp "&amp;#160;"&gt;<br />
]&gt;<br />
&lt;div&gt;This&amp;nbsp;is a non-breaking space.&lt;/div&gt;<br />
</span><span class="keyword">XML;<br />
<br />
</span><span class="default">$dd2 </span><span class="keyword">= new </span><span class="default">DOMDocument</span><span class="keyword">();<br />
</span><span class="default">$dd2</span><span class="keyword">-&gt;</span><span class="default">loadXML</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
<br />
echo </span><span class="default">$dd2</span><span class="keyword">-&gt;</span><span class="default">saveXML</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
Since the 'nbsp' entity is defined in the DOCTYPE, PHP no longer issues that Warning; the string is now well-formed, and loadXML() understands it perfectly.<br />
<br />
You can also use references to external DTDs in the same way (e.g., &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"<br />
"<a href="http://www.w3.org/TR/html4/strict.dtd" rel="nofollow" target="_blank">http://www.w3.org/TR/html4/strict.dtd</a>"&gt;), which is particularly important if you need to do this for many different documents with many different possible entities.<br />
<br />
Also, as a sidenote...entity references created by createEntityReference() do not need this kind of explicit declaration.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73933""></a>
  <div class="note">
   <strong class="user">shaoyu73 at gmail dot com</strong>
   <a href="#73933" class="date">16-Mar-2007 05:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
earth at anonymous dot com,<br />
<br />
preserveWhiteSpace property needs to be set to false for formatOutput to work properly, for some reason.<br />
<br />
$dom = new DOMDocument;<br />
$dom-&gt;preserveWhiteSpace = false;<br />
$dom-&gt;loadXML($xmlStr);<br />
...<br />
$element-&gt;appendChild(...);<br />
...<br />
$dom-&gt;formatOutput = true;<br />
$xmlStr = $dom-&gt;saveXML();<br />
echo $xmlStr;<br />
<br />
This would format the output nicely.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69295""></a>
  <div class="note">
   <strong class="user">Gavin Sinai gsinai at gmx dot net</strong>
   <a href="#69295" class="date">30-Aug-2006 04:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
loadXml reports an error instead of throwing an exception when the xml is not well formed. This is annoying if you are trying to to loadXml() in a try...catch statement. Apparently its a feature, not a bug, because this conforms to a spefication. <br />
<br />
If you want to catch an exception instead of generating a report, you could do something like<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">HandleXmlError</span><span class="keyword">(</span><span class="default">$errno</span><span class="keyword">, </span><span class="default">$errstr</span><span class="keyword">, </span><span class="default">$errfile</span><span class="keyword">, </span><span class="default">$errline</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$errno</span><span class="keyword">==</span><span class="default">E_WARNING </span><span class="keyword">&amp;&amp; (</span><span class="default">substr_count</span><span class="keyword">(</span><span class="default">$errstr</span><span class="keyword">,</span><span class="string">"DOMDocument::loadXML()"</span><span class="keyword">)&gt;</span><span class="default">0</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; throw new </span><span class="default">DOMException</span><span class="keyword">(</span><span class="default">$errstr</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
}<br />
<br />
function </span><span class="default">XmlLoader</span><span class="keyword">(</span><span class="default">$strXml</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">set_error_handler</span><span class="keyword">(</span><span class="string">'HandleXmlError'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$dom </span><span class="keyword">= new </span><span class="default">DOMDocument</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$dom</span><span class="keyword">-&gt;</span><span class="default">loadXml</span><span class="keyword">(</span><span class="default">$strXml</span><span class="keyword">);&nbsp; &nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">restore_error_handler</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$dom</span><span class="keyword">;<br />
&nbsp;}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Returning false in function HandleXmlError() causes a fallback to the default error handler.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68713""></a>
  <div class="note">
   <strong class="user">mp at webfactory dot de</strong>
   <a href="#68713" class="date">08-Aug-2006 05:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
While loadXML() expects its input to have a leading XML processing instruction to deduce the encoding used, there's no such concept in (non-XML) HTML documents. Thus, the libxml library underlying the DOM functions peeks at the &lt;META&gt; tags to figure out the encoding used.<br />
<br />
See <a href="http://xmlsoft.org/encoding.html." rel="nofollow" target="_blank">http://xmlsoft.org/encoding.html.</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="64319""></a>
  <div class="note">
   <strong class="user">earth at anonymous dot com</strong>
   <a href="#64319" class="date">12-Apr-2006 11:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that loadXML crops off beginning and trailing whitespace and linebreaks.<br />
<br />
When using loadXML and appendChild to add a chunk of XML to an existing document, you may want to force a linebreak between the end of the XML chunk and the next line (usually a close tag) in the output file:<br />
<br />
$childDocument = new DOMDocument;<br />
$childDocument&gt;preserveWhiteSpace = true;<br />
$childDocument-&gt;loadXML(..XML-Chunk..);<br />
$mNewNode = $mainDOcument-&gt;importNode($childDocument-&gt;documentElement, true);<br />
$ParentNode-&gt;appendChild($mNewNode);<br />
$ParentNode-&gt;appendChild($mainDocument-&gt;createTextNode("\\n&nbsp; ");<br />
<br />
Although it is said that DOM should not be used to make 'pretty' XML output, it is something I struggled with to get something that was readable for testing.&nbsp; Another solution is to use the createDocumentFragment()-&gt;appendXML(..XML-Chunk..) instead, which seems not to trim off linebreaks like DOMDocument-&gt;loadXML() does.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
