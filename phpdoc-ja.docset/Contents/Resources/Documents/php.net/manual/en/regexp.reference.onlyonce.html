<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>再試行無しのサブパターン</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="regexp.reference.assertions.html">≪ 言明</a></li>
      <li style="float: right;"><a href="regexp.reference.conditional.html">条件付きサブパターン ≫</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="reference.pcre.pattern.syntax.html">PCRE 正規表現構文</a></li>
    <li>再試行無しのサブパターン</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="regexp.reference.onlyonce" class="section">
     <h2 class="title">再試行無しのサブパターン</h2>
     <p class="para">
     繰り返し回数の下限もしくは上限の指定をした場合、
     〔繰り返しを指定した要素の〕続きがマッチに失敗すると、
     繰り返し指定した要素が再評価され、繰り返し回数を変えた上で
     残りのパターンがマッチするかどうか試されます。
     マッチングを続けても無駄なことが明らかな場合、マッチングの性質を変え、
     より速くマッチに失敗させるために、こうした動作を停止させることが
     有用な場合があります。
    </p>
    <p class="para">
     例えば、パターン \d+foo を
     &quot;123456bar&quot;
     という対象文字列に適用した場合を考えてみましょう。
    </p>
    <p class="para">
     \d+ が 6 桁の数字すべてにマッチしますが、その後 &quot;foo&quot; 
     とのマッチが失敗します。通常のマッチング処理の動作だと、5桁の数字のみが 
     \d+ にマッチするとして再試行され、次いで 4 桁等々と続けられ、
     最後には完全にマッチが失敗します。再試行無しのサブパターン 
     (once-only subpattern) を用いると、パターンの一部が一度マッチしたら、
     その後再評価されないよう指定することができます。つまり、最初に &quot;foo&quot; 
     とのマッチに失敗した時点で、ただちにマッチングを取り止めることが
     可能となります。表記には、
     
      <pre class="literallayout">
      (?&gt;\d+)bar
      </pre>
     
     のように、(?&gt; で始まる特別なカッコを用います。
    </p>
    <p class="para">
     この種類のカッコは、一度マッチしたパターンの部分に鍵をかけ (lock up) 
     ます。そのパターンへの再マッチは失敗し、バックトラック (backtrack) 
     が起こらないようにします。それより前の要素に対するバックトラックは、
     通常と同様に動作します。
    </p>
    <p class="para">
     別の説明をすると、このタイプのサブパターンは、同一のスタンドアローンの
     パターンが対象文字列のカレントの位置に固定されたかのように、
     文字列とマッチします。
    </p>
    <p class="para">
     再試行無しのサブパターンは、キャプチャ用サブパターンではありません
     〔つまり、値のキャプチャは行われません〕。上の簡単な例では、
     できるだけ多くのものを呑み込むよう繰り返しが最大化されました。つまり、
     + や +? は残りのパターンがマッチするよう数字の桁数が調整されるのに
     対して、 (?&gt;+) は数字の並び全体に対するマッチングだけしか行われません。
    </p>
    <p class="para">
     この構文には、どんな複雑なものでも、任意のサブパターンを含むことができ、
     ネストも可能です。
    </p>
    <p class="para">
     再試行無しのサブパターンと戻り読み言明とを組み合わせると、
     対象文字列の終端における効率的なマッチングを行うことができます。

      <pre class="literallayout">
      abcd$
      </pre>
       
     というパターンを見てましょう。

     マッチが成功しない長い文字列に適用した場合を考えます。
     マッチングは左から右に行われるため、PCRE は対象文字列のすべての &quot;a&quot; を探し、
     後に続く文字が残りのパターンにマッチするかどうか調べられます。
     
     パターンを

      <pre class="literallayout">
      ^.*abcd$
      </pre>
       
     のように少し変更してみます。

    この場合、最初の .* は、まず文字列全体にマッチします。
    （&quot;a&quot; がその後に続かないので）マッチが失敗すると、最後の 1 文字を除く
    文字列にマッチするようバックトラックが行なわれ、続いて最後の 2 文字を
    除く文字列に、という風に動作します。 &quot;a&quot; の検索は、やはり文字列全体に
    対して、右から左に、行われるため効率は良くありません。
    
    しかし、パターンを
    
      <pre class="literallayout">
      ^(?&gt;.*)(?&lt;=abcd)
      </pre>
       
     のようにしてみましょう。

    要素 .* に対してバックトラックは行われず、文字列全体にのみマッチします。
    続く戻り読み言明は、最後の 4 文字に対するテストを 1 回だけ行います。
    テストが失敗すると、マッチはただちに失敗します。長い文字列に対しては、
    この方法を用いると実行時間にかなりの差が生じます。
    </p>
    <p class="para">
     パターン中にサブパターンがあって、その中に繰り返し数に
     上限の無い要素があり、そのサブパターン自身も何回でも繰り返しが
     可能な場合、マッチの失敗に非常に長い時間がかかってしまう事があります。
     それを避ける唯一の方法は再試行無しのサブパターンを使うことです。
     パターン

      <pre class="literallayout">
      (\D+|&lt;\d+&gt;)*[!?]
      </pre>

     は、非数字もしくは &lt;&gt; で括られた数字に ! または ? が続く
     任意の長さの部分文字列にマッチします。マッチが成功するような
     対象文字列に対しては、速く動作します。
     しかし、これを

      <pre class="literallayout">
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
      </pre>

    に適用すると、マッチが失敗するまでに長い時間がかかります。これは、
    この対象文字列を分割するやり方が数多くあり、それらすべてに対し
    マッチを試みられる事になるためです。
    （この例で、終端に単一の文字ではなく [!?] を使っているのは、
    PCRE と Perl の双方とも、〔終端に〕単一の文字が使われると、
    より速く失敗と判定できるように最適化が行われる
    〔ので、それを避ける〕ためです。マッチに必要な最後の一文字が記憶され、
    文字列にその文字が無い場合、早期に失敗と判定されます。）
    このパターンを

      <pre class="literallayout">
      ((?&gt;\D+)|&lt;\d+&gt;)*[!?]
      </pre>
       
     のように変更した場合、非数字の部分が分割されることがなくなるので、
     より速くマッチが失敗するようになります。
     </p>
    </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="114717""></a>
  <div class="note">
   <strong class="user">Pedro Gimeno</strong>
   <a href="#114717" class="date">28-Mar-2014 03:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The comment by northhero at gmail dot com below is wrong.<br />
<br />
<span class="default">&lt;?php<br />
<br />
$pattern1 </span><span class="keyword">= </span><span class="string">'((?&gt;\D+)|&lt;\d+&gt;)*[!?]'</span><span class="keyword">;<br />
</span><span class="default">$pattern2 </span><span class="keyword">= </span><span class="string">'(\D+|&lt;\d+&gt;)*[!?]'</span><span class="keyword">;<br />
</span><span class="default">$subject </span><span class="keyword">= </span><span class="string">'aaaaaaaaaaaa!'</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/' </span><span class="keyword">. </span><span class="default">$pattern1 </span><span class="keyword">. </span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$match</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$match</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/' </span><span class="keyword">. </span><span class="default">$pattern1 </span><span class="keyword">. </span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$match</span><span class="keyword">));<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$match</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Output:<br />
<br />
int(1)<br />
array(1) {<br />
&nbsp; [0]=&gt;<br />
&nbsp; string(1) "!"<br />
}<br />
int(1)<br />
array(1) {<br />
&nbsp; [0]=&gt;<br />
&nbsp; string(1) "!"<br />
}<br />
<br />
Both match.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104507""></a>
  <div class="note">
   <strong class="user">northhero at gmail dot com</strong>
   <a href="#104507" class="date">19-Jun-2011 10:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The following two patterns are not equal to each other:<br />
(\D+|&lt;\d+&gt;)*[!?]&nbsp;&nbsp; and&nbsp;&nbsp; ((?&gt;\D+)|&lt;\d+&gt;)*[!?]<br />
<br />
For example<br />
The former matches the string of 'aaaaaaaaaaaa!', but the later does NOT.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
