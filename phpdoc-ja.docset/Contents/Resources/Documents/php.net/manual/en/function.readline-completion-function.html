<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>補完関数を登録する</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="function.readline-clear-history.html">≪ readline_clear_history</a></li>
      <li style="float: right;"><a href="function.readline-info.html">readline_info ≫</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="ref.readline.html">Readline 関数</a></li>
    <li>補完関数を登録する</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="function.readline-completion-function" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">readline_completion_function</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">readline_completion_function</span> &mdash; <span class="dc-title">補完関数を登録する</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.readline-completion-function-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">bool</span> <span class="methodname"><strong>readline_completion_function</strong></span>
    ( <span class="methodparam"><span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> <code class="parameter">$function</code></span>
   )</div>

  <p class="para rdfs-comment">
   この関数は補完用の関数を登録します。
   これは、Bash を使用している際に、タブキーを
   押して得られるのと同様の機能です。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.readline-completion-function-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    
     <dt>
<code class="parameter">function</code></dt>

     <dd>

      <p class="para">
       コマンドラインの一部を入力とし、
       マッチする可能性がある文字列の配列を返す
       既存の関数の名前を指定する必要があります。
      </p>
     </dd>

    
   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.readline-completion-function-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   成功した場合に <strong><code>TRUE</code></strong> を、失敗した場合に <strong><code>FALSE</code></strong> を返します。
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="94855""></a>
  <div class="note">
   <strong class="user">chris AT w3style DOT co  UK</strong>
   <a href="#94855" class="date">29-Nov-2009 05:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A little bit of info regarding useful variables when writing your callback function.<br />
<br />
There doesn't seem to be a way to set rl_basic_word_break_characters like with the pure C library, so as previous users have pointed out you'll only receive the current word in the input buffer within your callback.&nbsp; If for example you're typing "big bro|ther", where the bar is the position of your cursor when you hit TAB, you'll receive (string) "brother" and (int) 4 as your callback parameters.<br />
<br />
However, it is possible (easily) to get more useful information about what the user has typed into the readline buffer.&nbsp; readline_info() is key here.&nbsp; It will return an array containing:<br />
<br />
"line_buffer" =&gt; (string)<br />
&nbsp;&nbsp; the entire contents of the line buffer (+ some bugs**)<br />
<br />
"point" =&gt; (int)<br />
&nbsp;&nbsp; the current position of the cursor in the buffer<br />
<br />
"end" =&gt; (int)<br />
&nbsp;&nbsp; the position of the last character in the buffer<br />
<br />
So for the example above you'd get:<br />
<br />
&nbsp; * line_buffer =&gt; "big brother"<br />
&nbsp; * point =&gt; 7<br />
&nbsp; * end =&gt; 11<br />
<br />
From this you can easily perform multi-word matches.<br />
<br />
** NOTE: line_buffer seems to contain spurious data at the end of the string sometime.&nbsp; Fortunately since $end is provided you can substr() it to get the correct value.<br />
<br />
The matches you need to return are full words that can replace $input, so your algorithm might crudely look something like:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">your_callback</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="default">$index</span><span class="keyword">) {<br />
&nbsp; </span><span class="comment">// Get info about the current buffer<br />
&nbsp; </span><span class="default">$rl_info </span><span class="keyword">= </span><span class="default">readline_info</span><span class="keyword">();<br />
&nbsp; <br />
&nbsp; </span><span class="comment">// Figure out what the entire input is<br />
&nbsp; </span><span class="default">$full_input </span><span class="keyword">= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$rl_info</span><span class="keyword">[</span><span class="string">'line_buffer'</span><span class="keyword">], </span><span class="default">0</span><span class="keyword">, </span><span class="default">$rl_info</span><span class="keyword">[</span><span class="string">'end'</span><span class="keyword">]);<br />
&nbsp; <br />
&nbsp; </span><span class="default">$matches </span><span class="keyword">= array();<br />
&nbsp; <br />
&nbsp; </span><span class="comment">// Get all matches based on the entire input buffer<br />
&nbsp; </span><span class="keyword">foreach (</span><span class="default">phrases_that_begin_with</span><span class="keyword">(</span><span class="default">$full_input</span><span class="keyword">) as </span><span class="default">$phrase</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Only add the end of the input (where this word begins)<br />
&nbsp;&nbsp;&nbsp; // to the matches array<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$matches</span><span class="keyword">[] = </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$phrase</span><span class="keyword">, </span><span class="default">$index</span><span class="keyword">);<br />
&nbsp; }<br />
&nbsp; <br />
&nbsp; return </span><span class="default">$matches</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91769""></a>
  <div class="note">
   <strong class="user">overshoot.tv</strong>
   <a href="#91769" class="date">25-Jun-2009 09:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note: the first argument passed to the registered function is NOT the whole command line as entered by the user, but only the last part, i.e. the part after the last space.
<br />

<br />
e.g.:
<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">my_readline_completion_function</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$index</span><span class="keyword">) {
<br />
&nbsp; </span><span class="comment">// If the user is typing:
<br />
&nbsp; // mv file.txt directo[TAB]
<br />
&nbsp; // then:
<br />
&nbsp; // $string = directo
<br />
&nbsp; // the $index is the place of the cursor in the line:
<br />
&nbsp; // $index = 19; 
<br />

<br />
&nbsp; </span><span class="default">$array </span><span class="keyword">= array(
<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'ls'</span><span class="keyword">,
<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'mv'</span><span class="keyword">,
<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'dar'</span><span class="keyword">,
<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'exit'</span><span class="keyword">,
<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'quit'</span><span class="keyword">,
<br />
&nbsp; );
<br />

<br />
&nbsp; </span><span class="comment">// Here, I decide not to return filename autocompletion for the first argument (0th argument).
<br />
&nbsp; </span><span class="keyword">if (</span><span class="default">$index</span><span class="keyword">) {
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ls </span><span class="keyword">= `</span><span class="string">ls</span><span class="keyword">`;
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$lines </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">"\n"</span><span class="keyword">, </span><span class="default">$ls</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$lines </span><span class="keyword">AS </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$line</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp;&nbsp; if (</span><span class="default">is_dir</span><span class="keyword">(</span><span class="default">$line</span><span class="keyword">)) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$lines</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] .= </span><span class="string">'/'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">$lines</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">];
<br />
&nbsp;&nbsp;&nbsp; }
<br />
&nbsp; }
<br />
&nbsp; </span><span class="comment">// This will return both our list of functions, and, possibly, a list of files in the current filesystem.
<br />
&nbsp;// php will filter itself according to what the user is typing.
<br />
&nbsp; </span><span class="keyword">return </span><span class="default">$array</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49566""></a>
  <div class="note">
   <strong class="user">david at acz dot org</strong>
   <a href="#49566" class="date">01-Feb-2005 09:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function can simply return an array of all possible matches (regardless of the current user intput) and readline will handle the matching itself.&nbsp; This is likely to be much faster than attempting to handle partial matches in PHP.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25387""></a>
  <div class="note">
   <strong class="user">john at weider dot cc</strong>
   <a href="#25387" class="date">21-Sep-2002 06:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems that the registered function can accept 2 parameters, the first being the partial string, the second a number that when equal to zero indicates that the tab was hit on the first argument on the input. Otherwise it looks like the position within the string is returned.<br />
<br />
This is neccessary information for processing shell command line input.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
