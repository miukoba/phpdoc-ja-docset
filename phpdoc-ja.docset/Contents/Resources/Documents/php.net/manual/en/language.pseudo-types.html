<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>本ドキュメントにおける疑似的な型および変数</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="language.types.callable.html">≪ コールバック</a></li>
      <li style="float: right;"><a href="language.types.type-juggling.html">型の相互変換 ≫</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="language.types.html">型</a></li>
    <li>本ドキュメントにおける疑似的な型および変数</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="language.pseudo-types" class="sect1">
 <h2 class="title">本ドキュメントにおける疑似的な型および変数</h2>

 <div class="sect2" id="language.types.mixed">
  <h3 class="title">mixed</h3>

  <p class="para">
   <em>mixed</em> は、引数に多様な型 (全てである必要はない)
   を使うことができることを示します。
  </p>

  <p class="para">
   例えば <span class="function"><a href="function.gettype.html" class="function">gettype()</a></span> 関数は全ての PHP の型を受け入れるのに対し、
   <span class="function"><a href="function.str-replace.html" class="function">str_replace()</a></span> は文字列と配列のみを受け入れます。
  </p>

 </div>

 <div class="sect2" id="language.types.number">
  <h3 class="title">number</h3>

  <p class="para">
   <em>number</em> は引数が <span class="type"><a href="language.types.integer.html" class="type integer">integer</a></span> または <span class="type"><a href="language.types.float.html" class="type float">float</a></span>
   のどちらでもよいことを示します。
  </p>

 </div>

 <div class="sect2" id="language.types.callback">
  <h3 class="title">callback</h3>

  <p class="para">
   <span class="type"><a href="language.pseudo-types.html#language.types.callback" class="type callback">callback</a></span> 疑似型がこのドキュメントで使われていたのは、PHP 5.4 で
   <span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> タイプヒントが導入される前のことでした。両者はまったく同じ意味です。
  </p>
  
 </div>
 
 <div class="sect2" id="language.types.void">
  <h3 class="title">void</h3>

  <p class="para">
   返り値の型が <em>void</em> である場合は、
   返り値に意味がないことを表します。パラメータ一覧で
   <em>void</em> が使用されている場合は、
   その関数がパラメータを受け付けないことを表します。
  </p>

 </div>

 <div class="sect2" id="language.types.dotdotdot">
  <h3 class="title">...</h3>

  <p class="para">
   関数のプロトタイプ宣言における <code class="parameter">$...</code> は、
   <em>...など</em> を表します。
   この変数名を用いるのは、たとえば任意の数の引数を取りうる関数などです。
  </p>

 </div>
</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="109705""></a>
  <div class="note">
   <strong class="user">mike@EastGhostCom</strong>
   <a href="#109705" class="date">13-Aug-2012 02:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you pass a string as the callback function (i.e., 2nd parm to preg_replace_callback()), then PHP will interpret it as a function's name in the current scope -- and Main::dada_cb is not a valid function name in any scope.<br />
<br />
If you want to specify a static method of a class as the callback (i.e., "Main::dada_cb"), then you must pass as 2nd parm to preg_replace_callback:<br />
<br />
array( 'Main', 'dada_cb')<br />
<br />
And, if you want to use as a callback some method of an instantiated object (i.e., $object-&gt;dada_cb), then you must pass as the 2nd parm to preg_replace_callback:<br />
<br />
array( $object, 'dada_cb' )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101268""></a>
  <div class="note">
   <strong class="user">liam at helios-sites dot com</strong>
   <a href="#101268" class="date">06-Dec-2010 01:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that (e.g.) usort calls on static methods of classes in a namespace need to be laid out as follows:<br />
<br />
usort($arr, array('\Namespace\ClassName', 'functionName'));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93234""></a>
  <div class="note">
   <strong class="user">michael dot martinek at gmail dot com</strong>
   <a href="#93234" class="date">29-Aug-2009 06:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The documentation is a little confusing, and with the recent OO changes it adds a little more to the confusion.<br />
<br />
I was curious whether you could pass an object through the user func, modify it in that callback and have the actual object updated or whether some cloning was going on behind the scenes.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">Test<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var </span><span class="default">$sValue </span><span class="keyword">= </span><span class="string">'abc'</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function </span><span class="default">testing</span><span class="keyword">(</span><span class="default">$objTest</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$objTest</span><span class="keyword">-&gt;</span><span class="default">sValue </span><span class="keyword">= </span><span class="string">'123'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Test</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">call_user_func</span><span class="keyword">(array(</span><span class="default">$obj</span><span class="keyword">, </span><span class="string">'testing'</span><span class="keyword">), </span><span class="default">$obj</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$obj</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
This works as expected: The object is not cloned, and $sValue is properly set to '123'. With the OO changes in PHP 5, you don't need to do "function testing(&amp;$objTest)" as it is already passed by reference.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91482""></a>
  <div class="note">
   <strong class="user">phpguy at lifetoward dot com</strong>
   <a href="#91482" class="date">12-Jun-2009 02:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I noticed two important thing about putting callbacks into an arg list when calling a function:<br />
<br />
1. The function to which the callback refers must be defined earlier in the source stream. So for example:<br />
<br />
function main() {...; usort($array, 'sortfunction'); ... }<br />
function sortfunction($a, $b){ return 0; }<br />
<br />
Will NOT work, but this will:<br />
<br />
function sortfunction($a, $b){ return 0; }<br />
function main() {...; usort($array, 'sortfunction'); ... }<br />
<br />
2. It's not really just a string. For example, this doesn't work:<br />
<br />
usort($array, ($reverse?'reversesorter':'forwardsorter'));<br />
<br />
I found these two discoveries quite counterintuitive.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90397""></a>
  <div class="note">
   <strong class="user">sahid dot ferdjaoui at gmail dot com</strong>
   <a href="#90397" class="date">20-Apr-2009 12:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An example with PHP 5.3 and lambda functions<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp; array_map </span><span class="keyword">(function (</span><span class="default">$value</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return new </span><span class="default">MyFormElement </span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">);<br />
&nbsp; }, </span><span class="default">$_POST</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75329""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#75329" class="date">24-May-2007 07:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The mixed pseudotype is explained as meaning "multiple but not necessarily all" types, and the example of str_replace(mixed, mixed, mixed) is given where "mixed" means "string or array".<br />
Keep in mind that this refers to the types of the function's arguments _after_ any type juggling.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73104""></a>
  <div class="note">
   <strong class="user">levi at alliancesoftware dot com dot au</strong>
   <a href="#73104" class="date">08-Feb-2007 11:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Parent methods for callbacks should be called 'parent::method', so if you wish to call a non-static parent method via a callback, you should use a callback of<br />
&lt;?<br />
&nbsp;// always works<br />
&nbsp;$callback = array($this, 'parent::method') <br />
<br />
&nbsp;// works but gives an error in PHP5 with E_STRICT if the parent method is not static<br />
&nbsp;$callback array('parent', 'method'); <br />
?&gt;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72778""></a>
  <div class="note">
   <strong class="user">Edward</strong>
   <a href="#72778" class="date">01-Feb-2007 11:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To recap mr dot lilov at gmail dot com's comment: If you want to pass a function as an argument to another function, for example "array_map", do this:<br />
<br />
regular functions: <br />
&lt;? <br />
array_map(intval, $array)<br />
?&gt;<br />
<br />
static functions in a class:<br />
&lt;?<br />
array_map(array('MyClass', 'MyFunction'), $array)<br />
?&gt;<br />
<br />
functions from an object:<br />
&lt;?<br />
array_map(array($this, 'MyFunction'), $array)<br />
?&gt;<br />
<br />
I hope this clarifies things a little bit</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
