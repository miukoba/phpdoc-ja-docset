<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>マルチバイト文字列 関数</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs" class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mbstring.php4.req.html">≪ PHP の文字エンコーディングに関する要件</a></li>
      <li style="float: right;"><a href="function.mb-check-encoding.html">mb_check_encoding ≫</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.mbstring.html">マルチバイト文字列</a></li>
    <li>マルチバイト文字列 関数</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="ref.mbstring" class="reference">
  <h1 class="title">マルチバイト文字列 関数</h1> 

  <div class="partintro">
    <h1 class="title">リファレンス</h1>
    <p class="para">
     マルチバイト文字エンコーディングおよびそれに関連する問題は非常に複雑で、
     このドキュメントの範囲を超えています。これらの問題に関連するより詳細な情報は、
     以下の URL やその他のリソースを参照ください。
     <ul class="itemizedlist">
      <li class="listitem">
       <p class="para">
        Unicode について
       </p>
       <p class="para">
        <a href="http://www.unicode.org/" class="link external" title="Link : http://www.unicode.org/">&raquo;&nbsp;http://www.unicode.org/</a>
       </p>
      </li>
      <li class="listitem">
       <p class="para">
        日本語/韓国語/中国語文字に関する情報
       </p>
       <p class="para">
        <a href="http://examples.oreilly.com/cjkvinfo/doc/cjk.inf" class="link external" title="Link : http://examples.oreilly.com/cjkvinfo/doc/cjk.inf">&raquo;&nbsp;http://examples.oreilly.com/cjkvinfo/doc/cjk.inf</a>
       </p>
      </li>
     </ul>
    </p>
  </div>

 
















































































































































































































































 




























































































































































































 <h2>目次</h2><ul class="chunklist chunklist_reference"><li><a href="function.mb-check-encoding.html">mb_check_encoding</a> &mdash; 文字列が、指定したエンコーディングで有効なものかどうかを調べる</li><li><a href="function.mb-convert-case.html">mb_convert_case</a> &mdash; 文字列に対してケースフォルディングを行う</li><li><a href="function.mb-convert-encoding.html">mb_convert_encoding</a> &mdash; 文字エンコーディングを変換する</li><li><a href="function.mb-convert-kana.html">mb_convert_kana</a> &mdash; カナを(&quot;全角かな&quot;、&quot;半角かな&quot;等に)変換する</li><li><a href="function.mb-convert-variables.html">mb_convert_variables</a> &mdash; 変数の文字コードを変換する</li><li><a href="function.mb-decode-mimeheader.html">mb_decode_mimeheader</a> &mdash; MIME ヘッダフィールドの文字列をデコードする</li><li><a href="function.mb-decode-numericentity.html">mb_decode_numericentity</a> &mdash; HTML 数値エンティティを文字にデコードする</li><li><a href="function.mb-detect-encoding.html">mb_detect_encoding</a> &mdash; 文字エンコーディングを検出する</li><li><a href="function.mb-detect-order.html">mb_detect_order</a> &mdash; 文字エンコーディング検出順序を設定あるいは取得する</li><li><a href="function.mb-encode-mimeheader.html">mb_encode_mimeheader</a> &mdash; MIMEヘッダの文字列をエンコードする</li><li><a href="function.mb-encode-numericentity.html">mb_encode_numericentity</a> &mdash; 文字を HTML 数値エンティティにエンコードする</li><li><a href="function.mb-encoding-aliases.html">mb_encoding_aliases</a> &mdash; 既知のエンコーディング・タイプのエイリアスを取得</li><li><a href="function.mb-ereg-match.html">mb_ereg_match</a> &mdash; マルチバイト文字列が正規表現に一致するか調べる</li><li><a href="function.mb-ereg-replace-callback.html">mb_ereg_replace_callback</a> &mdash; マルチバイト文字列にコールバック関数を用いた正規表現による置換を行う</li><li><a href="function.mb-ereg-replace.html">mb_ereg_replace</a> &mdash; マルチバイト文字列に正規表現による置換を行う</li><li><a href="function.mb-ereg-search-getpos.html">mb_ereg_search_getpos</a> &mdash; 次の正規表現検索を開始する位置を取得する</li><li><a href="function.mb-ereg-search-getregs.html">mb_ereg_search_getregs</a> &mdash; マルチバイト文字列が正規表現に一致する部分があるか調べる</li><li><a href="function.mb-ereg-search-init.html">mb_ereg_search_init</a> &mdash; マルチバイト正規表現検索用の文字列と正規表現を設定する</li><li><a href="function.mb-ereg-search-pos.html">mb_ereg_search_pos</a> &mdash; 指定したマルチバイト文字列が正規表現に一致する部分の位置と長さを返す</li><li><a href="function.mb-ereg-search-regs.html">mb_ereg_search_regs</a> &mdash; 指定したマルチバイト文字列が正規表現に一致する部分を取得する</li><li><a href="function.mb-ereg-search-setpos.html">mb_ereg_search_setpos</a> &mdash; 次の正規表現検索を開始する位置を設定する</li><li><a href="function.mb-ereg-search.html">mb_ereg_search</a> &mdash; 指定したマルチバイト文字列が正規表現に一致するか調べる</li><li><a href="function.mb-ereg.html">mb_ereg</a> &mdash; マルチバイト文字列に正規表現マッチを行う</li><li><a href="function.mb-eregi-replace.html">mb_eregi_replace</a> &mdash; マルチバイト文字列に大文字小文字を区別せずに正規表現による置換を行う</li><li><a href="function.mb-eregi.html">mb_eregi</a> &mdash; マルチバイト文字列に大文字小文字を区別しない正規表現マッチを行う</li><li><a href="function.mb-get-info.html">mb_get_info</a> &mdash; mbstring の内部設定値を取得する</li><li><a href="function.mb-http-input.html">mb_http_input</a> &mdash; HTTP 入力文字エンコーディングを検出する</li><li><a href="function.mb-http-output.html">mb_http_output</a> &mdash; HTTP 出力文字エンコーディングを設定あるいは取得する</li><li><a href="function.mb-internal-encoding.html">mb_internal_encoding</a> &mdash; 内部文字エンコーディングを設定あるいは取得する</li><li><a href="function.mb-language.html">mb_language</a> &mdash; 現在の言語を設定あるいは取得する</li><li><a href="function.mb-list-encodings.html">mb_list_encodings</a> &mdash; サポートするすべてのエンコーディングの配列を返す</li><li><a href="function.mb-output-handler.html">mb_output_handler</a> &mdash; 出力バッファ内で文字エンコーディングを変換するコールバック関数</li><li><a href="function.mb-parse-str.html">mb_parse_str</a> &mdash; GET/POST/COOKIE データをパースし、グローバル変数を設定する</li><li><a href="function.mb-preferred-mime-name.html">mb_preferred_mime_name</a> &mdash; MIME 文字設定を文字列で得る</li><li><a href="function.mb-regex-encoding.html">mb_regex_encoding</a> &mdash; 現在のマルチバイト正規表現用のエンコーディングを取得または設定する</li><li><a href="function.mb-regex-set-options.html">mb_regex_set_options</a> &mdash; マルチバイト正規表現関数のデフォルトオプションを取得または設定する</li><li><a href="function.mb-send-mail.html">mb_send_mail</a> &mdash; エンコード変換を行ってメールを送信する</li><li><a href="function.mb-split.html">mb_split</a> &mdash; マルチバイト文字列を正規表現により分割する</li><li><a href="function.mb-strcut.html">mb_strcut</a> &mdash; 文字列の一部を得る</li><li><a href="function.mb-strimwidth.html">mb_strimwidth</a> &mdash; 指定した幅で文字列を丸める</li><li><a href="function.mb-stripos.html">mb_stripos</a> &mdash; 大文字小文字を区別せず、
   文字列の中で指定した文字列が最初に現れる位置を探す</li><li><a href="function.mb-stristr.html">mb_stristr</a> &mdash; 大文字小文字を区別せず、
   文字列の中で指定した文字列が最初に現れる位置を探す</li><li><a href="function.mb-strlen.html">mb_strlen</a> &mdash; 文字列の長さを得る</li><li><a href="function.mb-strpos.html">mb_strpos</a> &mdash; 文字列の中に指定した文字列が最初に現れる位置を見つける</li><li><a href="function.mb-strrchr.html">mb_strrchr</a> &mdash; 別の文字列の中で、ある文字が最後に現れる場所を見つける</li><li><a href="function.mb-strrichr.html">mb_strrichr</a> &mdash; 大文字小文字を区別せず、
   別の文字列の中である文字が最後に現れる場所を探す</li><li><a href="function.mb-strripos.html">mb_strripos</a> &mdash; 大文字小文字を区別せず、
   文字列の中で指定した文字列が最後に現れる位置を探す</li><li><a href="function.mb-strrpos.html">mb_strrpos</a> &mdash; 文字列の中に指定した文字列が最後に現れる位置を見つける</li><li><a href="function.mb-strstr.html">mb_strstr</a> &mdash; 文字列の中で、指定した文字列が最初に現れる位置を見つける</li><li><a href="function.mb-strtolower.html">mb_strtolower</a> &mdash; 文字列を小文字にする</li><li><a href="function.mb-strtoupper.html">mb_strtoupper</a> &mdash; 文字列を大文字にする</li><li><a href="function.mb-strwidth.html">mb_strwidth</a> &mdash; 文字列の幅を返す</li><li><a href="function.mb-substitute-character.html">mb_substitute_character</a> &mdash; 置換文字を設定あるいは取得する</li><li><a href="function.mb-substr-count.html">mb_substr_count</a> &mdash; 部分文字列の出現回数を数える</li><li><a href="function.mb-substr.html">mb_substr</a> &mdash; 文字列の一部を得る</li></ul>
</div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="115080""></a>
  <div class="note">
   <strong class="user">treilor at gmail dot com</strong>
   <a href="#115080" class="date">23-May-2014 05:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A small note for those who will follow rawsrc at gmail dot com's advice: mb_split uses regular expressions, in which case it may make sense to use built-in function mb_ereg_replace.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115050""></a>
  <div class="note">
   <strong class="user">mattr at telebody dot com</strong>
   <a href="#115050" class="date">19-May-2014 04:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A brief note on Daniel Rhodes' mb_punctuation_trim().<br />
The regular expression modifier u does not mean ungreedy, rather it means the pattern is in UTF-8 encoding. Instead the U modifier should be used to get ungreedy behavior. (I have not otherwise tested his code.)<br />
See <a href="http://php.net/manual/en/reference.pcre.pattern.modifiers.php" rel="nofollow" target="_blank">http://php.net/manual/en/reference.pcre.pattern.modifiers.php</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113569""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#113569" class="date">31-Oct-2013 08:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Yet another single-line mb_trim() function<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_trim</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$trim_chars </span><span class="keyword">= </span><span class="string">'\s'</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'/^['</span><span class="keyword">.</span><span class="default">$trim_chars</span><span class="keyword">.</span><span class="string">']*(?U)(.*)['</span><span class="keyword">.</span><span class="default">$trim_chars</span><span class="keyword">.</span><span class="string">']*$/u'</span><span class="keyword">, </span><span class="string">'\\1'</span><span class="keyword">,</span><span class="default">$string</span><span class="keyword">);<br />
}<br />
</span><span class="default">$string </span><span class="keyword">= </span><span class="string">'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "some text."&nbsp; &nbsp; &nbsp; '</span><span class="keyword">;<br />
echo </span><span class="default">mb_trim</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="string">'\s".'</span><span class="keyword">);<br />
</span><span class="comment">//some text<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113245""></a>
  <div class="note">
   <strong class="user">Daniel Rhodes</strong>
   <a href="#113245" class="date">17-Sep-2013 10:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a cheap and cheeky function to remove leading and trailing *punctuation* (or more specifically "non-word characters") from a UTF-8 string in whatever language. (At least it works well enough for Japanese and English.)<br />
<br />
/**<br />
&nbsp;* Trim singlebyte and multibyte punctuation from the start and end of a string<br />
&nbsp;* <br />
&nbsp;* @author Daniel Rhodes<br />
&nbsp;* @note we want the first non-word grabbing to be greedy but then<br />
&nbsp;* @note we want the dot-star grabbing (before the last non-word grabbing)<br />
&nbsp;* @note to be ungreedy<br />
&nbsp;* <br />
&nbsp;* @param string $string input string in UTF-8<br />
&nbsp;* @return string as $string but with leading and trailing punctuation removed<br />
&nbsp;*/<br />
function mb_punctuation_trim($string)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match('/^[^\w]{0,}(.*?)[^\w]{0,}$/iu', $string, $matches); //case-'i'nsensitive and 'u'ngreedy<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(count($matches) &lt; 2)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //some strange error so just return the original input<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $string;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return $matches[1];<br />
}<br />
<br />
Hope you like it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113238""></a>
  <div class="note">
   <strong class="user">Daniel Rhodes</strong>
   <a href="#113238" class="date">16-Sep-2013 11:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a cheap and cheeky function to remove leading and trailing *punctuation* (or more specifically "non-word characters") from a UTF-8 string in whatever language. (At least it works well enough for Japanese and English.)<br />
<br />
/**<br />
&nbsp;* Trim singlebyte and multibyte punctuation from the start and end of a string<br />
&nbsp;* <br />
&nbsp;* @author Daniel Rhodes<br />
&nbsp;* @note we want the first non-word grabbing to be greedy but then<br />
&nbsp;* @note we want the dot-star grabbing (before the last non-word grabbing)<br />
&nbsp;* @note to be ungreedy<br />
&nbsp;* <br />
&nbsp;* @param string $string input string in UTF-8<br />
&nbsp;* @return string as $string but with leading and trailing punctuation removed<br />
&nbsp;*/<br />
function mb_punctuation_trim($string)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match('/^[^\w]{0,}(.*?)[^\w]{0,}$/iu', $string, $matches); //case-'i'nsensitive and 'u'ngreedy<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(count($matches) &lt; 2)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //some strange error so just return the original input<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $string;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return $matches[1];<br />
}<br />
<br />
Hope you like it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113235""></a>
  <div class="note">
   <strong class="user">Daniel Rhodes</strong>
   <a href="#113235" class="date">16-Sep-2013 09:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a cheap and cheeky function to remove leading and trailing *punctuation* (or more specifically "non-word characters") from a UTF-8 string in whatever language. (At least it works well enough for Japanese and English.)<br />
<br />
/**<br />
&nbsp;* Trim singlebyte and multibyte punctuation from the start and end of a string<br />
&nbsp;* <br />
&nbsp;* @author Daniel Rhodes<br />
&nbsp;* @note we want the first non-word grabbing to be greedy but then<br />
&nbsp;* @note we want the dot-star grabbing (before the last non-word grabbing)<br />
&nbsp;* @note to be ungreedy<br />
&nbsp;* <br />
&nbsp;* @param string $string input string in UTF-8<br />
&nbsp;* @return string as $string but with leading and trailing punctuation removed<br />
&nbsp;*/<br />
function mb_punctuation_trim($string)<br />
{<br />
&nbsp;&nbsp;&nbsp; preg_match('/^[^\w]{0,}(.*?)[^\w]{0,}$/iu', $string, $matches); //case-'i'nsensitive and 'u'ngreedy<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; if(count($matches) &lt; 2)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //some strange error so just return the original input<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $string;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return $matches[1];<br />
}<br />
<br />
Hope you like it!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="109937""></a>
  <div class="note">
   <strong class="user">deceze at gmail dot com</strong>
   <a href="#109937" class="date">04-Sep-2012 07:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that all the discussion about mb_str_replace in the comments is pretty pointless. str_replace works just fine with multibyte strings:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$string&nbsp; </span><span class="keyword">= </span><span class="string">'漢字はユニコード'</span><span class="keyword">;<br />
</span><span class="default">$needle&nbsp; </span><span class="keyword">= </span><span class="string">'は'</span><span class="keyword">;<br />
</span><span class="default">$replace </span><span class="keyword">= </span><span class="string">'Foo'</span><span class="keyword">;<br />
<br />
echo </span><span class="default">str_replace</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">);<br />
</span><span class="comment">// outputs: 漢字Fooユニコード<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
The usual problem is that the string is evaluated as binary string, meaning PHP is not aware of encodings at all. Problems arise if you are getting a value "from outside" somewhere (database, POST request) and the encoding of the needle and the haystack is not the same. That typically means the source code is not saved in the same encoding as you are receiving "from outside". Therefore the binary representations don't match and nothing happens.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="105328""></a>
  <div class="note">
   <strong class="user">rawsrc at gmail dot com</strong>
   <a href="#105328" class="date">09-Aug-2011 11:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi,<br />
<br />
For those who are looking for mb_str_replace, here's a simple function :<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$replacement</span><span class="keyword">, </span><span class="default">$haystack</span><span class="keyword">) {<br />
&nbsp;&nbsp; return </span><span class="default">implode</span><span class="keyword">(</span><span class="default">$replacement</span><span class="keyword">, </span><span class="default">mb_split</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$haystack</span><span class="keyword">));<br />
}<br />
</span><span class="default">?&gt;<br />
</span>I haven't found a simpliest way to proceed :-)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102141""></a>
  <div class="note">
   <strong class="user">efesar</strong>
   <a href="#102141" class="date">28-Jan-2011 11:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This small mb_trim function works for me. 
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mb_trim</span><span class="keyword">( </span><span class="default">$string </span><span class="keyword">)
<br />
{
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">( </span><span class="string">"/(^\s+)|(\s+$)/us"</span><span class="keyword">, </span><span class="string">""</span><span class="keyword">, </span><span class="default">$string </span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; 
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$string</span><span class="keyword">;
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100459""></a>
  <div class="note">
   <strong class="user">johannesponader at dontspamme dot googlemail dot co</strong>
   <a href="#100459" class="date">17-Oct-2010 06:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Please note that when migrating code to handle UTF-8 encoding, not only the functions mentioned here are useful, but also the function htmlentities() has to be changed to htmlentities($var, ENT_COMPAT, "UTF-8") or similar. I didn't scan the manual for it, but there could be some more functions that need adjustments like this.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99482""></a>
  <div class="note">
   <strong class="user">phpnet at rcpt dot at</strong>
   <a href="#99482" class="date">19-Aug-2010 04:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
* Multibyte safe version of trim()<br />
* Always strips whitespace characters (those equal to \s)<br />
*<br />
* @author Peter Johnson<br />
* @email phpnet@rcpt.at<br />
* @param $string The string to trim<br />
* @param $chars Optional list of chars to remove from the string ( as per trim() )<br />
* @param $chars_array Optional array of preg_quote'd chars to be removed<br />
* @return string<br />
*/<br />
</span><span class="keyword">public static function </span><span class="default">mb_trim</span><span class="keyword">( </span><span class="default">$string</span><span class="keyword">, </span><span class="default">$chars </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">, </span><span class="default">$chars_array </span><span class="keyword">= array() )<br />
{<br />
&nbsp;&nbsp;&nbsp; for( </span><span class="default">$x</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$x</span><span class="keyword">&lt;</span><span class="default">iconv_strlen</span><span class="keyword">( </span><span class="default">$chars </span><span class="keyword">); </span><span class="default">$x</span><span class="keyword">++ ) </span><span class="default">$chars_array</span><span class="keyword">[] = </span><span class="default">preg_quote</span><span class="keyword">( </span><span class="default">iconv_substr</span><span class="keyword">( </span><span class="default">$chars</span><span class="keyword">, </span><span class="default">$x</span><span class="keyword">, </span><span class="default">1 </span><span class="keyword">) );<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$encoded_char_list </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">( </span><span class="string">"|"</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">( array( </span><span class="string">"\s"</span><span class="keyword">,</span><span class="string">"\t"</span><span class="keyword">,</span><span class="string">"\n"</span><span class="keyword">,</span><span class="string">"\r"</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">, </span><span class="string">"\x0B" </span><span class="keyword">), </span><span class="default">$chars_array </span><span class="keyword">) );<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="default">mb_ereg_replace</span><span class="keyword">( </span><span class="string">"^(</span><span class="default">$encoded_char_list</span><span class="string">)*"</span><span class="keyword">, </span><span class="string">""</span><span class="keyword">, </span><span class="default">$string </span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$string </span><span class="keyword">= </span><span class="default">mb_ereg_replace</span><span class="keyword">( </span><span class="string">"(</span><span class="default">$encoded_char_list</span><span class="string">)*$"</span><span class="keyword">, </span><span class="string">""</span><span class="keyword">, </span><span class="default">$string </span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$string</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95192""></a>
  <div class="note">
   <strong class="user">mt at mediamedics dot nl</strong>
   <a href="#95192" class="date">17-Dec-2009 02:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A multibyte one-to-one alternative for the str_split function (<a href="http://php.net/manual/en/function.str-split.php" rel="nofollow" target="_blank">http://php.net/manual/en/function.str-split.php</a>):<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">mb_str_split</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$split_length </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mb_internal_encoding</span><span class="keyword">(</span><span class="string">'UTF-8'</span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">mb_regex_encoding</span><span class="keyword">(</span><span class="string">'UTF-8'</span><span class="keyword">);&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$split_length </span><span class="keyword">= (</span><span class="default">$split_length </span><span class="keyword">&lt;= </span><span class="default">0</span><span class="keyword">) ? </span><span class="default">1 </span><span class="keyword">: </span><span class="default">$split_length</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$mb_strlen </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="string">'utf-8'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$mb_strlen</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$split_length</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">$split_length</span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$array</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94356""></a>
  <div class="note">
   <strong class="user">peter AT(no spam) dezzignz dot com</strong>
   <a href="#94356" class="date">30-Oct-2009 01:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The function trim() has not failed me so far in my multibyte applications, but in case one needs a truly multibyte function, here it is. The nice thing is that the character to remove can be whitespace or any other specified character, even a multibyte character.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// multibyte string split<br />
<br />
</span><span class="keyword">function </span><span class="default">mbStringToArray </span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if (empty(</span><span class="default">$str</span><span class="keyword">)) return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$array</span><span class="keyword">[] = </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$array</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="comment">// removes $rem at both ends<br />
<br />
</span><span class="keyword">function </span><span class="default">mb_trim </span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$rem </span><span class="keyword">= </span><span class="string">' '</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if (empty(</span><span class="default">$str</span><span class="keyword">)) return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// convert to array<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$arr </span><span class="keyword">= </span><span class="default">mbStringToArray</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$len </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// left side<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] === </span><span class="default">$rem</span><span class="keyword">) </span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// right side<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">$len</span><span class="keyword">-</span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt;= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">--) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] === </span><span class="default">$rem</span><span class="keyword">) </span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="string">''</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else break;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// convert to string<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">implode </span><span class="keyword">(</span><span class="string">''</span><span class="keyword">, </span><span class="default">$arr</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94220""></a>
  <div class="note">
   <strong class="user">roydukkey at roydukkey dot com</strong>
   <a href="#94220" class="date">23-Oct-2009 06:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This would be one way to create a multibyte substr_replace function
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mb_substr_replace</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$posOpen</span><span class="keyword">, </span><span class="default">$posClose</span><span class="keyword">) {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$posOpen</span><span class="keyword">).</span><span class="default">$replace</span><span class="keyword">.</span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$output</span><span class="keyword">, </span><span class="default">$posClose</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">);
<br />
&nbsp;&nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="91810""></a>
  <div class="note">
   <strong class="user">sakai at d4k dot net</strong>
   <a href="#91810" class="date">26-Jun-2009 02:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I hope this mb_str_replace will work for arrays.&nbsp; Please use mb_internal_encoding() beforehand, if you need to change the encoding.<br />
<br />
Thanks to marc at ermshaus dot org for the original.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if(!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'mb_str_replace'</span><span class="keyword">)) {<br />
<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$search</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$subject</span><span class="keyword">) {<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">$subject </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$val</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$search</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$val</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$ret</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach((array) </span><span class="default">$search </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$s </span><span class="keyword">== </span><span class="string">''</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$r </span><span class="keyword">= !</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$replace</span><span class="keyword">) ? </span><span class="default">$replace </span><span class="keyword">: (</span><span class="default">array_key_exists</span><span class="keyword">(</span><span class="default">$key</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">) ? </span><span class="default">$replace</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] : </span><span class="string">''</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$s</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while(</span><span class="default">$pos </span><span class="keyword">!== </span><span class="default">false</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$subject </span><span class="keyword">= </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">) . </span><span class="default">$r </span><span class="keyword">. </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$subject</span><span class="keyword">, </span><span class="default">$s</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$r</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$subject</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90611""></a>
  <div class="note">
   <strong class="user">mitgath at gmail dot com</strong>
   <a href="#90611" class="date">30-Apr-2009 03:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
according to:
<br />
<a href="http://bugs.php.net/bug.php?id=21317" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=21317</a>
<br />
here's missing function
<br />

<br />
<span class="default">&lt;?php
<br />
</span><span class="keyword">function </span><span class="default">mb_str_pad </span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">, </span><span class="default">$pad_length</span><span class="keyword">, </span><span class="default">$pad_string</span><span class="keyword">, </span><span class="default">$pad_style</span><span class="keyword">, </span><span class="default">$encoding</span><span class="keyword">=</span><span class="string">"UTF-8"</span><span class="keyword">) {
<br />
&nbsp;&nbsp; return </span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">,
<br />
</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">)-</span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$input</span><span class="keyword">,</span><span class="default">$encoding</span><span class="keyword">)+</span><span class="default">$pad_length</span><span class="keyword">, </span><span class="default">$pad_string</span><span class="keyword">, </span><span class="default">$pad_style</span><span class="keyword">);
<br />
}
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87047""></a>
  <div class="note">
   <strong class="user">Ben XO</strong>
   <a href="#87047" class="date">17-Nov-2008 02:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP5 has no mb_trim(), so here's one I made. It work just as trim(), but with the added bonus of PCRE character classes (including, of course, all the useful Unicode ones such as \pZ).
<br />

<br />
Unlike other approaches that I've seen to this problem, I wanted to emulate the full functionality of trim() - in particular, the ability to customise the character list.
<br />

<br />
<span class="default">&lt;?php
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**
<br />
&nbsp;&nbsp; &nbsp; * Trim characters from either (or both) ends of a string in a way that is
<br />
&nbsp;&nbsp; &nbsp; * multibyte-friendly.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * Mostly, this behaves exactly like trim() would: for example supplying 'abc' as
<br />
&nbsp;&nbsp; &nbsp; * the charlist will trim all 'a', 'b' and 'c' chars from the string, with, of
<br />
&nbsp;&nbsp; &nbsp; * course, the added bonus that you can put unicode characters in the charlist.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * We are using a PCRE character-class to do the trimming in a unicode-aware
<br />
&nbsp;&nbsp; &nbsp; * way, so we must escape ^, \, - and ] which have special meanings here.
<br />
&nbsp;&nbsp; &nbsp; * As you would expect, a single \ in the charlist is interpretted as
<br />
&nbsp;&nbsp; &nbsp; * "trim backslashes" (and duly escaped into a double-\ ). Under most circumstances
<br />
&nbsp;&nbsp; &nbsp; * you can ignore this detail.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * As a bonus, however, we also allow PCRE special character-classes (such as '\s')
<br />
&nbsp;&nbsp; &nbsp; * because they can be extremely useful when dealing with UCS. '\pZ', for example,
<br />
&nbsp;&nbsp; &nbsp; * matches every 'separator' character defined in Unicode, including non-breaking
<br />
&nbsp;&nbsp; &nbsp; * and zero-width spaces.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * It doesn't make sense to have two or more of the same character in a character
<br />
&nbsp;&nbsp; &nbsp; * class, therefore we interpret a double \ in the character list to mean a
<br />
&nbsp;&nbsp; &nbsp; * single \ in the regex, allowing you to safely mix normal characters with PCRE
<br />
&nbsp;&nbsp; &nbsp; * special classes.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * *Be careful* when using this bonus feature, as PHP also interprets backslashes
<br />
&nbsp;&nbsp; &nbsp; * as escape characters before they are even seen by the regex. Therefore, to
<br />
&nbsp;&nbsp; &nbsp; * specify '\\s' in the regex (which will be converted to the special character
<br />
&nbsp;&nbsp; &nbsp; * class '\s' for trimming), you will usually have to put *4* backslashes in the
<br />
&nbsp;&nbsp; &nbsp; * PHP code - as you can see from the default value of $charlist.
<br />
&nbsp;&nbsp; &nbsp; *
<br />
&nbsp;&nbsp; &nbsp; * @param string 
<br />
&nbsp;&nbsp; &nbsp; * @param charlist list of characters to remove from the ends of this string.
<br />
&nbsp;&nbsp; &nbsp; * @param boolean trim the left?
<br />
&nbsp;&nbsp; &nbsp; * @param boolean trim the right?
<br />
&nbsp;&nbsp; &nbsp; * @return String
<br />
&nbsp;&nbsp; &nbsp; */
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">mb_trim</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">, </span><span class="default">$charlist</span><span class="keyword">=</span><span class="string">'\\\\s'</span><span class="keyword">, </span><span class="default">$ltrim</span><span class="keyword">=</span><span class="default">true</span><span class="keyword">, </span><span class="default">$rtrim</span><span class="keyword">=</span><span class="default">true</span><span class="keyword">)
<br />
&nbsp;&nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$both_ends </span><span class="keyword">= </span><span class="default">$ltrim </span><span class="keyword">&amp;&amp; </span><span class="default">$rtrim</span><span class="keyword">;
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$char_class_inner </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array( </span><span class="string">'/[\^\-\]\\\]/S'</span><span class="keyword">, </span><span class="string">'/\\\{4}/S' </span><span class="keyword">),
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array( </span><span class="string">'\\\\\\0'</span><span class="keyword">, </span><span class="string">'\\' </span><span class="keyword">),
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$charlist
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">);
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$work_horse </span><span class="keyword">= </span><span class="string">'[' </span><span class="keyword">. </span><span class="default">$char_class_inner </span><span class="keyword">. </span><span class="string">']+'</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ltrim </span><span class="keyword">&amp;&amp; </span><span class="default">$left_pattern </span><span class="keyword">= </span><span class="string">'^' </span><span class="keyword">. </span><span class="default">$work_horse</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$rtrim </span><span class="keyword">&amp;&amp; </span><span class="default">$right_pattern </span><span class="keyword">= </span><span class="default">$work_horse </span><span class="keyword">. </span><span class="string">'$'</span><span class="keyword">;
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$both_ends</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pattern_middle </span><span class="keyword">= </span><span class="default">$left_pattern </span><span class="keyword">. </span><span class="string">'|' </span><span class="keyword">. </span><span class="default">$right_pattern</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; elseif(</span><span class="default">$ltrim</span><span class="keyword">)
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pattern_middle </span><span class="keyword">= </span><span class="default">$left_pattern</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pattern_middle </span><span class="keyword">= </span><span class="default">$right_pattern</span><span class="keyword">;
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }
<br />

<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/</span><span class="default">$pattern_middle</span><span class="string">/usSD"</span><span class="keyword">, </span><span class="string">''</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">) );
<br />
&nbsp;&nbsp;&nbsp; }
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="86120""></a>
  <div class="note">
   <strong class="user">marc at ermshaus dot org</strong>
   <a href="#86120" class="date">04-Oct-2008 12:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A small correction to patrick at hexane dot org's mb_str_replace function. The original function does not work as intended in case $replacement contains $needle.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">mb_str_replace</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$replacement</span><span class="keyword">, </span><span class="default">$haystack</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$needle_len </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$needle</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$replacement_len </span><span class="keyword">= </span><span class="default">mb_strlen</span><span class="keyword">(</span><span class="default">$replacement</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">$needle</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">$pos </span><span class="keyword">!== </span><span class="default">false</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$haystack </span><span class="keyword">= </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">0</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">) . </span><span class="default">$replacement<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">. </span><span class="default">mb_substr</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">$needle_len</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos </span><span class="keyword">= </span><span class="default">mb_strpos</span><span class="keyword">(</span><span class="default">$haystack</span><span class="keyword">, </span><span class="default">$needle</span><span class="keyword">, </span><span class="default">$pos </span><span class="keyword">+ </span><span class="default">$replacement_len</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$haystack</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84099""></a>
  <div class="note">
   <strong class="user">patrick at hexane dot org</strong>
   <a href="#84099" class="date">27-Jun-2008 05:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I wonder why there isn't a mb_str_replace().&nbsp; Here's one for now:<br />
<br />
function mb_str_replace( $needle, $replacement, $haystack ) {<br />
&nbsp; $needle_len = mb_strlen($needle);<br />
&nbsp; $pos = mb_strpos( $haystack, $needle);<br />
&nbsp; while (!($pos ===false)) {<br />
&nbsp;&nbsp;&nbsp; $front = mb_substr( $haystack, 0, $pos );<br />
&nbsp;&nbsp;&nbsp; $back&nbsp; = mb_substr( $haystack, $pos + $needle_len);<br />
&nbsp;&nbsp;&nbsp; $haystack = $front.$replacement.$back;<br />
&nbsp;&nbsp;&nbsp; $pos = mb_strpos( $haystack, $needle);<br />
&nbsp; }<br />
&nbsp; return $haystack;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74722""></a>
  <div class="note">
   <strong class="user">chris at maedata dot com</strong>
   <a href="#74722" class="date">25-Apr-2007 06:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The opposite of what Eugene Murai wrote in a previous comment is true when importing/uploading a file. For instance, if you export an Excel spreadsheet using the Save As Unicode Text option, you can use the following to convert it to UTF-8 after uploading:<br />
<br />
//Convert file to UTF-8 in case Windows mucked it up<br />
$file = explode( "\n", mb_convert_encoding( trim( file_get_contents( $_FILES['file']['tmp_name'] ) ), 'UTF-8', 'UTF-16' ) );</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73889""></a>
  <div class="note">
   <strong class="user">mdoocy at u dot washington dot edu</strong>
   <a href="#73889" class="date">14-Mar-2007 07:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that some of the multi-byte functions run in O(n) time, rather than constant time as is the case for their single-byte equivalents. This includes any functionality requiring access at a specific index, since random access is not possible in a string whose number of bytes will not necessarily match the number of characters. Affected functions include: mb_substr(), mb_strstr(), mb_strcut(), mb_strpos(), etc.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72472""></a>
  <div class="note">
   <strong class="user">motin at demomusic dot nu</strong>
   <a href="#72472" class="date">20-Jan-2007 02:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As peter dot albertsson at spray dot se already pointed out, overloading strlen may break code that handles binary data and relies upon strlen for bytelengths. <br />
<br />
The problem occurs when a file is filled with a string using fwrite in the following manner:<br />
<br />
$len = strlen($data);<br />
fwrite($fp, $data, $len);<br />
<br />
fwrite takes amount of bytes as the third parameter, but mb_strlen returns the amount of characters in the string. Since multibyte characters are possibly more than one byte in length each - this will result in that the last characters of $data never gets written to the file. <br />
<br />
After hours of investigating why PEAR::Cache_Lite didn't work - the above is what I found. <br />
<br />
I made an attempt at using single byte functions, but it doesn't work. Posting here anyway in case it helps someone else:<br />
<br />
/**<br />
* PHP Singe byte functions simulation (non successful)<br />
* <br />
* Usage: sb_string(functionname, arg1, arg2, etc);<br />
* Example: sb_string("strlen", "tuoea"); returns 8 (should...)<br />
*/<br />
function sb_string() {<br />
<br />
&nbsp; $arguments = func_get_args(); <br />
<br />
&nbsp; $func_overloading = ini_get("mbstring.func_overload");<br />
<br />
&nbsp; ini_set("mbstring.func_overload", 0);<br />
<br />
&nbsp; $ret = call_user_func_array(array_shift($arguments), $arguments);<br />
<br />
&nbsp; ini_set("mbstring.func_overload", $func_overloading);<br />
<br />
&nbsp; return $ret;<br />
<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70294""></a>
  <div class="note">
   <strong class="user">pdezwart .at. snocap</strong>
   <a href="#70294" class="date">10-Oct-2006 08:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are trying to emulate the UnicodeEncoding.Unicode.GetBytes() function in .NET, the encoding you want to use is: UCS-2LE</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68976""></a>
  <div class="note">
   <strong class="user">hayk at mail dot ru</strong>
   <a href="#68976" class="date">17-Aug-2006 09:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since PHP 5.1.0 and PHP 4.4.2 there is an Armenian ArmSCII-8 (ArmSCII-8, ArmSCII8, ARMSCII-8, ARMSCII8) encoding avaliable.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68349""></a>
  <div class="note">
   <strong class="user">daniel at softel dot jp</strong>
   <a href="#68349" class="date">24-Jul-2006 01:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that although "multi-byte" hints at total internationalization, the mb_ API was designed by a Japanese person to support the Japanese language.<br />
<br />
Some of the functions, for example mb_convert_kana(), make absolutely no sense outside of a Japanese language environment.<br />
<br />
It should perhaps be considered "lucky" if the functions work with non-Japanese multi-byte languages.<br />
<br />
I don't mean any disrespect to the mb_ API because I'm using it everyday and I appreciate its usefulness, but maybe a better name would be the jp_ API.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63113""></a>
  <div class="note">
   <strong class="user">Aardvark</strong>
   <a href="#63113" class="date">13-Mar-2006 08:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since not all hosted servces currently support the multi-byte function set, it may still be necessary to process Unicode strings using standard single byte functions.&nbsp; The function at the following link - <a href="http://www.kanolife.com/escape/2006/03/php-unicode-processing.html - shows by example how to do this.&nbsp; While this only covers UTF-8, the standard PHP function " rel="nofollow" target="_blank">http://www.kanolife.com/escape/2006/03/php-unicode-processing.html - shows by example how to do this.&nbsp; While this only covers UTF-8, the standard PHP function </a>"iconv" allows conversion into and out of UTF-8 if strings need to be input or output in other encodings.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="62787""></a>
  <div class="note">
   <strong class="user">peter kehl</strong>
   <a href="#62787" class="date">09-Mar-2006 05:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
UTF-16LE solution for CSV for Excel by Eugene Murai works well:<br />
$unicode_str_for_Excel = chr(255).chr(254).mb_convert_encoding( $utf8_str, 'UTF-16LE', 'UTF-8');<br />
<br />
However, then Excel on Mac OS X doesn't identify columns properly and its puts each whole row in its own cell. In order to fix that, use TAB "\\t" character as CSV delimiter rather than comma or colon.<br />
<br />
You may also want to use HTTP encoding header, such as<br />
header( "Content-type: application/vnd.ms-excel; charset=UTF-16LE" );</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55832""></a>
  <div class="note">
   
   <a href="#55832" class="date">15-Aug-2005 04:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
get the string octet-size, when mbstring.func_overload is set to 2 :<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">str_sizeof</span><span class="keyword">(</span><span class="default">$string</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">count</span><span class="keyword">(</span><span class="default">preg_split</span><span class="keyword">(</span><span class="string">"`.`"</span><span class="keyword">, </span><span class="default">$string</span><span class="keyword">)) - </span><span class="default">1 </span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
answering to peter albertsson, once you got your data octet-size, you can access each octet with something<br />
$string[0] ... $string[$size-1], since the [ operator doesn't complies with multibytes strings.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="53032""></a>
  <div class="note">
   <strong class="user">peter dot albertsson at spray dot se</strong>
   <a href="#53032" class="date">21-May-2005 12:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Setting mbstring.func_overload = 2 may break your applications that deal with binary data.<br />
<br />
After having set mbstring.func_overload = 2 and&nbsp; mbstring.internal_encoding = UTF-8 I can't even read a binary file and print/echo it to output without corrupting it.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51887""></a>
  <div class="note">
   <strong class="user">nzkiwi at NOSPAMmte dot biglobe dot ne dot jp</strong>
   <a href="#51887" class="date">14-Apr-2005 01:37</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A friend has pointed out that the entry <br />
"mbstring.http_input PHP_INI_ALL" in Table 1 on the mbstring page appears to be wrong: above Example 4 it says that "There is no way to control HTTP input character conversion from PHP script. To disable HTTP input character conversion, it has to be done in php.ini". <br />
Also the table shows the old-PHP-version defaults: <br />
;; Disable HTTP Input conversion <br />
mbstring.http_input = pass&nbsp; *BUT* (for PHP 4.3.0 or higher) <br />
;; Disable HTTP Input conversion <br />
mbstring.encoding_translation = Off</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50298""></a>
  <div class="note">
   <strong class="user">Eugene Murai</strong>
   <a href="#50298" class="date">24-Feb-2005 07:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
PHP can input and output Unicode, but a little different from what Microsoft means: when Microsoft says "Unicode", it unexplicitly means little-endian UTF-16 with BOM(FF FE = chr(255).chr(254)), whereas PHP's "UTF-16" means big-endian with BOM. For this reason, PHP does not seem to be able to output Unicode CSV file for Microsoft Excel. Solving this problem is quite simple: just put BOM infront of UTF-16LE string.<br />
<br />
Example:<br />
<br />
$unicode_str_for_Excel = chr(255).chr(254).mb_convert_encoding( $utf8_str, 'UTF-16LE', 'UTF-8');</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
</div></div></body></html>
