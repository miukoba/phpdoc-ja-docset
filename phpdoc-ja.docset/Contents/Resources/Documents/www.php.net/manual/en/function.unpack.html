<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>バイナリ文字列からデータを切り出す</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.uniqid.html">uniqid</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.usleep.html">usleep</a></div>
 <div class="up"><a href="ref.misc.html">その他の関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.unpack" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">unpack</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">unpack</span> &mdash; <span class="dc-title">バイナリ文字列からデータを切り出す</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.unpack-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">array</span> <span class="methodname"><strong>unpack</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$format</code></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$data</code></span>
   )</div>

  <p class="para rdfs-comment">
   <em><code class="parameter">format</code></em> に基づき、バイナリ文字列から配列に分解します。
  </p>
  <p class="para">
   分解した結果は連想配列に格納されます。
   このようにするには、別のフォーマットコードを使用してそれらを
   スラッシュ / で区切る必要があります。
   引数にリピータが含まれる場合の配列の要素名は、
   指定した名前の後に順番に番号がついたものとなります。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.unpack-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><em><code class="parameter">format</code></em></span>
     <dd>

      <p class="para">
       書式コードの説明は  <span class="function"><a href="function.pack.html" class="function">pack()</a></span> を参照ください。
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><em><code class="parameter">data</code></em></span>
     <dd>

      <p class="para">
       パックされたデータ。
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.unpack-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   バイナリ文字列を切り出した要素を含む連想配列を返します。
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.unpack-changelog">
  <h3 class="title">変更履歴</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>バージョン</th>
       <th>説明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.5.0</td>
       <td>
        <p class="para">
         Perl の関数に動きを近づけるための変更をしました。
        </p>
        <p class="para">
         &quot;a&quot; は最後の NULL バイトを維持するようになりました。
        </p>
        <p class="para">
         &quot;A&quot; は最後の ASCII 空白文字 (スペース、タブ、改行、キャリッジリターン、
         NULL バイト) をすべて取り除くようになりました。
        </p>
        <p class="para">
         NULL 埋め文字列用に &quot;Z&quot; が追加されました。これは最後の NULL バイトを取り除きます。
         NULL bytes.
        </p>
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.unpack-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-3770">
    <p><strong>例1  <span class="function"><strong>unpack()</strong></span> の例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"cchars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>
     結果の配列の内容は、値が <em>4</em> であるエントリ &quot;chars&quot;
     と値が <em>160</em> であるエントリ &quot;int&quot; となります。
    </p></div>
   </div>
  </p>

  <p class="para">
   <div class="example" id="example-3771">
    <p><strong>例2  <span class="function"><strong>unpack()</strong></span> でのリピータの例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2chars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>
      結果の配列のエントリは &quot;chars1&quot;、&quot;chars2&quot; および &quot;int&quot; となります。
     </p></div>
    </div>
   </p>
  </div>


 <div class="refsect1 notes" id="refsect1-function.unpack-notes">
  <h3 class="title">注意</h3>
  <div class="caution"><strong class="caution">警告</strong>
   <p class="para">
    PHP は内部的に整数を符号付きで保持することに注意しましょう。
    大きな値の unsigned long を切り出した場合、PHP の内部で保持された値は、
    同じ大きさの符号付き整数となり、符号無しを指定して切出された場合でも
    結果は負の数となります。
   </p>
  </div>
  <div class="caution"><strong class="caution">警告</strong>
   <p class="para">
    要素に名前をつけなければ、空文字列の要素となることに注意しましょう。
    つまり、名前をつけない要素が複数ある場合は、
    それらのキーが同じになるためデータが上書きされてしまうということです。
   </p>
   <p class="para">
    <div class="example" id="example-3772">
     <p><strong>例3  <span class="function"><strong>unpack()</strong></span> で名前のないキーを扱う例</strong></p>
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x32\x42\x00\xa0"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2/n"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>
      結果の配列の内容は、値が <em>160</em> であるエントリ &quot;1&quot;
      と値が <em>66</em> であるエントリ &quot;2&quot; になります。
      <em>c</em> で指定した最初の値が
      <em>n</em> で指定した値で上書きされます。
     </p></div>
    </div>
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.unpack-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.pack.html" class="function" rel="rdfs-seeAlso">pack()</a> - データをバイナリ文字列にパックする</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="113359""></a>
  <div class="note">
   <strong class="user">yvan dot burrie at hotmail dot com</strong>
   <a href="#113359" class="date">01-Oct-2013 08:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a demonstration concerning the speed of unpacking files:<br />
So let's see which method is fastest between FREAD or SUBSTR?<br />
<br />
I was creating a script that could read scenario files from a game, and render a preview of its terrain. The terrain structure within each file was huge (between 100,000 - 1,000,000 blocks containing 3 bits of data each). Therefore, I spent much effort to ensure it was fast and robust.<br />
<br />
Method 1: This method retrieves the 3 bits of data found in each block. It uses the loop of widthxheight and implode+unpack+substr each block:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">for ( </span><span class="default">$Y </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$Y </span><span class="keyword">&lt; ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) ; </span><span class="default">$Y </span><span class="keyword">++ ) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">TerrainID </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">Elevation </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] [ </span><span class="default">Unknown </span><span class="keyword">] = </span><span class="default">implode </span><span class="keyword">( </span><span class="default">null </span><span class="keyword">, </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c1' </span><span class="keyword">, </span><span class="default">substr </span><span class="keyword">( </span><span class="default">$Input </span><span class="keyword">, </span><span class="default">$Line </span><span class="keyword">) ) ) ; </span><span class="default">$Line </span><span class="keyword">+= </span><span class="default">1 </span><span class="keyword">;<br />
}<br />
</span><span class="comment">//The average microtime was: 2.9 sec<br />
</span><span class="default">?&gt;<br />
</span>Note that it takes even more time if you use a custom function to implement the implode+unpack+substr functions.<br />
<br />
Now... This method uses the FREAD function:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">for ( </span><span class="default">$Y </span><span class="keyword">= </span><span class="default">0 </span><span class="keyword">; </span><span class="default">$Y </span><span class="keyword">&lt; ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) ; </span><span class="default">$Y </span><span class="keyword">++ ) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">$Y </span><span class="keyword">] = </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c3' </span><span class="keyword">, </span><span class="default">fread </span><span class="keyword">( </span><span class="default">$sc </span><span class="keyword">, </span><span class="default">3 </span><span class="keyword">) ) ;<br />
}<br />
</span><span class="comment">//Average microtime was: 0.7 sec<br />
</span><span class="default">?&gt;<br />
</span>I recommend using the FREAD method instead of SUBSTR.<br />
<br />
Another test!!! This method is 10x faster than the above. This does not use the FOR loop:<br />
<span class="default">&lt;?php<br />
$Output </span><span class="keyword">[ </span><span class="default">Map </span><span class="keyword">] [ </span><span class="default">Data </span><span class="keyword">] = </span><span class="default">unpack </span><span class="keyword">( </span><span class="string">'c' </span><span class="keyword">. ( </span><span class="default">$width </span><span class="keyword">* </span><span class="default">$height </span><span class="keyword">) , </span><span class="default">stream_get_contents </span><span class="keyword">( </span><span class="default">$sc </span><span class="keyword">) ) ;<br />
</span><span class="comment">//Average microtime: 0.08 - 0.05 sec<br />
</span><span class="default">?&gt;<br />
</span><br />
If you want to read files much faster, you should try to reduce the number of loops and use the unpack function to its simplest and robust method.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="110102""></a>
  <div class="note">
   <strong class="user">googlybash24 at aol dot com</strong>
   <a href="#110102" class="date">20-Sep-2012 02:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To convert big endian to little endian or to convert little endian to big endian, use the following approach as an example:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// file_get_contents() returns a binary value, unpack("V*", _ ) returns an unsigned long 32-bit little endian decimal value, but bin2hex() after that would just give the hex data in the file if alone, so instead we use:<br />
// file_get_contents(), unpack("V*", _ ), then dechex(), in that order, to get the byte-swapping effect.<br />
</span><span class="default">?&gt;<br />
</span><br />
With the logic of the approach in this example, you can discover how to swap the endian byte order as you need.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="108599""></a>
  <div class="note">
   <strong class="user">kobrasrealm at gmail dot com</strong>
   <a href="#108599" class="date">10-May-2012 02:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I wrote a quick pair of functions using pack/unpack for converting between raw binary (e.g. openssl_random_pseudo_bytes() output) and hexadecimal (e.g. hash() output):<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">raw2hex</span><span class="keyword">(</span><span class="default">$raw</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$m </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">$raw</span><span class="keyword">);<br />
&nbsp; return </span><span class="default">$m</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
}<br />
<br />
function </span><span class="default">hex2raw</span><span class="keyword">(</span><span class="default">$hex</span><span class="keyword">) { <br />
&nbsp; return </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'H*'</span><span class="keyword">, </span><span class="default">$hex</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Feel free to suggest any improvements, but I thought this was worth sharing.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="106041""></a>
  <div class="note">
   <strong class="user">rogier</strong>
   <a href="#106041" class="date">05-Oct-2011 04:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
be aware of the behavior of your system that PHP resides on.<br />
<br />
On x86, unpack MAY not yield the result you expect for UInt32<br />
<br />
This is due to the internal nature of PHP, being that integers are internally stored as SIGNED!<br />
<br />
For x86 systems, unpack('N', "\xff\xff\xff\xff") results in -1<br />
For (most?) x64 systems, unpack('N', "\xff\xff\xff\xff") results in 4294967295.<br />
<br />
This can be verified by checking the value of PHP_INT_SIZE.<br />
If this value is 4, you have a PHP that internally stores 32-bit.<br />
A value of 8 internally stores 64-bit.<br />
<br />
To work around this 'problem', you can use the following code to avoid problems with unpack.<br />
The code is for big endian order but can easily be adjusted for little endian order (also, similar code works for 64-bit integers):<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">_uint32be</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// $bin is the binary 32-bit BE string that represents the integer<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">PHP_INT_SIZE </span><span class="keyword">&lt;= </span><span class="default">4</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$l</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'n*'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return (</span><span class="default">$l </span><span class="keyword">+ (</span><span class="default">$h</span><span class="keyword">*</span><span class="default">0x010000</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$int</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$int</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Do note that you *could* also use sprintf('%u', $x) to show the unsigned real value.<br />
Also note that (at least when PHP_INT_SIZE = 4) the result WILL be a float value when the input is larger then 0x7fffffff (just check with gettype);<br />
<br />
Hope this helps people.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103634""></a>
  <div class="note">
   <strong class="user">David Gero dave at havidave dot com</strong>
   <a href="#103634" class="date">25-Apr-2011 04:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You might find these functions useful:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">byteStr2byteArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">byteArray2byteStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"C*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
function </span><span class="default">lsbStr2ushortArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"v*"</span><span class="keyword">, </span><span class="string">"\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">ushortArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"v*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
function </span><span class="default">lsbStr2ulongArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V*"</span><span class="keyword">, </span><span class="string">"\0\0\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">ulongArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"V*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Of course, you can address byte strings as if they're arrays with numerical indexes, but the other functions are helpful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100548""></a>
  <div class="note">
   <strong class="user">zac at picolink dot net</strong>
   <a href="#100548" class="date">22-Oct-2010 05:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The documentation is clear that an integer read using an unsigned format character will still be stored as a signed integer.&nbsp; The often-cited work-around is to use sprintf('%u', $bigint) to properly display integers with the MSB set.<br />
<br />
In the case where the numeric value is more important than how it's displayed, you can still work with other large integers using intval() to "upgrade" your existing unsigned integers.<br />
<br />
I had a problem comparing 32-bit integers read from files with hard-coded constants (file signatures tend to need this).&nbsp; Here's what I did to avoid converting everything into strings:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$bigint </span><span class="keyword">= </span><span class="default">0x89504E47</span><span class="keyword">;<br />
<br />
</span><span class="default">$packed </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bigint</span><span class="keyword">);<br />
<br />
list(</span><span class="default">$unpacked</span><span class="keyword">) = </span><span class="default">array_values</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$packed</span><span class="keyword">));<br />
<br />
</span><span class="comment">//The $bigint remains an unsigned integer.<br />
//Even though their bit-wise values are identical, comparison fails.<br />
<br />
</span><span class="keyword">echo </span><span class="string">'bigint '</span><span class="keyword">,<br />
&nbsp; (</span><span class="default">$bigint </span><span class="keyword">== </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br />
&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br />
<br />
</span><span class="comment">//intval() triggers a re-interpretation of $bigint.<br />
//$bigint is internally compared as a signed integer.<br />
//Since the bit-wise value of $bigint never changes, comparison succeeds.<br />
<br />
</span><span class="keyword">echo </span><span class="string">'intval(bigint) '</span><span class="keyword">,<br />
&nbsp; (</span><span class="default">intval</span><span class="keyword">(</span><span class="default">$bigint</span><span class="keyword">) == </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br />
&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
It works, but it's a little backwards.&nbsp; If anyone has any ideas on how to "downgrade" a signed integer into an unsigned integer without using strings, that would be a valuable note to add to the documentation.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100326""></a>
  <div class="note">
   <strong class="user">Aaron Wells</strong>
   <a href="#100326" class="date">08-Oct-2010 12:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another option for converting binary data into PHP data types, is to use the Zend Framework's Zend_Io_Reader class:<br />
<a href="http://bit.ly/9zAhgz" rel="nofollow" target="_blank">http://bit.ly/9zAhgz</a><br />
<br />
There's also a Zend_Io_Writer class that does the reverse.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="97177""></a>
  <div class="note">
   <strong class="user">norwood at computer dot org</strong>
   <a href="#97177" class="date">06-Apr-2010 11:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Reading a text cell from an Excel spreadsheet returned a string with low-order embedded nulls: 0x4100 0x4200 etc. To remove the nulls, used<br />
<br />
<span class="default">&lt;?php<br />
$strWithoutNulls </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">( </span><span class="string">''</span><span class="keyword">, </span><span class="default">explode</span><span class="keyword">( </span><span class="string">"\0"</span><span class="keyword">, </span><span class="default">$strWithNulls </span><span class="keyword">) );<br />
</span><span class="default">?&gt;<br />
</span><br />
(unpack() didn't seem to help much here; needed chars back to re-constitute the string, not integers.)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93714""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#93714" class="date">24-Sep-2009 05:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Functions I found useful when dealing with fixed width file processing, related to unpack/pack functions.<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
* funpack<br />
* format: array of key, length pairs<br />
* data: string to unpack<br />
*/<br />
</span><span class="keyword">function </span><span class="default">funpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">trim</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos</span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
* fpack<br />
* format: array of key, length pairs<br />
* data: array of key, value pairs to pack<br />
* pad: padding direction<br />
*/<br />
</span><span class="keyword">function </span><span class="default">fpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pad </span><span class="keyword">= </span><span class="default">STR_PAD_RIGHT</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">], </span><span class="default">$len</span><span class="keyword">, </span><span class="default">$pad</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92344""></a>
  <div class="note">
   <strong class="user">sica at wnet com br</strong>
   <a href="#92344" class="date">20-Jul-2009 09:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The script following is a example how to save more than one values on file separating its with "\r\n" and how to recovering its values.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// Save two integer values in a binary file<br />
</span><span class="default">$nomearq </span><span class="keyword">= </span><span class="string">"./teste.bin"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">123</span><span class="keyword">;<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"wb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"First value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
echo </span><span class="string">"Separator \\r\\n with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">456</span><span class="keyword">;<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"Second value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Recover the saved values<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">file</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">,</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">));<br />
echo </span><span class="string">"&lt;br&gt;The reading values is:&lt;br&gt;"</span><span class="keyword">;<br />
foreach(</span><span class="default">$valorBin </span><span class="keyword">as </span><span class="default">$valor</span><span class="keyword">){<br />
&nbsp; </span><span class="default">$valor </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; echo </span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Results:<br />
First value (123) packed with 4 bytes<br />
Separator \r\n with 2 bytes<br />
Second value (456) packed with 4 bytes<br />
<br />
The reading values is:<br />
Array ( [1] =&gt; 123 ) <br />
Array ( [1] =&gt; 456 )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87546""></a>
  <div class="note">
   <strong class="user">jlarsen at fsu dot edu</strong>
   <a href="#87546" class="date">10-Dec-2008 12:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As with perl, the count for hex is number of nybbles or half-bytes, this differs from the other options which count in full bytes.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83349""></a>
  <div class="note">
   <strong class="user">Nhon</strong>
   <a href="#83349" class="date">21-May-2008 10:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As stated above, "if you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br />
<br />
To restore the original unsigned value, you could do this :<br />
<br />
if ($unpackedVal &lt;0)<br />
{<br />
&nbsp;&nbsp; &nbsp;&nbsp; $unpackedVal += 4294967296;<br />
}<br />
<br />
Hope this helps !<br />
<br />
Cheers</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82146""></a>
  <div class="note">
   <strong class="user">Anonymous Coward</strong>
   <a href="#82146" class="date">28-Mar-2008 07:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Warning: This unpack function makes the array with keys starting at 1 instead of starting at 0.<br />
<br />
For example:<br />
<span class="default">&lt;?php<br />
&nbsp;</span><span class="keyword">function </span><span class="default">read_field</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$a</span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">,</span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">));<br />
&nbsp; return </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br />
&nbsp;}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80972""></a>
  <div class="note">
   <strong class="user">joe dot nemeth @ palg dot com</strong>
   <a href="#80972" class="date">08-Feb-2008 07:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A simpler solution is to mask the value with 0xffffffff. For instance:<br />
<br />
<span class="default">&lt;?php<br />
$rec </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(<br />
&nbsp; </span><span class="string">"Vvalue/"</span><span class="keyword">.<br />
&nbsp; </span><span class="string">"Vhash32/"</span><span class="keyword">,<br />
&nbsp; </span><span class="default">$recbin</span><span class="keyword">);<br />
</span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'hash32'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br />
</span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'value'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Unlike sprintf(), which converts the value to a string, this preserves the numeric type of the value.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80914""></a>
  <div class="note">
   <strong class="user">Shawn Kelly</strong>
   <a href="#80914" class="date">06-Feb-2008 09:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Above it says this:<br />
<br />
&nbsp; "Note that PHP internally stores integral values as signed. If&nbsp; you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br />
<br />
This happened to me.&nbsp; I wanted to get a big number from a unsigned long, but it kept coming returning a negative.&nbsp; Happened to notice that sprintf('%u',$dta) will take the useless negative and restore it into its large unsigned proper magnitude.<br />
<br />
Hope this saves someone a little time...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57612""></a>
  <div class="note">
   <strong class="user">Justin dot SpahrSummers at gmail dot com</strong>
   <a href="#57612" class="date">08-Oct-2005 09:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I hadn't realized that if the number after the unpack type was 1 (i.e. "V1page"), that it would behave as if there was no number at all. I had been using a variable and didn't think to watch for this. For instance,<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if (</span><span class="default">$something</span><span class="keyword">)<br />
&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">;<br />
else<br />
&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
<br />
</span><span class="default">$arr </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V" </span><span class="keyword">. </span><span class="default">$get </span><span class="keyword">. </span><span class="string">"page"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Now if $something was FALSE, then $arr will only have one entry named "page". If $something was TRUE, $arr would have "page1" and "page2".</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52527""></a>
  <div class="note">
   <strong class="user">info at dreystone dot com</strong>
   <a href="#52527" class="date">04-May-2005 08:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is my solution to reading a Big-Endian formatted double on an Little-Endian machine.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">ToDouble</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"S*"</span><span class="keyword">, </span><span class="default">256</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$t</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] == </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">strrev</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return (double)</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46725""></a>
  <div class="note">
   <strong class="user">jjfoerch at earthlink dot net</strong>
   <a href="#46725" class="date">21-Oct-2004 01:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a situation where I had to unpack a file filled with little-endian order double-floats in a way that would work on either little-endian or big-endian machines.&nbsp; PHP doesn't have a formatting code that will change the byte order of doubles, so I wrote this workaround.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/*The following code is a workaround for php's unpack function<br />
which does not have the capability of unpacking double precision<br />
floats that were packed in the opposite byte order of the current<br />
machine.<br />
*/<br />
</span><span class="keyword">function </span><span class="default">big_endian_unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar </span><span class="keyword">= </span><span class="default">unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$vals </span><span class="keyword">= </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">explode </span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$format</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$f </span><span class="keyword">as </span><span class="default">$f_k </span><span class="keyword">=&gt; </span><span class="default">$f_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">intval </span><span class="keyword">(</span><span class="default">substr </span><span class="keyword">(</span><span class="default">$f_v</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$repeater </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">1</span><span class="keyword">} == </span><span class="string">'*'</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">count </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">) - </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">} != </span><span class="string">'d'</span><span class="keyword">) { </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">$repeater</span><span class="keyword">; continue; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$repeater</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$a </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">; </span><span class="default">$a </span><span class="keyword">&lt; </span><span class="default">$j</span><span class="keyword">; ++</span><span class="default">$a</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'d'</span><span class="keyword">,</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">strrev </span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list (</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'d1d'</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ++</span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$ar </span><span class="keyword">as </span><span class="default">$ar_k </span><span class="keyword">=&gt; </span><span class="default">$ar_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar</span><span class="keyword">[</span><span class="default">$ar_k</span><span class="keyword">] = </span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$a</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; ++</span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$ar</span><span class="keyword">;<br />
}<br />
<br />
list (</span><span class="default">$endiantest</span><span class="keyword">) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'L1L'</span><span class="keyword">, </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'V'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)));<br />
if (</span><span class="default">$endiantest </span><span class="keyword">!= </span><span class="default">1</span><span class="keyword">) </span><span class="default">define </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">);<br />
if (</span><span class="default">defined </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">)) </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'big_endian_unpack'</span><span class="keyword">;<br />
else </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'unpack'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
This workaround is used like this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; global </span><span class="default">$unpack_workaround</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bar </span><span class="keyword">= </span><span class="default">$unpack_workaround</span><span class="keyword">(</span><span class="string">'N7N/V2V/d8d'</span><span class="keyword">,</span><span class="default">$my_data</span><span class="keyword">);<br />
</span><span class="comment">//...<br />
</span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
On a little endian machine, $unpack_workaround will simply point to the function unpack.&nbsp; On a big endian machine, it will call the workaround function.<br />
<br />
Note, this solution only works for doubles.&nbsp; In my project I had no need to check for single precision floats.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45188""></a>
  <div class="note">
   <strong class="user">kennwhite dot nospam at hotmail dot com</strong>
   <a href="#45188" class="date">28-Aug-2004 09:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If having a zero-based index is useful/necessary, then instead of:<br />
<br />
$int_list = unpack("s*", $some_binary_data);<br />
<br />
&nbsp;try:<br />
<br />
$int_list = array_merge(unpack("s*", $some_binary_data));<br />
<br />
This will return a 0-based array:<br />
<br />
$int_list[0] = x<br />
$int_list[1] = y<br />
$int_list[2] = z<br />
...<br />
<br />
rather than the default 1-based array returned from unpack when no key is supplied:<br />
<br />
$int_list[1] = x<br />
$int_list[2] = y<br />
$int_list[3] = z<br />
...<br />
<br />
It's not used often, but array_merge() with only one parameter will compress a sequentially-ordered numeric-index, starting with an index of [0].</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43945""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43945" class="date">09-Jul-2004 07:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is about the last example of my previous post. For the sake of clarity, I'm including again here the example, which expands the one given in the formal documentation:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
This outputs:<br />
<br />
$array[chars1] = 65 <br />
$array[chars2] = 65 <br />
$array[int] = 65 <br />
<br />
Here, we assume that the ascii code for character 'A' is decimal 65.<br />
<br />
Remebering that the format string structure is:<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...],<br />
in this example, the format string instructs the function to<br />
&nbsp; 1. ("c2...") Read two chars from the second argument ("AA ...), <br />
&nbsp; 2. (...chars...) Use the array-keys "chars1", and "chars2" for <br />
&nbsp;&nbsp; &nbsp;&nbsp; these two chars read,<br />
&nbsp; 3. (.../n...) Read a short int from the second argument (...\0A"),<br />
&nbsp; 4. (...int") Use the word "int" as the array key for the just read<br />
&nbsp;&nbsp; &nbsp;&nbsp; short.<br />
<br />
I hope this is clearer now,<br />
<br />
Sergio.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43930""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43930" class="date">09-Jul-2004 04:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Suppose we need to get some kind of internal representation of an integer, say 65, as a four-byte long. Then we use, something like:<br />
<br />
&lt;?<br />
&nbsp; $i = 65;<br />
&nbsp; $s = pack("l", $i); // long 32 bit, machine byte order<br />
&nbsp; echo strlen($s) . "&lt;br&gt;\n";<br />
&nbsp; echo "***$s***&lt;br&gt;\n";<br />
?&gt;<br />
<br />
The output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
4<br />
***A*** <br />
<br />
(That is the string "A\0\0\0")<br />
<br />
Now we want to go back from string "A\0\0\0" to number 65. In this case we can use:<br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number 65<br />
&nbsp; $arr = unpack("l", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value&lt;br&gt;\n";<br />
?&gt;<br />
<br />
And this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[] = 65<br />
<br />
Let's give the array key a name, say "mykey". In this case, we can use: <br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number&nbsp; 65<br />
&nbsp; $arr = unpack("lmykey", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value\n";<br />
?&gt;<br />
<br />
An this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[mykey] = 65<br />
<br />
The "unpack" documentation is a little bit confusing. I think a more complete example could be:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp;&nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
whose output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$array[chars1] = 65 &lt;br&gt;<br />
$array[chars2] = 65 &lt;br&gt;<br />
$array[int] = 65 &lt;br&gt;<br />
<br />
Note that the format string is something like<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...]<br />
<br />
I hope this clarifies something<br />
<br />
Sergio</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="22398""></a>
  <div class="note">
   <strong class="user">adam at adeptsoftware dot com</strong>
   <a href="#22398" class="date">17-Jun-2002 06:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you just want to extract a dword/long int from a binary string, the following code works beautifully (intel endian):<br />
<br />
$Number = ord($Buffer{0}) | (ord($Buffer{1})&lt;&lt;8) | (ord($Buffer{2})&lt;&lt;16) | (ord($Buffer{3})&lt;&lt;24);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="12395""></a>
  <div class="note">
   <strong class="user">DanRichter.at.programmer.dot.net</strong>
   <a href="#12395" class="date">10-Apr-2001 08:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If no key name is given [e.g., unpack('C*',$data)], the keys are simply integers starting at 1, and you have a standard array. (I know of no way to get the array to start at zero.)<br />
<br />
If you use multiple types, you must give a key name for all of them (except optionally one), because the key counter is reset with each slash. For example, in unpack('n2/C*',$data), indices 1 and 2 of the returned array are filled by integers ('n'), then overwritten with characters ('C').</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="4319""></a>
  <div class="note">
   <strong class="user">iredden at redden dot on dot ca</strong>
   <a href="#4319" class="date">12-Mar-2000 01:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">parse_pascalstr</span><span class="keyword">(</span><span class="default">$bytes_parsed</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">) { <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/cstr_len"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str_len </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str_len"</span><span class="keyword">]; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/A"</span><span class="keyword">.</span><span class="default">$str_len</span><span class="keyword">.</span><span class="string">"str"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">); <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str"</span><span class="keyword">]; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); <br />
<br />
&nbsp;&nbsp;&nbsp; return array(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$bytes_parsed</span><span class="keyword">); <br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.uniqid.html">uniqid</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.usleep.html">usleep</a></div>
 <div class="up"><a href="ref.misc.html">その他の関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
