<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>MIME base64 方式によりエンコードされたデータをデコードする</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="ref.url.html">URL 関数</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.base64-encode.html">base64_encode</a></div>
 <div class="up"><a href="ref.url.html">URL 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.base64-decode" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">base64_decode</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">base64_decode</span> &mdash; <span class="dc-title">MIME base64 方式によりエンコードされたデータをデコードする</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.base64-decode-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>base64_decode</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$data</code></span>
   [, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$strict</code><span class="initializer"> = false</span></span>
  ] )</div>

  <p class="para rdfs-comment">
   base64 でエンコードされた <em><code class="parameter">data</code></em>
   をデコードします。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.base64-decode-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><em><code class="parameter">data</code></em></span>
     <dd>

      <p class="para">
       デコードされるデータ。
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><em><code class="parameter">strict</code></em></span>
     <dd>

      <p class="para">
       入力に base64 アルファベットの範囲外の文字が含まれる場合に <strong><code>FALSE</code></strong> を返す。
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.base64-decode-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   もとのデータを返します。失敗した場合に <strong><code>FALSE</code></strong> を返します。
   返り値はバイナリになることもあります。
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.base64-decode-changelog">
  <h3 class="title">変更履歴</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>バージョン</th>
       <th>説明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.2.0</td>
       <td><em><code class="parameter">strict</code></em> が追加されました。</td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.base64-decode-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-4060">
    <p><strong>例1  <span class="function"><strong>base64_decode()</strong></span> の例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$str&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw=='</span><span style="color: #007700">;<br />echo&nbsp;</span><span style="color: #0000BB">base64_decode</span><span style="color: #007700">(</span><span style="color: #0000BB">$str</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>上の例の出力は以下となります。</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
This is an encoded string
</pre></div>
    </div>
   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.base64-decode-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.base64-encode.html" class="function" rel="rdfs-seeAlso">base64_encode()</a> - MIME base64 方式でデータをエンコードする</span></li>
    <li class="member"><a href="http://www.faqs.org/rfcs/rfc2045" class="link external" title="Link : http://www.faqs.org/rfcs/rfc2045">&raquo;&nbsp;RFC 2045</a> 6.8 節</li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="105512""></a>
  <div class="note">
   <strong class="user">nicolem2005 at gmail dot com</strong>
   <a href="#105512" class="date">24-Aug-2011 02:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
base64_decode seems to fail when decoding big files/strings. I had an issue decoding a 7MB image file. Here is a solution that worked for me:<br />
<br />
$decodedstring=base64_decode(chunk_split($encodedstring));</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="104193""></a>
  <div class="note">
   <strong class="user">mekal</strong>
   <a href="#104193" class="date">31-May-2011 02:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to save data that is derived from a Javascript canvas.toDataURL() function, you have to convert blanks into plusses. If you do not do that, the decoded data is corrupted:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; $encodedData </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">' '</span><span class="keyword">,</span><span class="string">'+'</span><span class="keyword">,</span><span class="default">$encodedData</span><span class="keyword">);<br />
&nbsp; </span><span class="default">$decocedData </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encodedData</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
merci..........</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102113""></a>
  <div class="note">
   <strong class="user">winkelnkemper at googlemail dot com</strong>
   <a href="#102113" class="date">27-Jan-2011 01:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to save data that is derived from a Javascript canvas.toDataURL() function, you have to convert blanks into plusses. If you do not do that, the decoded data is corrupted:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; $encodedData </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">' '</span><span class="keyword">,</span><span class="string">'+'</span><span class="keyword">,</span><span class="default">$encodedData</span><span class="keyword">);<br />
&nbsp; </span><span class="default">$decocedData </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encodedData</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92980""></a>
  <div class="note">
   <strong class="user">martinstaemmler at gmx dot net</strong>
   <a href="#92980" class="date">18-Aug-2009 06:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had some trouble trying to let base64_decode decode base64-strings longer than ~5k chars.<br />
<br />
The base64-decoding function is a homomorphism between modulo 4 and modulo 3-length segmented strings. That motivates a divide and conquer approach: Split the encoded string into substrings counting modulo 4 chars, then decode each substring and concatenate all of them.<br />
<br />
Then instead of <br />
<br />
<span class="default">&lt;?php $decoded </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">); </span><span class="default">?&gt;<br />
</span><br />
for big $encoded strings, it's saver to use<br />
<br />
<span class="default">&lt;?php<br />
$decoded </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">;<br />
for (</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">ceil</span><span class="keyword">(</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">)/</span><span class="default">256</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++)<br />
&nbsp;&nbsp; </span><span class="default">$decoded </span><span class="keyword">= </span><span class="default">$decoded </span><span class="keyword">. </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">,</span><span class="default">$i</span><span class="keyword">*</span><span class="default">256</span><span class="keyword">,</span><span class="default">256</span><span class="keyword">));<br />
</span><span class="default">?&gt;<br />
</span><br />
where 256 can be replaced by a sufficiently small modulo 4 natural.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92147""></a>
  <div class="note">
   <strong class="user">dimagolov at yahoo dot com</strong>
   <a href="#92147" class="date">10-Jul-2009 08:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is function to decode Base 62 (see <a href="http://en.wikipedia.org/wiki/Base_62" rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/Base_62</a>) string to number. It is used by MTA in message id, e.g. by Exim<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">base62_decode</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ret</span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$i</span><span class="keyword">= </span><span class="default">0</span><span class="keyword">, </span><span class="default">$l</span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$l</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">ctype_digit</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">-= </span><span class="default">ord</span><span class="keyword">(</span><span class="string">'0'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">ctype_upper</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">-= </span><span class="default">ord</span><span class="keyword">(</span><span class="string">'A'</span><span class="keyword">) - </span><span class="default">10</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">ctype_lower</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">-= </span><span class="default">ord</span><span class="keyword">(</span><span class="string">'a'</span><span class="keyword">) - </span><span class="default">36</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$val</span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret</span><span class="keyword">= </span><span class="default">$ret </span><span class="keyword">* </span><span class="default">62 </span><span class="keyword">+ </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$ret</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="90199""></a>
  <div class="note">
   <strong class="user">mcalwell</strong>
   <a href="#90199" class="date">09-Apr-2009 06:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a problem testing whether an imap message body was base64 encoded on a pre 5.2.* server.&nbsp; I had been using this function on a post 5.2 server.<br />
<br />
I found that the function imap_base64() returns FALSE on failing to decode a string, and that I could use that to check instead.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(</span><span class="default">imap_base64</span><span class="keyword">(</span><span class="default">$body</span><span class="keyword">)) </span><span class="default">$body </span><span class="keyword">= </span><span class="default">imap_base64</span><span class="keyword">(</span><span class="default">$body</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87442""></a>
  <div class="note">
   <strong class="user">alvaro at demogracia dot com</strong>
   <a href="#87442" class="date">05-Dec-2008 10:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can do partial decoding (e.g. from buffered input streams) if you choose a chunk length that is multiple of 4:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$encoded </span><span class="keyword">= </span><span class="default">base64_encode</span><span class="keyword">(</span><span class="string">'The quick brown fox jumps over the lazy dog'</span><span class="keyword">);<br />
for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">=</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$len</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">+=</span><span class="default">4</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">base64_decode</span><span class="keyword">( </span><span class="default">substr</span><span class="keyword">(</span><span class="default">$encoded</span><span class="keyword">, </span><span class="default">$i</span><span class="keyword">, </span><span class="default">4</span><span class="keyword">) );<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
4 encoded chars represent 3 original chars. The "=" character is used as padding.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84349""></a>
  <div class="note">
   <strong class="user">twm at twmacinta dot com</strong>
   <a href="#84349" class="date">10-Jul-2008 05:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To follow up on Starson's post, PHP was changed to no longer treat a space as if it were a plus sign in CVS revision 1.43.2.1, which corresponds to PHP 5.1.0.&nbsp; You can see what happened with a diff to branch point 1.43 at:<br />
<br />
<a href="http://cvs.php.net/viewvc.cgi/php-src/ext/standard/base64.c" rel="nofollow" target="_blank">http://cvs.php.net/viewvc.cgi/php-src/ext/standard/base64.c</a><br />
<br />
The CVS log indicates that this change was made to fix bug #34214 (base64_decode() does not properly ignore whitespace).<br />
<br />
It would seem from the comment preceding the code which was removed that the treatment of the space as if it were the plus sign was actually intentional at one time:<br />
<br />
&nbsp;&nbsp;&nbsp; When Base64 gets POSTed, all pluses are interpreted as spaces.<br />
&nbsp;&nbsp;&nbsp; This line changes them back.&nbsp; It's not exactly the Base64 spec,<br />
&nbsp;&nbsp;&nbsp; but it is completely compatible with it (the spec says that spaces<br />
&nbsp;&nbsp;&nbsp; are invalid).&nbsp; This will also save many people considerable<br />
&nbsp;&nbsp;&nbsp; headache.<br />
<br />
&nbsp;&nbsp;&nbsp; if (ch == ' ') ch = '+';<br />
<br />
However, RFC 3548 states that characters not in the Base64 alphabet should either be ignored or cause the implementation to reject the encoding and RFC 2045 says they should be ignored.&nbsp; So the original code was unfortunately not fully compatible with the spec or other implementations.&nbsp; It may have also masked problems with code not properly escaping POST variables.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81425""></a>
  <div class="note">
   <strong class="user">debug</strong>
   <a href="#81425" class="date">27-Feb-2008 09:39</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
@morgangalpin att gmail dotty com<br />
<br />
A better implementation would be the following regular expression:<br />
<br />
^[a-zA-Z0-9/+]*={0,2}$<br />
<br />
Which will also detect the usage of = or == at the end of the string (and only end).<br />
<br />
If this regex isn't following proper RFC guidelines, please comment on it.<br />
<br />
A function geared specifically toward this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">is_base64_encoded</span><span class="keyword">()<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'%^[a-zA-Z0-9/+]*={0,2}$%'</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; };<br />
<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"iash21iawhdj98UH3"</span><span class="keyword">); </span><span class="comment">// true<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"#iu3498r"</span><span class="keyword">); </span><span class="comment">// false<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"asiudfh9w=8uihf"</span><span class="keyword">); </span><span class="comment">// false<br />
</span><span class="default">is_base64_encoded</span><span class="keyword">(</span><span class="string">"a398UIhnj43f/1!+sadfh3w84hduihhjw=="</span><span class="keyword">); </span><span class="comment">// true<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79098""></a>
  <div class="note">
   <strong class="user">zmorris at zsculpt dot com</strong>
   <a href="#79098" class="date">10-Nov-2007 11:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a drop-in replacement for base64_decode(), based on a faster version of morgangalpin's code:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// workaround for bug in php 4.3.11 through 4.4.7, 5.1.2 through 5.2.4 and perhaps others (<a href="http://bugs.php.net/bug.php?id=37244" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=37244</a>)<br />
</span><span class="keyword">function&nbsp; &nbsp; </span><span class="default">base64_decode_fix</span><span class="keyword">( </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$strict </span><span class="keyword">= </span><span class="default">false </span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; if( </span><span class="default">$strict </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">preg_match</span><span class="keyword">( </span><span class="string">'![^a-zA-Z0-9/+=]!'</span><span class="keyword">, </span><span class="default">$data </span><span class="keyword">) )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return( </span><span class="default">false </span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; return( </span><span class="default">base64_decode</span><span class="keyword">( </span><span class="default">$data </span><span class="keyword">) );<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77073""></a>
  <div class="note">
   <strong class="user">morgangalpin att gmail dotty com</strong>
   <a href="#77073" class="date">14-Aug-2007 02:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was having trouble with base64_decode returning false if the data to be decoded wasn't actually encoded. It turns out that it is a bug that exists in PHP version 5.1.2, which I'm using, but it has been fixed in CVS. The relevant bug is: <a href="http://bugs.php.net/bug.php?id=37244 " rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=37244 </a>"base64_decode violates RFC 3548". The fix may become available in 5.2.4 or 6 or whatever is coming next.<br />
<br />
Since I'm not able to upgrade PHP to the latest version, I needed a way to check if some data had actually been encoded before trying to decode it. Here is the function I've used; I hope it helps someone.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; * Check a string of base64 encoded data to make sure it has actually<br />
&nbsp;&nbsp; * been encoded.<br />
&nbsp;&nbsp; *<br />
&nbsp;&nbsp; * @param $encodedString string Base64 encoded string to validate.<br />
&nbsp;&nbsp; * @return Boolean Returns true when the given string only contains <br />
&nbsp;&nbsp; * base64 characters; returns false if there is even one non-base64 character.<br />
&nbsp;&nbsp; */<br />
&nbsp; </span><span class="keyword">function </span><span class="default">checkBase64Encoded</span><span class="keyword">(</span><span class="default">$encodedString</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$length </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encodedString</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Check every character.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$length</span><span class="keyword">; ++</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= </span><span class="default">$encodedString</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp;&nbsp; if (<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (</span><span class="default">$c </span><span class="keyword">&lt; </span><span class="string">'0' </span><span class="keyword">|| </span><span class="default">$c </span><span class="keyword">&gt; </span><span class="string">'9'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (</span><span class="default">$c </span><span class="keyword">&lt; </span><span class="string">'a' </span><span class="keyword">|| </span><span class="default">$c </span><span class="keyword">&gt; </span><span class="string">'z'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (</span><span class="default">$c </span><span class="keyword">&lt; </span><span class="string">'A' </span><span class="keyword">|| </span><span class="default">$c </span><span class="keyword">&gt; </span><span class="string">'Z'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (</span><span class="default">$c </span><span class="keyword">!= </span><span class="string">'+'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (</span><span class="default">$c </span><span class="keyword">!= </span><span class="string">'/'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (</span><span class="default">$c </span><span class="keyword">!= </span><span class="string">'='</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp;&nbsp; ) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Bad character found.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Only good characters found.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">true</span><span class="keyword">;<br />
&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71583""></a>
  <div class="note">
   <strong class="user">Tom</strong>
   <a href="#71583" class="date">06-Dec-2006 07:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function supports "base64url" as described in Section 5 of RFC 4648, "Base 64 Encoding with URL and Filename Safe Alphabet"<br />
<br />
&nbsp;&nbsp;&nbsp; <span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">base64url_decode</span><span class="keyword">(</span><span class="default">$base64url</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$base64 </span><span class="keyword">= </span><span class="default">strtr</span><span class="keyword">(</span><span class="default">$base64url</span><span class="keyword">, </span><span class="string">'-_'</span><span class="keyword">, </span><span class="string">'+/'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$plainText </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$base64</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return (</span><span class="default">$plainText</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69747""></a>
  <div class="note">
   <strong class="user">Starson</strong>
   <a href="#69747" class="date">19-Sep-2006 03:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To expand on Jes' post:<br />
<br />
The change took place between 5.0.5 and 5.1.0.&nbsp; Exactly where I don't know or care.<br />
<br />
In short php &lt;= 5.0.5's base64_decode( $string ) will assume that a space is meant to be a + sign where php &gt;= 5.1.0's base64_decode( $string ) will no longer make that assumption.&nbsp; I did not see this noted in the change log.<br />
<br />
Please note that, as of this writing, mb_convert_encoding( $string, "UTF-8", "BASE64" ) still behaves as base64_decode( $string ) did in php &lt;= 5.0.5 regardless of the version of php you are running.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69298""></a>
  <div class="note">
   <strong class="user">Jes</strong>
   <a href="#69298" class="date">30-Aug-2006 05:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've come across an interesting issue with an external program that submits a gzcompressed base64_encoded string to PHP via POST. The external program encodes the string using the occasional " " (space) character, however if I encode the same original string within PHP (using base64_encode), it uses a "+" (plus) character wherever the external program would use a space. On my deployed machine, running PHP 4.3.9, base64_decode is fine with the " " (space) characters, but my test server running 5.1.4 is not. It took me a while to figure out that was the issue, but I ended up fixing it with a simple:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$post_data </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">" "</span><span class="keyword">,</span><span class="string">"+"</span><span class="keyword">,</span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'string'</span><span class="keyword">])<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
This fix works on both the 4.3.9 and 5.1.4 machines. I am sure that the external program is probably not conforming to the standard, and it isn't a PHP problem per-se; but incase anybody else ever runs into that.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43131""></a>
  <div class="note">
   <strong class="user">paul at ijsfontein dot nl</strong>
   <a href="#43131" class="date">10-Jun-2004 03:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The user notes posted here helped me a lot in writing the PHP code to upload uuencoded files to a server using $_POST. Hardest thing to figure out was why the files came out scrambled and corrupted. After comparing the original file with the file reconstructed by the uudecode script, I found out that a simple "stripcslashes" on the posted data will do the trick.<br />
<br />
So, to upload any kind of uuencoded file using a POST:<br />
1. send the raw file data to the PHP script<br />
2. $uuencoded_data = stripcslashes($_POST['filedata']);<br />
3. strip the marker lines from $uuencoded_data (first line, last line and second last line of the data. Each line is seperated by a LF (chr(10)) character.)<br />
4. $decoded_data = uudecode($stripped_uuencoded_data); (this function can be found in the user notes here).<br />
5. Use the script provided in one of the user notes on this page to write the decoded data to a binary file.<br />
<br />
That should do the trick!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="38479""></a>
  <div class="note">
   <strong class="user">tobias at silverxnet dot de</strong>
   <a href="#38479" class="date">23-Dec-2003 09:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was wondering how to decode attached images within mails. Basically they are mostly JPEG files, so it was obviously to write a function that decodes JPEG images.<br />
I guess the plainest way to do so was the following:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">base64_to_jpeg</span><span class="keyword">( </span><span class="default">$inputfile</span><span class="keyword">, </span><span class="default">$outputfile </span><span class="keyword">) {<br />
&nbsp; </span><span class="comment">/* read data (binary) */<br />
&nbsp; </span><span class="default">$ifp </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">( </span><span class="default">$inputfile</span><span class="keyword">, </span><span class="string">"rb" </span><span class="keyword">);<br />
&nbsp; </span><span class="default">$imageData </span><span class="keyword">= </span><span class="default">fread</span><span class="keyword">( </span><span class="default">$ifp</span><span class="keyword">, </span><span class="default">filesize</span><span class="keyword">( </span><span class="default">$inputfile </span><span class="keyword">) );<br />
&nbsp; </span><span class="default">fclose</span><span class="keyword">( </span><span class="default">$ifp </span><span class="keyword">);<br />
&nbsp; </span><span class="comment">/* encode &amp; write data (binary) */<br />
&nbsp; </span><span class="default">$ifp </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">( </span><span class="default">$outputfile</span><span class="keyword">, </span><span class="string">"wb" </span><span class="keyword">);<br />
&nbsp; </span><span class="default">fwrite</span><span class="keyword">( </span><span class="default">$ifp</span><span class="keyword">, </span><span class="default">base64_decode</span><span class="keyword">( </span><span class="default">$imageData </span><span class="keyword">) );<br />
&nbsp; </span><span class="default">fclose</span><span class="keyword">( </span><span class="default">$ifp </span><span class="keyword">);<br />
&nbsp; </span><span class="comment">/* return output filename */<br />
&nbsp; </span><span class="keyword">return( </span><span class="default">$outputfile </span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
This function decodes the given inputfile (a filename!) and saves it to the given outputfile (a filename as well) and then returns the output filename for further usage (e.g. redirect, imagejpeg() and so on).<br />
I thought that might be helpful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31316""></a>
  <div class="note">
   <strong class="user">Klaus Fehrenbacher</strong>
   <a href="#31316" class="date">17-Apr-2003 01:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
this script can correct the bug<br />
<br />
<span class="default">&lt;?php<br />
$enc </span><span class="keyword">= </span><span class="default">chunk_split</span><span class="keyword">(</span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">'!\015\012|\015|\012!'</span><span class="keyword">,</span><span class="string">''</span><span class="keyword">,</span><span class="default">$enc</span><span class="keyword">));<br />
</span><span class="default">$enc </span><span class="keyword">= </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$enc</span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="20080""></a>
  <div class="note">
   <strong class="user">nsayer at kfu dot com</strong>
   <a href="#20080" class="date">21-Mar-2002 10:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I used to do uudecode as a C module, but I've discovered a really fast way to do it in PHP. Here it is:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">uudecode</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$b64chars</span><span class="keyword">=</span><span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ\<br />
abcdefghijklmnopqrstuvwxyz0123456789+/"</span><span class="keyword">;<br />
<br />
&nbsp; </span><span class="default">$encode </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/^./m"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">,</span><span class="default">$encode</span><span class="keyword">);<br />
&nbsp; </span><span class="default">$encode </span><span class="keyword">= </span><span class="default">preg_replace</span><span class="keyword">(</span><span class="string">"/\n/m"</span><span class="keyword">,</span><span class="string">""</span><span class="keyword">,</span><span class="default">$encode</span><span class="keyword">);<br />
&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] == </span><span class="string">'`'</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="string">' '</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="default">$b64chars</span><span class="keyword">[</span><span class="default">ord</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">])-</span><span class="default">32</span><span class="keyword">];<br />
&nbsp; }<br />
<br />
&nbsp; while(</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">) % </span><span class="default">4</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$encode </span><span class="keyword">.= </span><span class="string">"="</span><span class="keyword">;<br />
<br />
&nbsp; return </span><span class="default">base64_decode</span><span class="keyword">(</span><span class="default">$encode</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
This is the PHP equivalent to perl's unpack("u",___). That is, you need to strip the 'begin' and 'end' lines from the typical uuencoded file.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="ref.url.html">URL 関数</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.base64-encode.html">base64_encode</a></div>
 <div class="up"><a href="ref.url.html">URL 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
