<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>指定した関数を __autoload() の実装として登録する</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.spl-autoload-functions.html">spl_autoload_functions</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.spl-autoload-unregister.html">spl_autoload_unregister</a></div>
 <div class="up"><a href="ref.spl.html">SPL 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.spl-autoload-register" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">spl_autoload_register</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.1.2)</p><p class="refpurpose"><span class="refname">spl_autoload_register</span> &mdash; <span class="dc-title">指定した関数を __autoload() の実装として登録する</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.spl-autoload-register-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">bool</span> <span class="methodname"><strong>spl_autoload_register</strong></span>
    ([ <span class="methodparam"><span class="type"><a href="language.types.callable.html" class="type callable">callable</a></span> <code class="parameter">$autoload_function</code></span>
   [, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$throw</code><span class="initializer"> = true</span></span>
   [, <span class="methodparam"><span class="type">bool</span> <code class="parameter">$prepend</code><span class="initializer"> = false</span></span>
  ]]] )</div>

  <p class="para rdfs-comment">
   指定した関数を、spl が提供する __autoload スタックに登録します。
   スタックがまだアクティブになっていない場合は、まずアクティブにします。
  </p>
  <p class="para">
   もしあなたのコード中に  <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> 関数が存在するのなら、
   それを明示的に __autoload スタックに登録しなければなりません。
   なぜなら、 <span class="function"><strong>spl_autoload_register()</strong></span> は、
    <span class="function"><a href="function.spl-autoload.html" class="function">spl_autoload()</a></span> あるいは  <span class="function"><a href="function.spl-autoload-call.html" class="function">spl_autoload_call()</a></span> によって
    <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> 関数のエンジンキャッシュを効率的に置き換えるからです。
  </p>
  <p class="para">
   複数の autoload 関数が必要となる場合でも  <span class="function"><strong>spl_autoload_register()</strong></span>
   は対応できます。この関数は autoload 関数のキューを作成し、
   定義された順にそれを実行していきます。一方
    <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> は、一度しか定義できません。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.spl-autoload-register-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><em><code class="parameter">autoload_function</code></em></span>
     <dd>

      <p class="para">
       登録したい autoload 関数。
       パラメータが指定されなかった場合は、デフォルト実装である
        <span class="function"><a href="function.spl-autoload.html" class="function">spl_autoload()</a></span> が登録されます。
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><em><code class="parameter">throw</code></em></span>
     <dd>

      <p class="para">
       このパラメータは、
        <span class="function"><strong>spl_autoload_register()</strong></span>
       が <em><code class="parameter">autoload_function</code></em>
       を登録できなかったときに例外をスローするかどうかを指定します。
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><em><code class="parameter">prepend</code></em></span>
     <dd>

      <p class="para">
       true の場合、 <span class="function"><strong>spl_autoload_register()</strong></span>
       はスタックの最後の追加するのではなく先頭に追加します。
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.spl-autoload-register-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   成功した場合に <strong><code>TRUE</code></strong> を、失敗した場合に <strong><code>FALSE</code></strong> を返します。
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.spl-autoload-register-changelog">
  <h3 class="title">変更履歴</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>バージョン</th>
       <th>説明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>5.3.0</td>
       <td>
        名前空間に対応するようになりました。
       </td>
      </tr>

      <tr>
       <td>5.3.0</td>
       <td>
        <em><code class="parameter">prepend</code></em> パラメータが追加されました。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.spl-autoload-register-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-3899">
    <p><strong>例1  <span class="function"><strong>spl_autoload_register()</strong></span> を  <span class="function"><a href="function.autoload.html" class="function">__autoload()</a></span> 関数の代わりに使う例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #FF8000">//&nbsp;function&nbsp;__autoload($class)&nbsp;{<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;'classes/'&nbsp;.&nbsp;$class&nbsp;.&nbsp;'.class.php';<br />//&nbsp;}<br /><br /></span><span style="color: #007700">function&nbsp;</span><span style="color: #0000BB">my_autoloader</span><span style="color: #007700">(</span><span style="color: #0000BB">$class</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;</span><span style="color: #DD0000">'classes/'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$class&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">'.class.php'</span><span style="color: #007700">;<br />}<br /><br /></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(</span><span style="color: #DD0000">'my_autoloader'</span><span style="color: #007700">);<br /><br /></span><span style="color: #FF8000">//&nbsp;あるいは、PHP&nbsp;5.3.0&nbsp;以降なら無名関数を使えます<br /></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(function&nbsp;(</span><span style="color: #0000BB">$class</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;</span><span style="color: #DD0000">'classes/'&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$class&nbsp;</span><span style="color: #007700">.&nbsp;</span><span style="color: #DD0000">'.class.php'</span><span style="color: #007700">;<br />});<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
   <div class="example" id="example-3900">
    <p><strong>例2  <span class="function"><strong>spl_autoload_register()</strong></span> でクラスをロードしない例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #007700">namespace&nbsp;</span><span style="color: #0000BB">Foobar</span><span style="color: #007700">;<br /><br />class&nbsp;</span><span style="color: #0000BB">Foo&nbsp;</span><span style="color: #007700">{<br />&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;public&nbsp;function&nbsp;</span><span style="color: #0000BB">test</span><span style="color: #007700">(</span><span style="color: #0000BB">$name</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;</span><span style="color: #DD0000">'[['</span><span style="color: #007700">.&nbsp;</span><span style="color: #0000BB">$name&nbsp;</span><span style="color: #007700">.</span><span style="color: #DD0000">']]'</span><span style="color: #007700">;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></span><span style="color: #0000BB">spl_autoload_register</span><span style="color: #007700">(</span><span style="color: #0000BB">__NAMESPACE__&nbsp;</span><span style="color: #007700">.</span><span style="color: #DD0000">'\Foo::test'</span><span style="color: #007700">);&nbsp;</span><span style="color: #FF8000">//&nbsp;PHP&nbsp;5.3.0&nbsp;以降<br /><br /></span><span style="color: #007700">new&nbsp;</span><span style="color: #0000BB">InexistentClass</span><span style="color: #007700">;<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>上の例の出力は、
たとえば以下のようになります。</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
[[Foobar\InexistentClass]]
Fatal error: Class &#039;Foobar\InexistentClass&#039; not found in ...
</pre></div>
    </div>
   </div>
  </p>
 </div>

 
 <div class="refsect1 seealso" id="refsect1-function.spl-autoload-register-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.autoload.html" class="function" rel="rdfs-seeAlso">__autoload()</a> - 未定義のクラスのロードを試みる</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="113362""></a>
  <div class="note">
   <strong class="user">Kurd the Great</strong>
   <a href="#113362" class="date">02-Oct-2013 01:13</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if(!defined('BASE_PATH')) {<br />
&nbsp;&nbsp;&nbsp; define('BASE_PATH', dirname(__FILE__) . '/');<br />
&nbsp;&nbsp;&nbsp; require BASE_PATH . 'Autoloader.php';<br />
&nbsp;&nbsp;&nbsp; Autoloader::Register();<br />
}<br />
<br />
class Autoloader<br />
{<br />
&nbsp;&nbsp;&nbsp; public static function Register() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return spl_autoload_register(array('Autoloader', 'Load'));<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; public static function Load($strObjectName) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(class_exists($strObjectName) === false) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return false;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $strObjectFilePath = BASE_PATH . $strObjectName . '.php';<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if((file_exists($strObjectFilePath) === false) || (is_readable($strObjectFilePath) === false)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return false;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; require($strObjectFilePath);<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="113251""></a>
  <div class="note">
   <strong class="user">phil at propcom dot co dot uk</strong>
   <a href="#113251" class="date">18-Sep-2013 05:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is important to note that the autoloader will NOT be called if an E_STRICT error triggers the error handler which, in turn, tries to use classes which are not yet loaded. <br />
<br />
In this instance, you should manually load classes required by the error handler.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112804""></a>
  <div class="note">
   <strong class="user">ali dot taheri dot m at gmail dot com</strong>
   <a href="#112804" class="date">24-Jul-2013 11:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've made a little function that makes and registers a loader that seems to be safe and reliable although I'm not sure but it feels like a good idea to share, it took me some time to come up with it I hope it saves someone some time, <br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">Loader</span><span class="keyword">(</span><span class="default">$root </span><span class="keyword">= </span><span class="string">""</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$loaderFunction </span><span class="keyword">= </span><span class="default">create_function</span><span class="keyword">(</span><span class="string">'$class'</span><span class="keyword">, </span><span class="string">'include&nbsp; "' </span><span class="keyword">. </span><span class="default">$root </span><span class="keyword">. </span><span class="string">'$class.php";'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$loaderFunction</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
if you have a file system exactly like your directory tree this function works perfectly, I haven't tested it on unix, but on windows, the default loader fails when your webpage isn't in the root directory, this makes sure that it won't cause a problem if your webpage is on a subdir too just pass ../ or more drived ../../ as root and it will work like a charm, note that i couldn't use anonymous functions because then the $root variable wouldn't have the same scope as the Loader function, so the function must be created on the fly. this is a good example of this functions usage<br />
<br />
your class:<br />
root/classes/support/classic.php<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">namespace </span><span class="default">classes</span><span class="keyword">/</span><span class="default">support</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; class </span><span class="default">classic </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// class def<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
root/support/index.php<br />
<span class="default">&lt;?php<br />
<br />
Loader</span><span class="keyword">(</span><span class="string">'../'</span><span class="keyword">);<br />
<br />
use </span><span class="default">classes</span><span class="keyword">/</span><span class="default">support</span><span class="keyword">/</span><span class="default">classic</span><span class="keyword">;<br />
<br />
</span><span class="default">$cls </span><span class="keyword">= new </span><span class="default">classic</span><span class="keyword">();<br />
</span><span class="comment">//use $cls<br />
</span><span class="default">?&gt;<br />
</span><br />
the loader will make a function like this:<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function(</span><span class="default">$class</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; include&nbsp; </span><span class="string">"../</span><span class="default">$class</span><span class="string">.php"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">//when and when the class is needed this will run the script which is indeed what we need:<br />
<br />
</span><span class="keyword">include </span><span class="string">'../classes/support/classic.php'</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
hope this helps folks;</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112260""></a>
  <div class="note">
   <strong class="user">sebastian at 34n dot de</strong>
   <a href="#112260" class="date">24-May-2013 06:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can also use it like this:<br />
<br />
&gt; spl_autoload_register ( array( new AutoloaderClass, 'method') );<br />
<br />
or in PHP &gt; 5.3:<br />
<br />
&gt; spl_autoload_register ( [ new My\Namespace\Autoloader, 'method'] );<br />
<br />
On this way you dont have to create a variable, which is used once.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="111875""></a>
  <div class="note">
   <strong class="user">a dot schaffhirt at sedna-soft dot de</strong>
   <a href="#111875" class="date">07-Apr-2013 10:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
What I said here previously is only true on Windows. The built-in default autoloader that is registered when you call spl_autoload_register() without any arguments simply adds the qualified class name plus the registered file extension (.php) to each of the include paths and tries to include that file.<br />
<br />
Example (on Windows):<br />
<br />
include paths:<br />
- "."<br />
- "d:/projects/phplib"<br />
<br />
qualified class name to load:<br />
network\http\rest\Resource<br />
<br />
Here's what happens:<br />
<br />
PHP tries to load<br />
'.\\network\\http\\rest\\Resource.php'<br />
-&gt; file not found<br />
<br />
PHP tries to load<br />
'd:/projects/phplib\\network\\http\\rest\\Resource.php'<br />
-&gt; file found and included<br />
<br />
Note the slashes and backslashes in the file path. On Windows this works perfectly, but on a Linux machine, the backslashes won't work and additionally the file names are case-sensitive.<br />
<br />
That's why on Linux the quick-and-easy way would be to convert these qualified class names to slashes and to lowercase and pass them to the built-in autoloader like so:<br />
<br />
<span class="default">&lt;?php<br />
spl_autoload_register</span><span class="keyword">(<br />
&nbsp; function (</span><span class="default">$pClassName</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload</span><span class="keyword">(</span><span class="default">strtolower</span><span class="keyword">(</span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">"\\"</span><span class="keyword">, </span><span class="string">"/"</span><span class="keyword">, </span><span class="default">$pClassName</span><span class="keyword">)));<br />
&nbsp; }<br />
);<br />
</span><span class="default">?&gt;<br />
</span><br />
But this means, you have to save all your classes with lowercase file names. Otherwise, if you omit the strtolower call, you have to use the class names exactly as specified by the file name, which can be annoying for class names that are defined with non-straightforward case like e. g. XMLHttpRequest.<br />
<br />
I prefer the lowercase approach, because it is easier to use and the file name conversion can be done automatically on deploying.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="110382""></a>
  <div class="note">
   <strong class="user">daniel at amnistechnology dot com</strong>
   <a href="#110382" class="date">17-Oct-2012 06:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Cleverly - and usefully - I have noticed that (on PHP 5.3 at least) these autoloaders "kick in" even when you call a public static method of an as-yet-unloaded all static class.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107362""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#107362" class="date">04-Feb-2012 01:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that when specifying the third parameter (prepend), the function will fail badly in PHP 5.2</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102180""></a>
  <div class="note">
   <strong class="user">(delphists) at (apollo) dot (lv)</strong>
   <a href="#102180" class="date">01-Feb-2011 10:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When using spl_autoload_register() with class methods, it might seem that it can use only public methods, though it can use private/protected methods as well, if registered from inside the class:<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">ClassAutoloader </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public function </span><span class="default">__construct</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$this</span><span class="keyword">, </span><span class="string">'loader'</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; private function </span><span class="default">loader</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">'Trying to load '</span><span class="keyword">, </span><span class="default">$className</span><span class="keyword">, </span><span class="string">' via '</span><span class="keyword">, </span><span class="default">__METHOD__</span><span class="keyword">, </span><span class="string">"()\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; include </span><span class="default">$className </span><span class="keyword">. </span><span class="string">'.php'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$autoloader </span><span class="keyword">= new </span><span class="default">ClassAutoloader</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Class1</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$obj </span><span class="keyword">= new </span><span class="default">Class2</span><span class="keyword">();<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Output:<br />
--------<br />
Trying to load Class1 via ClassAutoloader::loader()<br />
Class1::__construct()<br />
Trying to load Class2 via ClassAutoloader::loader()<br />
Class2::__construct()</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98746""></a>
  <div class="note">
   <strong class="user">anthon at piwik dot org</strong>
   <a href="#98746" class="date">05-Jul-2010 06:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Think twice about throwing an exception from a registered autoloader.<br />
<br />
If you have multiple autoloaders registered, and one (or more) throws an exception before a later autoloader loads the class, stacked exceptions are thrown (and must be caught) even though the class was loaded successfully.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96952""></a>
  <div class="note">
   <strong class="user">sebastian dot krebs at kingcrunch dot de</strong>
   <a href="#96952" class="date">24-Mar-2010 07:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems, that&nbsp; spl_autoload tests, if the class exists, after calling every registered loader. So it breaks the chain, if the class exists and will not call the other loaders<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">a </span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) {<br />
&nbsp; echo </span><span class="string">"a\n"</span><span class="keyword">;<br />
&nbsp; class </span><span class="default">Bla </span><span class="keyword">{} </span><span class="comment">// Usually "include 'path/to/file.php';"<br />
</span><span class="keyword">}<br />
function </span><span class="default">b </span><span class="keyword">(</span><span class="default">$c</span><span class="keyword">) {<br />
&nbsp; echo </span><span class="string">"b\n"</span><span class="keyword">;<br />
}<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'a'</span><span class="keyword">);<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'b'</span><span class="keyword">);<br />
<br />
</span><span class="default">$c </span><span class="keyword">= new </span><span class="default">Bla</span><span class="keyword">();<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96804""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#96804" class="date">17-Mar-2010 05:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Be careful using this function on case sensitive file systems.<br />
<br />
<span class="default">&lt;?php<br />
spl_autoload_extensions</span><span class="keyword">(</span><span class="string">'.php'</span><span class="keyword">);<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
I develop on OS X and everything was working fine. But when releasing to my linux server, none of my class files were loading. I had to lowercase all my filenames, because calling a class "DatabaseObject" would try including "databaseobject.php", instead of "DatabaseObject.php"<br />
<br />
I think i'll go back to using the slower __autoload() function, just so i can keep my class files readable</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95456""></a>
  <div class="note">
   <strong class="user">rayro at gmx dot de</strong>
   <a href="#95456" class="date">04-Jan-2010 12:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is never a good idea and a unconscienable concept to create the classes in the autoload function via eval. <br />
It should be a nice feature with these Exception, but i think anyone is able to handle it without this method although. Atm i dont realize for what this is good for...<br />
<br />
As i might note, class_exists() will ever define the classes u only want to check for existance, and will therefor ever return true:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">EvalIsEvil</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
&nbsp; eval(</span><span class="string">'class '</span><span class="keyword">.</span><span class="default">$className</span><span class="keyword">.</span><span class="string">'{}'</span><span class="keyword">);<br />
}<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'EvalIsEvil'</span><span class="keyword">);<br />
if (</span><span class="default">class_exists</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">=</span><span class="string">"IsMyModuleHere"</span><span class="keyword">)) {<br />
&nbsp; </span><span class="comment">// this is no module, but get there with eval()...<br />
&nbsp; </span><span class="keyword">return new </span><span class="default">$s</span><span class="keyword">();<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92514""></a>
  <div class="note">
   <strong class="user">a dot schaffhirt at sedna-soft dot de</strong>
   <a href="#92514" class="date">28-Jul-2009 04:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Good news for PHP 5.3 users with namespaced classes:<br />
<br />
When you create a subfolder structure matching the namespaces of the containing classes, you will never even have to define an autoloader.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; spl_autoload_extensions</span><span class="keyword">(</span><span class="string">".php"</span><span class="keyword">); </span><span class="comment">// comma-separated list<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">();<br />
</span><span class="default">?&gt;<br />
</span><br />
It is recommended to use only one extension for all classes. PHP (more exactly spl_autoload) does the rest for you and is even quicker than a semantically equal self-defined autoload function like this one:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">my_autoload </span><span class="keyword">(</span><span class="default">$pClassName</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; include(</span><span class="default">__DIR__ </span><span class="keyword">. </span><span class="string">"/" </span><span class="keyword">. </span><span class="default">$pClassName </span><span class="keyword">. </span><span class="string">".php"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">"my_autoload"</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
I compared them with the following setting: There are 10 folders, each having 10 subfolders, each having 10 subfolders, each containing 10 classes.<br />
<br />
To load and instantiate these 1000 classes (parameterless no-action constructor), the user-definded autoload function approach took 50ms longer in average than the spl_autoload function in a series of 10 command-line calls for each approach.<br />
<br />
I made this benchmark to ensure that I don't recommend something that could be called "nice, but slow" later.<br />
<br />
Best regards,</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="78122""></a>
  <div class="note">
   <strong class="user">stanlemon at mac dot com</strong>
   <a href="#78122" class="date">28-Sep-2007 07:20</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Editorial note: The appropriate PHP bug that requests behavior this function emulates is <a href="http://bugs.php.net/bug.php?id=42823 . This function does NOT work if there has been an array($obj, " rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=42823 . This function does NOT work if there has been an array($obj, </a>'nonStaticMethod') registered in the autoload stack--while the autoload will be removed, it will be re-registered incorrectly.<br />
<br />
The spl_autoload_register() method registers functions in its stack in the order that spl_autoload_register() was called, and subsequently if you want an autoload function to override previous autoload functions you will either need to unregister the previous ones or change the order of the autoload stack.<br />
<br />
For example, say in your default implementation of an autoload function you throw an exception if the class cannot be found, or perhaps a fatal error.&nbsp; Later on in your code you add a second implementation of an autoload function which will load a library that the previous method would fail on.&nbsp; This will not call the second autoloader method first, but rather will continue to error out on the first method.<br />
<br />
As previously mentioned, you can unregister the existing autoloader that errors out, or you can create a mechanism for unregistering and re-registering the autoloaders in the order you want.<br />
<br />
Here is a sample/example of how you might consider re-registering autoloaders so that the newest autoloader is called first, and the oldest last:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// Editorial notes: Small bug and compatibility fixes<br />
// added to the function<br />
<br />
</span><span class="keyword">function </span><span class="default">spl_autoload_preregister</span><span class="keyword">( </span><span class="default">$autoload </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// No functions currently in the stack.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if ( (</span><span class="default">$funcs </span><span class="keyword">= </span><span class="default">spl_autoload_functions</span><span class="keyword">()) === </span><span class="default">false </span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$autoload</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Unregister existing autoloaders...<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$compat </span><span class="keyword">=<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">version_compare</span><span class="keyword">(</span><span class="default">PHP_VERSION</span><span class="keyword">, </span><span class="string">'5.1.2'</span><span class="keyword">, </span><span class="string">'&lt;='</span><span class="keyword">) &amp;&amp;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">version_compare</span><span class="keyword">(</span><span class="default">PHP_VERSION</span><span class="keyword">, </span><span class="string">'5.1.0'</span><span class="keyword">, </span><span class="string">'&gt;='</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$funcs </span><span class="keyword">as </span><span class="default">$func</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// :TRICKY: There are some compatibility issues and some<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // places where we need to error out<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$reflector </span><span class="keyword">= new </span><span class="default">ReflectionMethod</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">], </span><span class="default">$func</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">$reflector</span><span class="keyword">-&gt;</span><span class="default">isStatic</span><span class="keyword">()) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; throw new </span><span class="default">Exception</span><span class="keyword">(</span><span class="string">'<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; This function is not compatible<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; with non-static object methods due to PHP Bug #44144.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; '</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Suprisingly, spl_autoload_register supports the<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Class::staticMethod callback format, although call_user_func doesn't<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$compat</span><span class="keyword">) </span><span class="default">$func </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">(</span><span class="string">'::'</span><span class="keyword">, </span><span class="default">$func</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_unregister</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Register the new one, thus putting it at the front of the stack...<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$autoload</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Now, go back and re-register all of our old ones.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$funcs </span><span class="keyword">as </span><span class="default">$func</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="default">$func</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Note: I have not tested this for overhead, so I am not 100% sure what the performance implication of the above example are.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73146""></a>
  <div class="note">
   <strong class="user">harvey dot NO_SPAM dot robin at gmail dot com</strong>
   <a href="#73146" class="date">10-Feb-2007 02:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function is smart enough not to add the same loader twice.&nbsp; This seems to work for all of the different loader formats.&nbsp; Example:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">ALoader<br />
</span><span class="keyword">{<br />
&nbsp; static function </span><span class="default">load</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) { return </span><span class="default">true</span><span class="keyword">; }<br />
}<br />
<br />
function </span><span class="default">anotherLoader</span><span class="keyword">(</span><span class="default">$class</span><span class="keyword">) {<br />
&nbsp; return </span><span class="default">true</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">$F </span><span class="keyword">= new </span><span class="default">ALoader</span><span class="keyword">;<br />
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'ALoader'</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'ALoader'</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$F</span><span class="keyword">, </span><span class="string">'load'</span><span class="keyword">));<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'anotherLoader'</span><span class="keyword">);<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(</span><span class="string">'anotherLoader'</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">spl_autoload_functions</span><span class="keyword">());<br />
<br />
</span><span class="comment">/*<br />
&nbsp;* Results on PHP5.2 CLI, linux.<br />
&nbsp;* array(2) {<br />
&nbsp;*&nbsp; [0]=&gt;<br />
&nbsp;*&nbsp; array(2) {<br />
&nbsp;*&nbsp; &nbsp; [0]=&gt;<br />
&nbsp;*&nbsp; &nbsp; string(7) "ALoader"<br />
&nbsp;*&nbsp; &nbsp; [1]=&gt;<br />
&nbsp;*&nbsp; &nbsp; string(4) "load"<br />
&nbsp;*&nbsp; }<br />
&nbsp;*&nbsp; [1]=&gt;<br />
&nbsp;*&nbsp; string(13) "anotherLoader"<br />
&nbsp;* }<br />
&nbsp;*/<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="71155""></a>
  <div class="note">
   <strong class="user">florent at mediagonale dot com</strong>
   <a href="#71155" class="date">14-Nov-2006 10:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If your autoload function is a class method, you can call spl_autoload_register with an array specifying the class and the method to run.<br />
<br />
* You can use a static method :<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">class </span><span class="default">MyClass </span><span class="keyword">{<br />
&nbsp; public static function </span><span class="default">autoload</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// ...<br />
&nbsp; </span><span class="keyword">}<br />
}<br />
<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="string">'MyClass'</span><span class="keyword">, </span><span class="string">'autoload'</span><span class="keyword">));<br />
</span><span class="default">?&gt;<br />
</span><br />
* Or you can use an instance :<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">MyClass </span><span class="keyword">{<br />
&nbsp; public function </span><span class="default">autoload</span><span class="keyword">(</span><span class="default">$className</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// ...<br />
&nbsp; </span><span class="keyword">}<br />
}<br />
<br />
</span><span class="default">$instance </span><span class="keyword">= new </span><span class="default">MyClass</span><span class="keyword">();<br />
</span><span class="default">spl_autoload_register</span><span class="keyword">(array(</span><span class="default">$instance</span><span class="keyword">, </span><span class="string">'autoload'</span><span class="keyword">));<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.spl-autoload-functions.html">spl_autoload_functions</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.spl-autoload-unregister.html">spl_autoload_unregister</a></div>
 <div class="up"><a href="ref.spl.html">SPL 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
