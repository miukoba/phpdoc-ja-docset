<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>proc_open
  で開かれたプロセスに関する情報を取得する</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.proc-close.html">proc_close</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.proc-nice.html">proc_nice</a></div>
 <div class="up"><a href="ref.exec.html">プログラム実行関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.proc-get-status" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">proc_get_status</h1>
  <p class="verinfo">(PHP 5)</p><p class="refpurpose"><span class="refname">proc_get_status</span> &mdash; <span class="dc-title"> <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span>
  で開かれたプロセスに関する情報を取得する</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.proc-get-status-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">array</span> <span class="methodname"><strong>proc_get_status</strong></span>
    ( <span class="methodparam"><span class="type">resource</span> <code class="parameter">$process</code></span>
   )</div>

  <p class="para rdfs-comment">
    <span class="function"><strong>proc_get_status()</strong></span> は、 <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span>
   で開かれたプロセスに関する情報を取得します。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.proc-get-status-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><em><code class="parameter">process</code></em></span>
     <dd>

      <p class="para">
       評価される  <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span> <span class="type"><span class="type リソース">リソース</span></span>
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.proc-get-status-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   成功時は集められた情報の<span class="type"><span class="type 配列">配列</span></span>、失敗時は <strong><code>FALSE</code></strong> 。
   返される配列は次のような要素を持ちます:
  </p>
  <p class="para">
  <table class="doctable informaltable">
   
    <thead>
     <tr><th>要素</th><th>型</th><th>説明</th></tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td>command</td>
      <td><span class="type"><a href="language.types.string.html" class="type string">string</a></span></td>
      <td>
        <span class="function"><a href="function.proc-open.html" class="function">proc_open()</a></span> に指定されたコマンド文字列。
      </td>
     </tr>

     <tr>
      <td>pid</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>プロセス ID</td>
     </tr>

     <tr>
      <td>running</td>
      <td><span class="type"><a href="language.types.boolean.html" class="type bool">bool</a></span></td>
      <td>
       もしプロセスがまだ動いている場合は、<strong><code>TRUE</code></strong> 、すでに終了している場合は
       <strong><code>FALSE</code></strong>。
      </td>
     </tr>

     <tr>
      <td>signaled</td>
      <td><span class="type"><a href="language.types.boolean.html" class="type bool">bool</a></span></td>
      <td>
       子プロセスが、キャッチされていないシグナルにより終了した場合に
       <strong><code>TRUE</code></strong> となります。Windows では常に <strong><code>FALSE</code></strong> にセットされます。
      </td>
     </tr>

     <tr>
      <td>stopped</td>
      <td><span class="type"><a href="language.types.boolean.html" class="type bool">bool</a></span></td>
      <td>
       子プロセスが、シグナルにより停止した時に <strong><code>TRUE</code></strong> となります。
       Windows では常に <strong><code>FALSE</code></strong> にセットされます。
      </td>
     </tr>

     <tr>
      <td>exitcode</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>
       プロセスが返した終了コード
       (<em>running</em> が <strong><code>FALSE</code></strong> の時のみ意味を持ちます)。
       正しい値を返すのは関数を最初にコールした時のみで、次に
       コールした際には <em>-1</em> を返します。
      </td>
     </tr>

     <tr>
      <td>termsig</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>
       プロセスを終了させたシグナルの番号です (<em>signaled</em> が
       <strong><code>TRUE</code></strong> の時のみ意味を持ちます)。
      </td>
     </tr>

     <tr>
      <td>stopsig</td>
      <td><span class="type"><a href="language.types.integer.html" class="type int">int</a></span></td>
      <td>
       プロセスを停止させたシグナルの番号です (<em>stopped</em> が
       <strong><code>TRUE</code></strong> の時のみ意味を持ちます)。
      </td>
     </tr>

    </tbody>
   
  </table>

  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.proc-get-status-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.proc-open.html" class="function" rel="rdfs-seeAlso">proc_open()</a> - コマンドを実行し、入出力用にファイルポインタを開く</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="103189""></a>
  <div class="note">
   <strong class="user">Lachlan Mulcahy</strong>
   <a href="#103189" class="date">30-Mar-2011 08:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is worth noting that proc_get_status will continue to indicate the process that you spawned is running (because it is!) until that process has been able to write everything it wants to write to the STDOUT and STDERR streams.<br />
<br />
PHP seems to use a buffer for this and so the spawned process can can get it's write calls to return immediately. <br />
<br />
However, once this buffer is full the write call will block until you read out some of the information from the stream/pipe.<br />
<br />
This can manifest itself in many ways but generally the called process will still be running, but just not doing anything as it is blocking on being able to write more to STDERR or STDOUT -- whichever stream buffer is full.<br />
<br />
To work around this you should include in your loop of checking proc_get_status' running element a "stream_get_contents" on the relevant pipes.<br />
<br />
I generally use stream_set_blocking($pipies[2], 0) kind of calls to make sure that the stream_get_contents call will not block if there is no data in the stream.<br />
<br />
This one had me stumped for a while, so hopefully it helps someone!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93382""></a>
  <div class="note">
   <strong class="user">Mark Seecof</strong>
   <a href="#93382" class="date">07-Sep-2009 05:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On Unix/Linux, if you change the command line you pass to proc_open() just slightly then proc_get_status() will give you the actual process-id (pid) of your child.<br />
<br />
Suppose you wish to run the external command /usr/bin/compress to create a BSD foo.Z file.&nbsp; Rather than proc_open("/usr/bin/compress /tmp/foo",...) you may invoke proc_open("exec /usr/bin/compress /tmp/foo",...) and then proc_get_status()['pid'] will be the actual pid of /usr/bin/compress.<br />
<br />
Why?&nbsp; Because the way proc_open() actually works on Unix/Linux is by starting "/bin/sh -c usercmd userargs...", e.g., "/bin/sh -c /usr/bin/compress /tmp/foo".[Note 1]&nbsp; That means normally your command is the child of the shell, so the pid you retrieve with proc_get_status() is the pid of the shell (PHP's child), and you have to fumble around trying to find the pid of your command (PHP's grandchild).&nbsp; But if you put "exec" in front of your command, you tell the shell to *replace itself* with your command without starting another process (technically, to exec your command without forking first).&nbsp; That means your command will inherit the pid of the shell, which is the pid that proc_get_status() returns.<br />
<br />
So if you would like the actual pid of the process running your command, just prepend "exec " to&nbsp; your proc_open() command argument then retrieve the pid using proc_get_status().<br />
<br />
This also makes proc_terminate() and proc_close() work more like you might prefer, since they will affect the actual process running your command (which will be a child process rather than a grandchild process).<br />
<br />
[Note 1] My guess is that the PHP developers want the shell to expand wildcards in path/filenames.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92145""></a>
  <div class="note">
   <strong class="user">php dot net at crazedsanity dot com</strong>
   <a href="#92145" class="date">10-Jul-2009 05:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For clarification, the "exitcode" is only valid the FIRST TIME IT IS CALLED after the process exits.<br />
<br />
If you have a method that polls a spawned process for its status, you *MUST* have that same method capture the exitcode: if the method is called a second time (after realizing the pid is dead) and it hasn't cached that exitcode, it will receive the -1 mentioned.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87894""></a>
  <div class="note">
   <strong class="user">lytithwyn at gmail dot com</strong>
   <a href="#87894" class="date">29-Dec-2008 03:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I have had lots of problems in the past bit trying to kill external commands run by proc_open.<br />
<br />
Others have suggested using ps to find the children of the pid returned by proc_get_status, but on my system this doesn't work.&nbsp; I'm using php-5.2.5 and apache-2.0.59 on linux kernel 2.6.21, and the processes I start with proc_open end up being owned by init (pid 1), not by the pid returned by proc_get_status.<br />
<br />
I did notice, however, that the pid's of the processes were always above and very close to the proc_get_status pid.&nbsp; Using that information, I wrote a little function that takes the name of a command, the starting pid at which to search (which would be the proc_get_status pid), and optionally a search limit as arguments.&nbsp; It will use ps to list processes owned by apache (you may have to change this user name for your system), and search for the command specified.&nbsp; The limit tells how far above the starting pid to search.&nbsp; This will help if the command may have already exited, and you don't want to kill a process from a different session than the one you're working with.<br />
<br />
Here's the code:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">findCommandPID</span><span class="keyword">(</span><span class="default">$command</span><span class="keyword">, </span><span class="default">$startpid</span><span class="keyword">, </span><span class="default">$limit </span><span class="keyword">= </span><span class="default">3</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ps </span><span class="keyword">= `</span><span class="string">ps -u apache --sort=pid -o comm= -o pid=</span><span class="keyword">`;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ps_lines </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">"\n"</span><span class="keyword">, </span><span class="default">$ps</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pattern </span><span class="keyword">= </span><span class="string">"/(\S{1,})(\s{1,})(\d{1,})/"</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; foreach(</span><span class="default">$ps_lines </span><span class="keyword">as </span><span class="default">$line</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">preg_match</span><span class="keyword">(</span><span class="default">$pattern</span><span class="keyword">, </span><span class="default">$line</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//this limits us to finding the command within $limit pid's of the parent;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //eg, if ppid = 245, limit = 3, we won't search past 248 <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">3</span><span class="keyword">] &gt; </span><span class="default">$startpid </span><span class="keyword">+ </span><span class="default">$limit</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//try to match a ps line where the command matches our search <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //at a higher pid than our parent<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(</span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] == </span><span class="default">$command </span><span class="keyword">&amp;&amp; </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">3</span><span class="keyword">] &gt; </span><span class="default">$startpid</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">3</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84338""></a>
  <div class="note">
   <strong class="user">webmaster at rouen dot fr</strong>
   <a href="#84338" class="date">09-Jul-2008 10:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The following function takes an array of shell commands and executes them. It is able to execute up to $nb_max_process at the same time. As soon as one process is terminated, another one is executed. Quite useful if you want to batch process commands on a multi-processor or multi-core environment.<br />
<br />
The example below tries to convert to PNG a list of SVG files submitted on the command line (using Inkscape).<br />
<br />
(it's quick and dirty but works very well for me)<br />
<br />
#!/usr/bin/php<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">pool_execute</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">,</span><span class="default">$nb_max_process</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$pool</span><span class="keyword">=array();<br />
&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$nb_max_process</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]=</span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp; }<br />
<br />
&nbsp; while(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">)&gt;</span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$commande</span><span class="keyword">=</span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$commande_lancee</span><span class="keyword">=</span><span class="default">FALSE</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; while(</span><span class="default">$commande_lancee</span><span class="keyword">==</span><span class="default">FALSE</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">usleep</span><span class="keyword">(</span><span class="default">50000</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">$nb_max_process </span><span class="keyword">and </span><span class="default">$commande_lancee</span><span class="keyword">==</span><span class="default">FALSE</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]===</span><span class="default">FALSE</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]=</span><span class="default">proc_open</span><span class="keyword">(</span><span class="default">$commande</span><span class="keyword">,array(),</span><span class="default">$foo</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$commande_lancee</span><span class="keyword">=</span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$etat</span><span class="keyword">=</span><span class="default">proc_get_status</span><span class="keyword">(</span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$etat</span><span class="keyword">[</span><span class="string">'running'</span><span class="keyword">]==</span><span class="default">FALSE</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">proc_close</span><span class="keyword">(</span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pool</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]=</span><span class="default">proc_open</span><span class="keyword">(</span><span class="default">$commande</span><span class="keyword">,array(),</span><span class="default">$foo</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$commande_lancee</span><span class="keyword">=</span><span class="default">TRUE</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
}<br />
<br />
</span><span class="default">$fichiers</span><span class="keyword">=</span><span class="default">$argv</span><span class="keyword">;<br />
</span><span class="default">array_shift</span><span class="keyword">(</span><span class="default">$fichiers</span><span class="keyword">);<br />
</span><span class="default">$commandes</span><span class="keyword">=array();<br />
foreach(</span><span class="default">$fichiers </span><span class="keyword">as </span><span class="default">$fichier</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$entree</span><span class="keyword">=</span><span class="default">$fichier</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$sortie</span><span class="keyword">=</span><span class="default">basename</span><span class="keyword">(</span><span class="default">$fichier</span><span class="keyword">,</span><span class="string">'.svg'</span><span class="keyword">).</span><span class="string">".png"</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$commandes</span><span class="keyword">[]=</span><span class="string">'inkscape --file='</span><span class="keyword">.</span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$entree</span><span class="keyword">).</span><span class="string">' --export-area-canvas --export-png='</span><span class="keyword">.</span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$sortie</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">pool_execute</span><span class="keyword">(</span><span class="default">$commandes</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">);</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83628""></a>
  <div class="note">
   <strong class="user">strrev xc.noxeh@ellij</strong>
   <a href="#83628" class="date">05-Jun-2008 10:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can NOT rely on pid+1.<br />
You could prefix exec to the command string, this will replace the /bin/sh script with the real thing you want to exec (use only if you don't do 'scary things' like pipes, output redirection, multiple commands, however if you know how they work, go ahead).<br />
If you prefix exec, the /bin/sh process will only start your process, and the PID will be the same.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75725""></a>
  <div class="note">
   <strong class="user">damien at cyg dot net</strong>
   <a href="#75725" class="date">13-Jun-2007 03:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Alternatively, if you're calling a subsequent php script using proc_open, you can have that process echo its own actual PID in the output.<br />
Also, if you go through the /proc filesystem on linux, you can read through /proc/12345 where 12345 is the pid returned by proc_get_status (the pid of the /bin/sh instance) and it will list its child processes within.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74329""></a>
  <div class="note">
   <strong class="user">andy dot shellam at mailnetwork dot co dot uk</strong>
   <a href="#74329" class="date">05-Apr-2007 02:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Further to my previous note, I've found out the PID returned is the PID of the shell (/bin/sh) that then runs the actual command requested.<br />
<br />
I've raised this as bug #41003.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74328""></a>
  <div class="note">
   <strong class="user">andy dot shellam at mailnetwork dot co dot uk</strong>
   <a href="#74328" class="date">05-Apr-2007 01:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To the poster above, same here on FreeBSD 6.1, PHP 5.2.1.<br />
<br />
To get the correct PID to use for posix_kill I have to add 1 to the PID returned from proc_get_status.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.proc-close.html">proc_close</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.proc-nice.html">proc_nice</a></div>
 <div class="up"><a href="ref.exec.html">プログラム実行関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
