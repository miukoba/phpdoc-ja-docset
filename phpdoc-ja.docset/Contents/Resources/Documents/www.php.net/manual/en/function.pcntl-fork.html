<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>現在実行中のプロセスをフォークする</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.pcntl-exec.html">pcntl_exec</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.pcntl-get-last-error.html">pcntl_get_last_error</a></div>
 <div class="up"><a href="ref.pcntl.html">PCNTL 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.pcntl-fork" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">pcntl_fork</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.1.0, PHP 5)</p><p class="refpurpose"><span class="refname">pcntl_fork</span> &mdash; <span class="dc-title">現在実行中のプロセスをフォークする</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.pcntl-fork-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">int</span> <span class="methodname"><strong>pcntl_fork</strong></span>
    ( <span class="methodparam">void</span>
   )</div>

  <p class="para rdfs-comment">
    <span class="function"><strong>pcntl_fork()</strong></span> 関数は、親プロセスとその PID および
   PPID のみが異なる子プロセスを生成します。システム上でのフォークの
   動作の具体的な詳細については、実行するシステムの fork(2) の
   マニュアルを参照ください。
  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.pcntl-fork-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   成功時に、子プロセスの PID が親プロセスの実行スレッドに返され、
   子プロセスの実行スレッドには 0 が返されます。失敗した場合、親プロセスの
   コンテキストに -1 が返され、子プロセスは生成されずに、PHP のエラーが
   出力されます。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.pcntl-fork-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-3624">
    <p><strong>例1  <span class="function"><strong>pcntl_fork()</strong></span> の例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br />$pid&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">pcntl_fork</span><span style="color: #007700">();<br />if&nbsp;(</span><span style="color: #0000BB">$pid&nbsp;</span><span style="color: #007700">==&nbsp;-</span><span style="color: #0000BB">1</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die(</span><span style="color: #DD0000">'fork&nbsp;できません'</span><span style="color: #007700">);<br />}&nbsp;else&nbsp;if&nbsp;(</span><span style="color: #0000BB">$pid</span><span style="color: #007700">)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #FF8000">//&nbsp;親プロセスの場合<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000BB">pcntl_wait</span><span style="color: #007700">(</span><span style="color: #0000BB">$status</span><span style="color: #007700">);&nbsp;</span><span style="color: #FF8000">//&nbsp;ゾンビプロセスから守る<br /></span><span style="color: #007700">}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #FF8000">//&nbsp;子プロセスの場合<br /></span><span style="color: #007700">}<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.pcntl-fork-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.pcntl-waitpid.html" class="function" rel="rdfs-seeAlso">pcntl_waitpid()</a> - 待つかフォークした子プロセスのステータスを返す</span></li>
    <li class="member"> <span class="function"><a href="function.pcntl-signal.html" class="function" rel="rdfs-seeAlso">pcntl_signal()</a> - シグナルハンドラを設定する</span></li>
    <li class="member"> <span class="function"><a href="function.setproctitle.html" class="function" rel="rdfs-seeAlso">setproctitle()</a> - プロセスのタイトルを設定</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="110790""></a>
  <div class="note">
   <strong class="user">manishpatel2280 at gmail dot com</strong>
   <a href="#110790" class="date">08-Dec-2012 03:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Its been easy to fork process with pcntl_fork.. but how can we control or process further once all child processes gets completed.. here is the way we can do that...<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt;= </span><span class="default">5</span><span class="keyword">; ++</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">$pid</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print </span><span class="string">"In child </span><span class="default">$i</span><span class="string">\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exit(</span><span class="default">$i</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">pcntl_waitpid</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">, </span><span class="default">$status</span><span class="keyword">) != -</span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$status </span><span class="keyword">= </span><span class="default">pcntl_wexitstatus</span><span class="keyword">(</span><span class="default">$status</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Child </span><span class="default">$status</span><span class="string"> completed\n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="106860""></a>
  <div class="note">
   <strong class="user">kexianbin at diyism dot com</strong>
   <a href="#106860" class="date">13-Dec-2011 08:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Fork in foreach:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">foreach (</span><span class="default">$tasks </span><span class="keyword">as </span><span class="default">$v</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {if ((</span><span class="default">$pid</span><span class="keyword">=</span><span class="default">pcntl_fork</span><span class="keyword">())===-</span><span class="default">1</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {</span><span class="comment">//...<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">continue;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; else if (</span><span class="default">$pid</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {</span><span class="default">pcntl_wait</span><span class="keyword">(</span><span class="default">$status</span><span class="keyword">, </span><span class="default">WNOHANG</span><span class="keyword">); </span><span class="comment">//protect against zombie children, one wait vs one child<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">}<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; else if (</span><span class="default">$pid</span><span class="keyword">===</span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {</span><span class="default">ob_start</span><span class="keyword">();</span><span class="comment">//prevent output to main process<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">register_shutdown_function</span><span class="keyword">(</span><span class="default">create_function</span><span class="keyword">(</span><span class="string">'$pars'</span><span class="keyword">, </span><span class="string">'ob_end_clean();posix_kill(getmypid(), SIGKILL);'</span><span class="keyword">), array());</span><span class="comment">//to kill self before exit();, or else the resource shared with parent will be closed<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //...<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">exit();</span><span class="comment">//avoid foreach loop in child process<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">}<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="106600""></a>
  <div class="note">
   <strong class="user">nmmm at nmmm dot nu</strong>
   <a href="#106600" class="date">21-Nov-2011 07:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It was driving me crazy that the script was killed couple of hours after I logged out, even I started it as:<br />
<br />
php server.php &gt;&amp; logfile.txt<br />
<br />
looks like PHP somehow interact with standard input, even I do not used it.<br />
<br />
Solution was to start it with nohup:<br />
<br />
nohup php server.php &gt;&amp; logfile.txt<br />
<br />
or to do demonize / run as demon (e.g. fork() and close file descriptors)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100557""></a>
  <div class="note">
   <strong class="user">sean dot kelly at mediatile dot com</strong>
   <a href="#100557" class="date">23-Oct-2010 02:36</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
"Fatal Error" has always been the bane of my world because there is no way to capture and handle the condition in PHP. My team builds almost everything in PHP in order to leverage our core library of code, so it was of the essence to find a solution for this problem of scripts bombing unrecoverably and us never knowing about it.<br />
<br />
One of our background automation systems creates a "task queue" of sorts and for each task in the queue, a PHP module is include()ed to handle the task. Sometimes however a poorly behaved module will nuke with a Fatal Error and take out the parent script with it.<br />
<br />
I decided to try to use pcntl_fork() to isolate the task module from the parent code, and it seems to work: a Fatal Error generated within the module makes the child task bomb, and the waiting parent can simply catch the return code from the child and track/alert us to the problem as needed. <br />
<br />
Naturally something similar could be done if I wanted to simply exec() the module and check the output, but then I would not have the benefit of the stateful environment that the parent script has so carefully prepared. This allows me to keep the child process within the context of the parent's running environment and not suffer the consequences of Fatal Errors stopping the task queue from continuing to process.<br />
<br />
Here is fork_n_wait.php for your amusement:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if (! </span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'pcntl_fork'</span><span class="keyword">)) die(</span><span class="string">'PCNTL functions not available on this PHP installation'</span><span class="keyword">);<br />
<br />
for (</span><span class="default">$x </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$x </span><span class="keyword">&lt; </span><span class="default">5</span><span class="keyword">; </span><span class="default">$x</span><span class="keyword">++) {<br />
&nbsp;&nbsp; switch (</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">()) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; case -</span><span class="default">1</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// @fail<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">die(</span><span class="string">'Fork failed'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; break;<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; case </span><span class="default">0</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// @child: Include() misbehaving code here<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">print </span><span class="string">"FORK: Child #</span><span class="keyword">{</span><span class="default">$x</span><span class="keyword">}</span><span class="string"> preparing to nuke...\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">generate_fatal_error</span><span class="keyword">(); </span><span class="comment">// Undefined function<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">break;<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; default:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="comment">// @parent<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="keyword">print </span><span class="string">"FORK: Parent, letting the child run amok...\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">pcntl_waitpid</span><span class="keyword">(</span><span class="default">$pid</span><span class="keyword">, </span><span class="default">$status</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; break;<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
print </span><span class="string">"Done! :^)\n\n"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Which outputs:<br />
php -q fork_n_wait.php<br />
FORK: Child #1 preparing to nuke...<br />
PHP Fatal error:&nbsp; Call to undefined function generate_fatal_error() in ~fork_n_wait.php on line 16<br />
FORK: Parent, letting the child run amok...<br />
FORK: Child #2 preparing to nuke...<br />
PHP Fatal error:&nbsp; Call to undefined function generate_fatal_error() in ~/fork_n_wait.php on line 16<br />
FORK: Parent, letting the child run amok...<br />
FORK: Child #3 preparing to nuke...<br />
PHP Fatal error:&nbsp; Call to undefined function generate_fatal_error() in ~/fork_n_wait.php on line 16<br />
FORK: Parent, letting the child run amok...<br />
FORK: Child #4 preparing to nuke...<br />
PHP Fatal error:&nbsp; Call to undefined function generate_fatal_error() in ~/fork_n_wait.php on line 16<br />
FORK: Parent, letting the child run amok...<br />
Done! :^)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99369""></a>
  <div class="note">
   <strong class="user">KrazyBox</strong>
   <a href="#99369" class="date">13-Aug-2010 04:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There are quite a few questions regarding how file descriptors get handled when processes are forked. <br />
<br />
Remember that fork() makes a copy of the program, which means all descriptors are copied. Unfortunately, this is a rather bad situation for a PHP program because most descriptors are handled by PHP or a PHP Extension internally.<br />
<br />
The simple, and probably "proper" way to solve this issue is to fork before hand, there really should be no need to fork at many different points among a program, you would simply fork, and then delegate the work. Use a master/worker hierarchy.<br />
<br />
For example, if you need to have many processes that use a MySQL Connection, just fork before the connection is made, that way each child has it´s own connection to mysql that it, and it alone, manages.<br />
<br />
With careful and correct usage, fork() can be an extremely powerful tool.<br />
<br />
--Please remember to take proper care of your children.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99350""></a>
  <div class="note">
   <strong class="user">somebody</strong>
   <a href="#99350" class="date">12-Aug-2010 12:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
you should be _very_ careful with using fork in scripts beyond academic examples,<br />
or rather just avoid it alltogether, unless you are very aware of it's limitations.<br />
<br />
the problem is that it just forks the whole php process, including not only<br />
the state of the script, but also the internal state of any extensions loaded.<br />
this means that all memory is copied, but all file descriptors are shared among<br />
the parent and child processes.<br />
and that can cause major havoc if some extension internally maintains<br />
file descriptors.<br />
the primary example is ofcourse mysql, but this could be any extensions that<br />
maintains open files or network sockets.<br />
also, just reopening your connection in the parent or child isn't a safe<br />
method, because when the old connection resource is destroyed, the extension<br />
might not just close it, but for example send a request to the server to log<br />
off, making the connection unusable.<br />
this happens with mysql for example, when php exits - in the following script the query will always fail with "MySQL server has gone away":<br />
<br />
<span class="default">&lt;?php<br />
mysql_connect</span><span class="keyword">(</span><span class="comment">/* enter a working server here maybe? */</span><span class="keyword">);<br />
if(</span><span class="default">pcntl_fork</span><span class="keyword">()) die(); </span><span class="comment">// fork a child and have the parent terminate<br />
//if(pcntl_fork()) posix_kill(getmypid(),9); // works, but very ugly<br />
</span><span class="default">$r</span><span class="keyword">=</span><span class="default">mysql_query</span><span class="keyword">(</span><span class="string">"select 1;"</span><span class="keyword">);<br />
if(!</span><span class="default">$r</span><span class="keyword">)die(</span><span class="default">mysql_error</span><span class="keyword">().</span><span class="string">"\n"</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>(it was suggested that processes kill themselves with SIGKILL to avoid any cleanup on shutdown)<br />
<br />
(the only save way would be to close all connections and reopen them after the fork, and even that might not be possible if an extension keeps one open internally)<br />
<br />
for a nice demonstration of the havoc fork can create, try the below script.<br />
it opens a mysql connection, then forks, and runs queries from both parent and child,<br />
verifying that it receives the correct result.<br />
run it (on the cli preferably) a few times, and you will find various possible<br />
results:<br />
- very often is just hangs and doesn't output anything anymore<br />
- also very often, the server closes the connection, probably because it<br />
&nbsp; receives interleaved requests it can't process.<br />
- sometimes one process gets the result of the OTHER processes'<br />
&nbsp; query! (because both send their queries down the same socket,<br />
&nbsp; and it's pure luck who gets the reply)<br />
<br />
<span class="default">&lt;?php<br />
mysql_connect</span><span class="keyword">(</span><span class="comment">/* enter a working server here maybe? */</span><span class="keyword">);<br />
</span><span class="default">$f</span><span class="keyword">=</span><span class="default">pcntl_fork</span><span class="keyword">();<br />
while(</span><span class="default">true</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">,</span><span class="default">10</span><span class="keyword">)/</span><span class="default">100</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$r</span><span class="keyword">=</span><span class="default">mysql_query</span><span class="keyword">(</span><span class="string">"select </span><span class="default">$f</span><span class="string">;"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if(!</span><span class="default">$r</span><span class="keyword">)die(</span><span class="default">$f</span><span class="keyword">.</span><span class="string">": "</span><span class="keyword">.</span><span class="default">mysql_error</span><span class="keyword">().</span><span class="string">"\n"</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; list(</span><span class="default">$x</span><span class="keyword">)=</span><span class="default">mysql_fetch_array</span><span class="keyword">(</span><span class="default">$r</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; echo (</span><span class="default">$f</span><span class="keyword">)?</span><span class="string">"."</span><span class="keyword">:</span><span class="string">"-"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$x</span><span class="keyword">!=</span><span class="default">$f</span><span class="keyword">) echo (</span><span class="default">$f</span><span class="keyword">.</span><span class="string">": fail: </span><span class="default">$x</span><span class="string">!=</span><span class="default">$f</span><span class="string">\n "</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98844""></a>
  <div class="note">
   <strong class="user">iulian</strong>
   <a href="#98844" class="date">10-Jul-2010 08:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When using fork to run multiple children processes on a single job queue using mysql, I used mysql_affected_rows() to prevent collisions between workers:<br />
<br />
First I find a "free" job:<br />
SELECT job_id FROM queue WHERE status="free"<br />
<br />
Then I update the queue:<br />
UPDATE queue SET worker_id={$worker_id} WHERE job_id={$job_id}<br />
<br />
Then I see if the row was changed<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(</span><span class="default">mysql_affected_rows</span><span class="keyword">() == </span><span class="default">0</span><span class="keyword">)<br />
{<br />
</span><span class="comment">//the row hasn't changed, so it must mean that another worker has claimed the job, so I go back to the "find a free job" query<br />
</span><span class="keyword">}<br />
else<br />
{<br />
</span><span class="comment">//do the job<br />
</span><span class="keyword">}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98711""></a>
  <div class="note">
   <strong class="user">duerra at yahoo dot com</strong>
   <a href="#98711" class="date">02-Jul-2010 04:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Using pcntl_fork() can be a little tricky in some situations.&nbsp; For fast jobs, a child can finish processing before the parent process has executed some code related to the launching of the process.&nbsp; The parent can receive a signal before it's ready to handle the child process' status.&nbsp; To handle this scenario, I add an id to a "queue" of processes in the signal handler that need to be cleaned up if the parent process is not yet ready to handle them.&nbsp; <br />
<br />
I am including a stripped down version of a job daemon that should get a person on the right track. <br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">declare(</span><span class="default">ticks</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">);<br />
</span><span class="comment">//A very basic job daemon that you can extend to your needs. <br />
</span><span class="keyword">class </span><span class="default">JobDaemon</span><span class="keyword">{<br />
<br />
&nbsp;&nbsp;&nbsp; public </span><span class="default">$maxProcesses </span><span class="keyword">= </span><span class="default">25</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$jobsStarted </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$currentJobs </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$signalQueue</span><span class="keyword">=array();&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; protected </span><span class="default">$parentPID</span><span class="keyword">;<br />
&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; public function </span><span class="default">__construct</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"constructed \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">parentPID </span><span class="keyword">= </span><span class="default">getmypid</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">pcntl_signal</span><span class="keyword">(</span><span class="default">SIGCHLD</span><span class="keyword">, array(</span><span class="default">$this</span><span class="keyword">, </span><span class="string">"childSignalHandler"</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp;&nbsp; * Run the Daemon<br />
&nbsp;&nbsp;&nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">public function </span><span class="default">run</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Running \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">&lt;</span><span class="default">10000</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$jobID </span><span class="keyword">= </span><span class="default">rand</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">,</span><span class="default">10000000000000</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; while(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentJobs</span><span class="keyword">) &gt;= </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">maxProcesses</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo </span><span class="string">"Maximum children allowed, waiting...\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$launched </span><span class="keyword">= </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">launchJob</span><span class="keyword">(</span><span class="default">$jobID</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Wait for child processes to finish before exiting here<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">while(</span><span class="default">count</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentJobs</span><span class="keyword">)){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"Waiting for current jobs to finish... \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp;&nbsp; * Launch a job from the job queue<br />
&nbsp;&nbsp;&nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">protected function </span><span class="default">launchJob</span><span class="keyword">(</span><span class="default">$jobID</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Problem launching the job<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">error_log</span><span class="keyword">(</span><span class="string">'Could not launch new job, exiting'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if (</span><span class="default">$pid</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Parent process<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // Sometimes you can receive a signal to the childSignalHandler function before this code executes if<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // the child script executes quickly enough!<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentJobs</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">] = </span><span class="default">$jobID</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// In the event that a signal for this pid was caught before we get here, it will be in our signalQueue array<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // So let's go ahead and process it now as if we'd just received the signal<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(isset(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">signalQueue</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">])){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"found </span><span class="default">$pid</span><span class="string"> in the signal queue, processing it now \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">childSignalHandler</span><span class="keyword">(</span><span class="default">SIGCHLD</span><span class="keyword">, </span><span class="default">$pid</span><span class="keyword">, </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">signalQueue</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; unset(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">signalQueue</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else{<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Forked child, do your deeds....<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$exitStatus </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="comment">//Error code if you need to or whatever<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">echo </span><span class="string">"Doing something fun in pid "</span><span class="keyword">.</span><span class="default">getmypid</span><span class="keyword">().</span><span class="string">"\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exit(</span><span class="default">$exitStatus</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; public function </span><span class="default">childSignalHandler</span><span class="keyword">(</span><span class="default">$signo</span><span class="keyword">, </span><span class="default">$pid</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">, </span><span class="default">$status</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//If no pid is provided, that means we're getting the signal from the system.&nbsp; Let's figure out<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; //which child process ended<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if(!</span><span class="default">$pid</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_waitpid</span><span class="keyword">(-</span><span class="default">1</span><span class="keyword">, </span><span class="default">$status</span><span class="keyword">, </span><span class="default">WNOHANG</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Make sure we get all of the exited children<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">while(</span><span class="default">$pid </span><span class="keyword">&gt; </span><span class="default">0</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$pid </span><span class="keyword">&amp;&amp; isset(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentJobs</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">])){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$exitCode </span><span class="keyword">= </span><span class="default">pcntl_wexitstatus</span><span class="keyword">(</span><span class="default">$status</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$exitCode </span><span class="keyword">!= </span><span class="default">0</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo </span><span class="string">"</span><span class="default">$pid</span><span class="string"> exited with status "</span><span class="keyword">.</span><span class="default">$exitCode</span><span class="keyword">.</span><span class="string">"\n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; unset(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">currentJobs</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if(</span><span class="default">$pid</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Oh no, our job has finished before this parent process could even note that it had been launched!<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //Let's make note of it and handle it when the parent process is ready for it<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">echo </span><span class="string">"..... Adding </span><span class="default">$pid</span><span class="string"> to the signal queue ..... \n"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">signalQueue</span><span class="keyword">[</span><span class="default">$pid</span><span class="keyword">] = </span><span class="default">$status</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_waitpid</span><span class="keyword">(-</span><span class="default">1</span><span class="keyword">, </span><span class="default">$status</span><span class="keyword">, </span><span class="default">WNOHANG</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94708""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#94708" class="date">19-Nov-2009 07:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
With regards to the database connection, one could deal with this using kill 9 or a sleep, the real problem is if two threads make a database query at the same time, PHP starts having random database errors that are not necessarily clear as to what the problem is.<br />
<br />
You should create a separate link per thread.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="94338""></a>
  <div class="note">
   <strong class="user">Tony</strong>
   <a href="#94338" class="date">29-Oct-2009 12:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to execute some code after your php page has been returned to the user. Try something like this -<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">index</span><span class="keyword">()<br />
{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function </span><span class="default">shutdown</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">posix_kill</span><span class="keyword">(</span><span class="default">posix_getpid</span><span class="keyword">(), </span><span class="default">SIGHUP</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Do some initial processing<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">echo(</span><span class="string">"Hello World"</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Switch over to daemon mode.<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">())<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return;&nbsp; &nbsp;&nbsp; </span><span class="comment">// Parent<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">ob_end_clean</span><span class="keyword">(); </span><span class="comment">// Discard the output buffer and close<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">STDIN</span><span class="keyword">);&nbsp; </span><span class="comment">// Close all of the standard<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">STDOUT</span><span class="keyword">); </span><span class="comment">// file descriptors as we<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">STDERR</span><span class="keyword">); </span><span class="comment">// are running as a daemon.<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">register_shutdown_function</span><span class="keyword">(</span><span class="string">'shutdown'</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">posix_setsid</span><span class="keyword">() &lt; </span><span class="default">0</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">())<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return;&nbsp; &nbsp;&nbsp; </span><span class="comment">// Parent<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // Now running as a daemon. This process will even survive<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; // an apachectl stop.<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">sleep</span><span class="keyword">(</span><span class="default">10</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$fp </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="string">"/tmp/sdf123"</span><span class="keyword">, </span><span class="string">"w"</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fprintf</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">, </span><span class="string">"PID = %s\n"</span><span class="keyword">, </span><span class="default">posix_getpid</span><span class="keyword">());<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$fp</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93466""></a>
  <div class="note">
   <strong class="user">php at mx dot magic-lamp dot org</strong>
   <a href="#93466" class="date">11-Sep-2009 10:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A workaround for the MySQL "Lost Connection during query", or any other object related problems caused by children exiting is to force the child to kill -9 itself, thus avoiding any cleanup.&nbsp; Sure - it's not too elegant, but it does work.<br />
<br />
<span class="default">&lt;?php<br />
$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
if ( </span><span class="default">$pid </span><span class="keyword">== </span><span class="default">0 </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// This is the child process.&nbsp; Do something here.<br />
&nbsp;&nbsp;&nbsp; // Instead of calling exit(), we use posix_kill()<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">posix_kill</span><span class="keyword">(</span><span class="default">getmypid</span><span class="keyword">(),</span><span class="default">9</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Watch out that you don't spawn too many processes though as this creates its own problems.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93089""></a>
  <div class="note">
   <strong class="user">drrota at us dot ibm dot com</strong>
   <a href="#93089" class="date">22-Aug-2009 12:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was able to get around the problem of not being able to run fork and exec from Apache php.<br />
<br />
I got around this by calling the system 'at' command on Linux.&nbsp; "at run something now".&nbsp; and you have to set atrun -s in a crontab file (to run every minute) to insure that things get kicked off quickly even if there is a heavy load on the machine.<br />
<br />
If you're the only one running batch jobs on a linux box, this works.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79439""></a>
  <div class="note">
   <strong class="user">kentmussell at mindspring dot com</strong>
   <a href="#79439" class="date">27-Nov-2007 07:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is an interesting script I wrote.&nbsp; It demonstrates how pcntl_fork() might be used as a useful tool.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/* This script serves the purpose of testing an algorithm designed to:<br />
a.) Compare password hashes, or try passwords efficiently where the time to try a single password is 10 seconds.&nbsp; <br />
b.) Spawn threads to work simultaneously on comparing hashes.<br />
c.) Restrict the number of threads open at a time.&nbsp; <br />
*/<br />
//checks for divisibility<br />
</span><span class="keyword">function </span><span class="default">divby</span><span class="keyword">(</span><span class="default">$num</span><span class="keyword">,</span><span class="default">$den</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$result </span><span class="keyword">= </span><span class="default">$num</span><span class="keyword">/</span><span class="default">$den</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$result2 </span><span class="keyword">= </span><span class="default">floor</span><span class="keyword">(</span><span class="default">$result</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$result </span><span class="keyword">== </span><span class="default">$result2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="comment">//checks whether a period of time fits into 2 second intervals occuring every 10 seconds.&nbsp; Interval may increase or decrease in size to use more or less memory.&nbsp; <br />
</span><span class="keyword">function </span><span class="default">goodTime</span><span class="keyword">(</span><span class="default">$elapsed</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$num </span><span class="keyword">= </span><span class="default">floor</span><span class="keyword">(</span><span class="default">$elapsed</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$num </span><span class="keyword">= </span><span class="default">$num</span><span class="keyword">/</span><span class="default">12</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$min </span><span class="keyword">= </span><span class="default">floor</span><span class="keyword">(</span><span class="default">$num</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$min </span><span class="keyword">= </span><span class="default">12</span><span class="keyword">*</span><span class="default">$min</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$max </span><span class="keyword">= </span><span class="default">$min</span><span class="keyword">+</span><span class="default">2</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$elapsed </span><span class="keyword">&gt;= </span><span class="default">$min </span><span class="keyword">&amp;&amp; </span><span class="default">$elapsed </span><span class="keyword">&lt;= </span><span class="default">$max</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="string">"yes"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="string">"no"</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
</span><span class="default">$x </span><span class="keyword">= </span><span class="default">30</span><span class="keyword">; </span><span class="comment">//number of child threads<br />
</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="comment">//needed to create first thread<br />
</span><span class="default">$xpass </span><span class="keyword">= </span><span class="default">md5</span><span class="keyword">(</span><span class="string">'29'</span><span class="keyword">);</span><span class="comment">//hash to crack<br />
</span><span class="default">$time </span><span class="keyword">= </span><span class="default">time</span><span class="keyword">();<br />
</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
</span><span class="comment">//parent spawns $x children.<br />
</span><span class="keyword">while (</span><span class="default">$i </span><span class="keyword">&lt;= </span><span class="default">$x</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">file_exists</span><span class="keyword">(</span><span class="string">'childcall.txt'</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">unlink</span><span class="keyword">(</span><span class="string">'childcall.txt'</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exit;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$elapsed </span><span class="keyword">= </span><span class="default">time</span><span class="keyword">()-</span><span class="default">$time</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//children are only spawned during intervals occuring every 10 seconds leaving enough time for the previous batch of children to finish their task.<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">goodTime</span><span class="keyword">(</span><span class="default">$elapsed</span><span class="keyword">)==</span><span class="string">"yes"</span><span class="keyword">) {&nbsp; &nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Are we the parent?<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$pid </span><span class="keyword">!= </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//Give birth to a child.&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//create a record of how many children have been birthed.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$time2 </span><span class="keyword">= </span><span class="default">$elapsed</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//escort children out of the loop.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">$pid </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">$x</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i</span><span class="keyword">++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="comment">//parent waits for children to finish playing. <br />
</span><span class="keyword">if (</span><span class="default">$pid</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$value </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; while (!</span><span class="default">file_exists</span><span class="keyword">(</span><span class="string">'childcall.txt'</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//wait<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">}<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">unlink</span><span class="keyword">(</span><span class="string">'childcall.txt'</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$time </span><span class="keyword">= </span><span class="default">time</span><span class="keyword">()+</span><span class="default">2</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; while (</span><span class="default">time</span><span class="keyword">()&lt;</span><span class="default">$time</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">//wait<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">}<br />
&nbsp;&nbsp;&nbsp; exit;<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="comment">//children take turns finding the highest array value, and changing it to 0<br />
</span><span class="default">rsort</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
</span><span class="default">$value </span><span class="keyword">= </span><span class="default">max</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$value</span><span class="keyword">] = </span><span class="default">0</span><span class="keyword">;<br />
</span><span class="default">$time </span><span class="keyword">= </span><span class="default">time</span><span class="keyword">()+</span><span class="default">10</span><span class="keyword">;<br />
</span><span class="comment">//simulate delay<br />
</span><span class="keyword">while (</span><span class="default">time</span><span class="keyword">() &lt; </span><span class="default">$time</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//wait<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
</span><span class="comment">//compare the high array value hash to the hash we are looking to crack.<br />
</span><span class="keyword">if (</span><span class="default">md5</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">) == </span><span class="default">$xpass</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"</span><span class="default">$value</span><span class="string"> \n"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
if (</span><span class="default">$value </span><span class="keyword">== </span><span class="default">$x </span><span class="keyword">|| </span><span class="default">md5</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">) == </span><span class="default">$xpass</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$file </span><span class="keyword">= </span><span class="string">"childcall.txt"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$content </span><span class="keyword">= </span><span class="default">true</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">file_put_contents</span><span class="keyword">(</span><span class="default">$file</span><span class="keyword">,</span><span class="default">$contents</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70721""></a>
  <div class="note">
   <strong class="user">amatsak at chestnutsoftware dot com</strong>
   <a href="#70721" class="date">25-Oct-2006 11:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The reason for the MySQL "Lost Connection during query" issue when forking is the fact that the child process inherits the parent's database connection. When the child exits, the connection is closed. If the parent is performing a query at this very moment, it is doing it on an already closed connection, hence the error.<br />
<br />
An easy way to avoid this is to create a new database connection in parent immediately after forking. Don't forget to force a new connection by passing true in the 4th argument of mysql_connect():<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// Create the MySQL connection<br />
</span><span class="default">$db </span><span class="keyword">= </span><span class="default">mysql_connect</span><span class="keyword">(</span><span class="default">$server</span><span class="keyword">, </span><span class="default">$username</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">);<br />
<br />
</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
if ( </span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1 </span><span class="keyword">) {&nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Fork failed&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">exit(</span><span class="default">1</span><span class="keyword">);<br />
} else if ( </span><span class="default">$pid </span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// We are the parent<br />
&nbsp;&nbsp;&nbsp; // Can no longer use $db because it will be closed by the child<br />
&nbsp;&nbsp;&nbsp; // Instead, make a new MySQL connection for ourselves to work with<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$db </span><span class="keyword">= </span><span class="default">mysql_connect</span><span class="keyword">(</span><span class="default">$server</span><span class="keyword">, </span><span class="default">$username</span><span class="keyword">, </span><span class="default">$password</span><span class="keyword">, </span><span class="default">true</span><span class="keyword">);<br />
} else {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// We are the child<br />
&nbsp;&nbsp;&nbsp; // Do something with the inherited connection here<br />
&nbsp;&nbsp;&nbsp; // It will get closed upon exit<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">exit(</span><span class="default">0</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
This way, the child will inherit the old connection, will work on it and will close upon exit. The parent won't care, because it will open a new connection for itself immediately after forking.<br />
<br />
Hope this helps.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69198""></a>
  <div class="note">
   <strong class="user">xuecan at google dot com</strong>
   <a href="#69198" class="date">26-Aug-2006 06:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I think this simple code can help understand how fork works:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">echo </span><span class="string">"posix_getpid()="</span><span class="keyword">.</span><span class="default">posix_getpid</span><span class="keyword">().</span><span class="string">", posix_getppid()="</span><span class="keyword">.</span><span class="default">posix_getppid</span><span class="keyword">().</span><span class="string">"\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">$pid </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
if (</span><span class="default">$pid </span><span class="keyword">== -</span><span class="default">1</span><span class="keyword">) die(</span><span class="string">"could not fork"</span><span class="keyword">);<br />
if (</span><span class="default">$pid</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"pid="</span><span class="keyword">.</span><span class="default">$pid</span><span class="keyword">.</span><span class="string">", posix_getpid()="</span><span class="keyword">.</span><span class="default">posix_getpid</span><span class="keyword">().</span><span class="string">", posix_getppid()="</span><span class="keyword">.</span><span class="default">posix_getppid</span><span class="keyword">().</span><span class="string">"\n"</span><span class="keyword">;<br />
} else {<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="string">"pid="</span><span class="keyword">.</span><span class="default">$pid</span><span class="keyword">.</span><span class="string">", posix_getpid()="</span><span class="keyword">.</span><span class="default">posix_getpid</span><span class="keyword">().</span><span class="string">", posix_getppid()="</span><span class="keyword">.</span><span class="default">posix_getppid</span><span class="keyword">().</span><span class="string">"\n"</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49949""></a>
  <div class="note">
   <strong class="user">arnold at helderhosting dot nl</strong>
   <a href="#49949" class="date">13-Feb-2005 04:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is not possible to use the function 'pcntl_fork' when PHP is used as Apache module. You can only use pcntl_fork in CGI mode or from command-line.<br />
<br />
Using this function will result in: 'Fatal error: Call to undefined function: pcntl_fork()'</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="25492""></a>
  <div class="note">
   <strong class="user">ben at gelbnet dot com</strong>
   <a href="#25492" class="date">26-Sep-2002 12:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I was writing a shell script to get input from a user, however, I needed my script to time out after a certain number of seconds if the user didn't enter enough data. The code below descibes the method I used. It's a little hairy but it does work.<br />
<br />
-Ben<br />
<br />
#!/home/ben/php/bin/php -q<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//GLOBALS<br />
</span><span class="default">$RETURN_CHAR </span><span class="keyword">= </span><span class="string">"\n"</span><span class="keyword">;<br />
</span><span class="default">$TIMEOUT </span><span class="keyword">= </span><span class="default">5</span><span class="keyword">; </span><span class="comment">//number of seconds to timeout on input<br />
</span><span class="default">$PID </span><span class="keyword">= </span><span class="default">getmypid</span><span class="keyword">();<br />
</span><span class="default">$CHILD_PID </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
<br />
</span><span class="comment">//Make sure program execution doesn't time out<br />
</span><span class="default">set_time_limit</span><span class="keyword">(</span><span class="default">0</span><span class="keyword">);<br />
<br />
function </span><span class="default">set_timeout</span><span class="keyword">() {<br />
global </span><span class="default">$PID</span><span class="keyword">;<br />
global </span><span class="default">$CHILD_PID</span><span class="keyword">;<br />
global </span><span class="default">$TIMEOUT</span><span class="keyword">;<br />
<br />
</span><span class="default">$CHILD_PID </span><span class="keyword">= </span><span class="default">pcntl_fork</span><span class="keyword">();<br />
if(</span><span class="default">$CHILD_PID </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) {<br />
</span><span class="default">sleep</span><span class="keyword">(</span><span class="default">$TIMEOUT</span><span class="keyword">);<br />
</span><span class="default">posix_kill</span><span class="keyword">(</span><span class="default">$PID</span><span class="keyword">, </span><span class="default">SIGTERM</span><span class="keyword">);<br />
exit;<br />
}<br />
}<br />
<br />
function </span><span class="default">clear_timeout</span><span class="keyword">() {<br />
global </span><span class="default">$CHILD_PID</span><span class="keyword">;<br />
</span><span class="default">posix_kill</span><span class="keyword">(</span><span class="default">$CHILD_PID</span><span class="keyword">, </span><span class="default">SIGTERM</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="comment">// read_data()<br />
// gets a line of data from STDIN and returns it<br />
</span><span class="keyword">function </span><span class="default">read_data</span><span class="keyword">() {<br />
<br />
</span><span class="default">$in </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="string">"php://stdin"</span><span class="keyword">, </span><span class="string">"r"</span><span class="keyword">);<br />
</span><span class="default">set_timeout</span><span class="keyword">();<br />
</span><span class="default">$in_string </span><span class="keyword">= </span><span class="default">fgets</span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">, </span><span class="default">255</span><span class="keyword">);<br />
</span><span class="default">clear_timeout</span><span class="keyword">();<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$in</span><span class="keyword">);<br />
return </span><span class="default">$in_string</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">// write_data($outstring)<br />
// writes data to STDOUT<br />
</span><span class="keyword">function </span><span class="default">write_data</span><span class="keyword">(</span><span class="default">$outstring</span><span class="keyword">) {<br />
</span><span class="default">$out </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="string">"php://stdout"</span><span class="keyword">, </span><span class="string">"w"</span><span class="keyword">);<br />
</span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$out</span><span class="keyword">, </span><span class="default">$outstring</span><span class="keyword">);<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$out</span><span class="keyword">);<br />
}<br />
<br />
while(</span><span class="default">1</span><span class="keyword">) {<br />
</span><span class="default">write_data</span><span class="keyword">(</span><span class="string">"say something-&gt;"</span><span class="keyword">);<br />
</span><span class="default">$input </span><span class="keyword">= </span><span class="default">read_data</span><span class="keyword">();<br />
</span><span class="default">write_data</span><span class="keyword">(</span><span class="default">$RETURN_CHAR</span><span class="keyword">.</span><span class="default">$input</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.pcntl-exec.html">pcntl_exec</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.pcntl-get-last-error.html">pcntl_get_last_error</a></div>
 <div class="up"><a href="ref.pcntl.html">PCNTL 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
