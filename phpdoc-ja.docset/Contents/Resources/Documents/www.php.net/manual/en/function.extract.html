<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>配列からシンボルテーブルに変数をインポートする</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.end.html">end</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.in-array.html">in_array</a></div>
 <div class="up"><a href="ref.array.html">配列 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.extract" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">extract</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">extract</span> &mdash; <span class="dc-title">配列からシンボルテーブルに変数をインポートする</span></p>

 </div>
 <div class="refsect1 description" id="refsect1-function.extract-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">int</span> <span class="methodname"><strong>extract</strong></span>
    ( <span class="methodparam"><span class="type">array</span> <code class="parameter reference">&$array</code></span>
   [, <span class="methodparam"><span class="type">int</span> <code class="parameter">$flags</code><span class="initializer"> = EXTR_OVERWRITE</span></span>
   [, <span class="methodparam"><span class="type">string</span> <code class="parameter">$prefix</code><span class="initializer"> = <strong><code>NULL</code></strong></span></span>
  ]] )</div>

  <p class="para rdfs-comment">
   配列からシンボルテーブルに変数をインポートします。
  </p>
  <p class="para">
   各キーについて変数名として有効であるかどうか、
   そして、シンボルテーブルの既存の変数と衝突しないかどうかを確認します。
  </p>
 </div>

 <div class="refsect1 parameters" id="refsect1-function.extract-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><em><code class="parameter">array</code></em></span>
     <dd>

      <p class="para">
       この関数は連想配列 <em><code class="parameter">var_array</code></em>
       を引数とし、そのキーを変数名、値を変数の値として処理します。
       各キー/値の組に関して、<em><code class="parameter">flags</code></em> および
       <em><code class="parameter">prefix</code></em> パラメータに基づき、
       現在のシンボルテーブルに変数を一つ作成します。
      </p>
      <p class="para">
       連想配列を使用する必要があります。<strong><code>EXTR_PREFIX_ALL</code></strong>
       または <strong><code>EXTR_PREFIX_INVALID</code></strong> を使用しない限り、
       数値添字の配列には結果は出力されません。
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><em><code class="parameter">flags</code></em></span>
     <dd>

      <p class="para">
       無効または数値キーおよび衝突に関する対処法は、
       <em><code class="parameter">flags</code></em> で定義されます。
       これは以下の値のどれかとなります。
       <dl>

        <dt>

         <span class="term"><strong><code>EXTR_OVERWRITE</code></strong></span>
         <dd>

          <span class="simpara">
           衝突があった場合、存在する変数が上書きされます。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_SKIP</code></strong></span>
         <dd>

          <span class="simpara">
           衝突があった場合、存在する変数は上書きされません。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_PREFIX_SAME</code></strong></span>
         <dd>

          <span class="simpara">
           衝突があった場合、<em><code class="parameter">prefix</code></em>
           を前につけた新しい変数となります。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_PREFIX_ALL</code></strong></span>
         <dd>

          <span class="simpara">
           全ての変数の前に <em><code class="parameter">prefix</code></em> を付けます。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_PREFIX_INVALID</code></strong></span>
         <dd>

          <span class="simpara">
           無効または数値の変数名のみに接頭辞
           <em><code class="parameter">prefix</code></em> を付けます。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_IF_EXISTS</code></strong></span>
         <dd>

          <span class="simpara">
           現在のシンボルテーブルに既に存在する場合にのみ上書きします。
           例えば <var class="varname"><var class="varname"><a href="reserved.variables.request.html" class="classname">$_REQUEST</a></var></var> 以外にあなたが定義した変数のみを展開し
           有効な変数としたいような場合に有用です。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_PREFIX_IF_EXISTS</code></strong></span>
         <dd>

          <span class="simpara">
           同じ変数だが接頭辞をつけていないバージョンの変数が
           現在のシンボルテーブルに存在する場合にのみ
           変数を生成します。
          </span>
         </dd>

        </dt>

        <dt>

         <span class="term"><strong><code>EXTR_REFS</code></strong></span>
         <dd>

          <span class="simpara">
           変数を参照として展開します。
           これはインポート済みの変数が、
           <em><code class="parameter">array</code></em>
           パラメータの値に常に参照付けられることを意味します。
           このフラグを単独で使用するか、
           あるいは<em><code class="parameter">flags</code></em>と和算することにより、
           他のフラグとそれを組み合わせることができます。
          </span>
         </dd>

        </dt>

       </dl>

      </p>
      <p class="para">
       <em><code class="parameter">flags</code></em> が指定されない場合、
       <strong><code>EXTR_OVERWRITE</code></strong> とみなされます。
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><em><code class="parameter">prefix</code></em></span>
     <dd>

      <p class="para">
       <em><code class="parameter">prefix</code></em> は、
       <em><code class="parameter">flags</code></em> が
       <strong><code>EXTR_PREFIX_SAME</code></strong>、<strong><code>EXTR_PREFIX_ALL</code></strong>、
       <strong><code>EXTR_PREFIX_INVALID</code></strong> あるいは
       <strong><code>EXTR_PREFIX_IF_EXISTS</code></strong> の場合にのみ必要であることに注意してください。
       接頭辞を付けた変数名が有効な変数名でない場合、
       この変数はシンボルテーブルにインポートされません。接頭辞は、
       アンダースコア文字で配列のキーから自動的に分割されます。
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>

 <div class="refsect1 returnvalues" id="refsect1-function.extract-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   シンボルテーブルにインポートした変数の数を返します。
  </p>
 </div>

 <div class="refsect1 changelog" id="refsect1-function.extract-changelog">
  <h3 class="title">変更履歴</h3>
  <p class="para">
   <table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>バージョン</th>
       <th>説明</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>4.3.0</td>
       <td>
        <strong><code>EXTR_REFS</code></strong> が追加されました。
       </td>
      </tr>

      <tr>
       <td>4.2.0</td>
       <td>
        <strong><code>EXTR_IF_EXISTS</code></strong> と <strong><code>EXTR_PREFIX_IF_EXISTS</code></strong>
        が追加されました。
       </td>
      </tr>

      <tr>
       <td>4.0.5</td>
       <td>
        この関数は、取り込んだ変数の数を返すようになりました。
        <strong><code>EXTR_PREFIX_INVALID</code></strong> が追加されました。
        <strong><code>EXTR_PREFIX_ALL</code></strong> が数値変数も扱ううようになりました。
       </td>
      </tr>

     </tbody>
    
   </table>

  </p>
 </div>

 <div class="refsect1 examples" id="refsect1-function.extract-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-4985">
    <p><strong>例1  <span class="function"><strong>extract()</strong></span> の例</strong></p>
    <div class="example-contents"><p>
     extract の使用例としては、シンボルテーブルに
      <span class="function"><a href="function.wddx-deserialize.html" class="function">wddx_deserialize()</a></span> から返された連想配列を
    インポートすることが考えられます。
    </p></div>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #FF8000">/*&nbsp;$var_array&nbsp;はwddx_deserializeから返された配列と仮定します&nbsp;*/<br /><br /></span><span style="color: #0000BB">$size&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"large"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$var_array&nbsp;</span><span style="color: #007700">=&nbsp;array(</span><span style="color: #DD0000">"color"&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">"blue"</span><span style="color: #007700">,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #DD0000">"size"&nbsp;&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">"medium"</span><span style="color: #007700">,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #DD0000">"shape"&nbsp;</span><span style="color: #007700">=&gt;&nbsp;</span><span style="color: #DD0000">"sphere"</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">extract</span><span style="color: #007700">(</span><span style="color: #0000BB">$var_array</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">EXTR_PREFIX_SAME</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">"wddx"</span><span style="color: #007700">);<br /><br />echo&nbsp;</span><span style="color: #DD0000">"</span><span style="color: #0000BB">$color</span><span style="color: #DD0000">,&nbsp;</span><span style="color: #0000BB">$size</span><span style="color: #DD0000">,&nbsp;</span><span style="color: #0000BB">$shape</span><span style="color: #DD0000">,&nbsp;</span><span style="color: #0000BB">$wddx_size</span><span style="color: #DD0000">\n"</span><span style="color: #007700">;<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>上の例の出力は以下となります。</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
blue, large, sphere, medium
</pre></div>
    </div>
    <div class="example-contents"><p>
     <strong><code>EXTR_PREFIX_SAME</code></strong> を指定したため、<var class="varname"><var class="varname">$size</var></var>
     は上書きされず、<var class="varname"><var class="varname">$wddx_size</var></var> が作成されます。
     <strong><code>EXTR_SKIP</code></strong> が指定された場合、<var class="varname"><var class="varname">$wddx_size</var></var> は作成されません。
     <strong><code>EXTR_OVERWRITE</code></strong>
     の場合は、<var class="varname"><var class="varname">$size</var></var> の値は &quot;medium&quot; となります。
     <strong><code>EXTR_PREFIX_ALL</code></strong> の場合は新規の変数
     <var class="varname"><var class="varname">$wddx_color</var></var>,
     <var class="varname"><var class="varname">$wddx_size</var></var>, <var class="varname"><var class="varname">$wddx_shape</var></var>
     が作成されます。
    </p></div>
   </div>
  </p>
 </div>

 <div class="refsect1 notes" id="refsect1-function.extract-notes">
  <h3 class="title">注意</h3>
  <div class="warning"><strong class="warning">警告</strong>
   <p class="para">
     <span class="function"><strong>extract()</strong></span> をユーザー入力
    (<var class="varname"><var class="varname"><a href="reserved.variables.get.html" class="classname">$_GET</a></var></var> や <var class="varname"><var class="varname"><a href="reserved.variables.files.html" class="classname">$_FILES</a></var></var> など)
    のような信頼できないデータについて使用しないでください。
    もし行う場合、例えば
    <a href="security.globals.html" class="link">register_globals</a>
    を信頼しているような古いコードを一時的に実行したい場合、
    <strong><code>EXTR_SKIP</code></strong> のような
    <em><code class="parameter">flags</code></em>
    の値が上書きされていないことを確認してください。そして
    <a href="ini.html" class="link"><var class="filename">php.ini</var></a> の
    <a href="ini.core.html#ini.variables-order" class="link">variables_order</a>
    で定義されたものと同じ順で展開すべきであることに留意してください。
   </p>
  </div>
  <blockquote class="note"><p><strong class="note">注意</strong>: 
   <p class="para">
    <a href="security.globals.html" class="link">register_globals</a> が on の状態で
    <var class="varname"><var class="varname"><a href="reserved.variables.files.html" class="classname">$_FILES</a></var></var> に対して
     <span class="function"><strong>extract()</strong></span> を実行して
    <strong><code>EXTR_SKIP</code></strong> を指定すると、
    その結果に驚くことでしょう。
   </p>
   <div class="warning"><strong class="warning">警告</strong>
    <p class="para">
     これは決しておすすめする方法ではなく、
     単にドキュメントとしての完全性を求めてここに書いているだけです。
     <a href="security.globals.html" class="link">register_globals</a>
     を使ったり、<var class="varname"><var class="varname"><a href="reserved.variables.files.html" class="classname">$_FILES</a></var></var> のような信頼できないデータに対して
      <span class="function"><strong>extract()</strong></span> を使ったりすることは非推奨となっています。
     先に説明したようにセキュリティ上のリスクがあるからです。
     もしこの問題に遭遇したならば、
     まずいコーディング作法を少なくともふたつ使っているということになります。
    </p>
   </div>
   <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /><br /></span><span style="color: #FF8000">/*&nbsp;$testfile&nbsp;にはアップロードされたファイルの名前が入っており、<br />&nbsp;&nbsp;&nbsp;register_globals&nbsp;が&nbsp;on&nbsp;であるものとします&nbsp;*/<br /><br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$testfile</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">extract</span><span style="color: #007700">(</span><span style="color: #0000BB">$_FILES</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">EXTR_SKIP</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$testfile</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$testfile</span><span style="color: #007700">[</span><span style="color: #DD0000">'tmp_name'</span><span style="color: #007700">]);<br /><br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
   </div>

   <span class="simpara">
    おそらくこんな結果になることを期待しているでしょう。
   </span>
   <div class="example-contents screen">
<div class="cdata"><pre>
string(14) &quot;/tmp/phpgCCPX8&quot;
array(5) {
  [&quot;name&quot;]=&gt;
  string(10) &quot;somefile.txt&quot;
  [&quot;type&quot;]=&gt;
  string(24) &quot;application/octet-stream&quot;
  [&quot;tmp_name&quot;]=&gt;
  string(14) &quot;/tmp/phpgCCPX8&quot;
  [&quot;error&quot;]=&gt;
  int(0)
  [&quot;size&quot;]=&gt;
  int(4208)
}
string(14) &quot;/tmp/phpgCCPX8&quot;
</pre></div>
   </div>
   <span class="simpara">
    しかし、実際にはこのようになります。
   </span>
   <div class="example-contents screen">
<div class="cdata"><pre>
string(14) &quot;/tmp/phpgCCPX8&quot;
string(14) &quot;/tmp/phpgCCPX8&quot;
string(1) &quot;/&quot;
</pre></div>
   </div>
   <p class="para">
    これは、<a href="security.globals.html" class="link">register_globals</a>
    が on の場合は  <span class="function"><strong>extract()</strong></span>
    がコールされた時点で既にグローバルスコープに
    <var class="varname"><var class="varname">$testfile</var></var> が存在するからです。
    そして <strong><code>EXTR_SKIP</code></strong> が指定されているので、
    <var class="varname"><var class="varname">$testfile</var></var> が
    <strong><code>$_FILES</code></strong> 配列の内容で上書きされることはありません。
    <var class="varname"><var class="varname">$testfile</var></var> はそのまま文字列として残るわけです。
    <a href="language.types.string.html#language.types.string.substr" class="link">
    文字列は配列構文を使ってもアクセスでき</a>、
    非数値の文字列 <em>tmp_name</em> は
    <em>0</em> と解釈されるので、PHP は
    <var class="varname"><var class="varname">$testfile['tmp_name']</var></var> を
    <var class="varname"><var class="varname">$testfile[0]</var></var> とみなします。
   </p>
  </p></blockquote>
 </div>

 <div class="refsect1 seealso" id="refsect1-function.extract-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.compact.html" class="function" rel="rdfs-seeAlso">compact()</a> - 変数名とその値から配列を作成する</span></li>
    <li class="member"> <span class="function"><a href="function.list.html" class="function" rel="rdfs-seeAlso">list()</a> - 配列と同様の形式で、複数の変数への代入を行う</span></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="112165""></a>
  <div class="note">
   <strong class="user">FredLawl</strong>
   <a href="#112165" class="date">13-May-2013 11:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It is possible to use this as a way to create public attributes for a class.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">class </span><span class="default">Foo </span><span class="keyword">{<br />
<br />
&nbsp; public function </span><span class="default">__construct </span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">) {<br />
<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">extract</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">, </span><span class="default">EXTR_REFS</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$array </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$value</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">$key </span><span class="keyword">= $</span><span class="default">$key</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Do: $this-&gt;key = $key; if $key is not a string.<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">}<br />
<br />
&nbsp; }<br />
<br />
}<br />
<br />
</span><span class="default">$array </span><span class="keyword">= array(<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'valueOne'&nbsp; &nbsp; &nbsp; </span><span class="keyword">=&gt; </span><span class="string">'Test Value 1'</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'valueTwo'&nbsp; &nbsp; &nbsp; </span><span class="keyword">=&gt; </span><span class="string">'Test Value 2'</span><span class="keyword">,<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">'valueThree'&nbsp; &nbsp; </span><span class="keyword">=&gt; </span><span class="string">'Test Value 3'<br />
</span><span class="keyword">);<br />
<br />
</span><span class="default">$foo </span><span class="keyword">= new </span><span class="default">Foo</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Works<br />
</span><span class="keyword">echo </span><span class="default">$foo</span><span class="keyword">-&gt;</span><span class="default">valueOne</span><span class="keyword">; </span><span class="comment">// Test Value 1<br />
</span><span class="keyword">echo </span><span class="default">$foo</span><span class="keyword">-&gt;</span><span class="default">valueTwo</span><span class="keyword">; </span><span class="comment">// Test Value 2<br />
<br />
// Does not work!<br />
</span><span class="keyword">echo </span><span class="default">$foo</span><span class="keyword">::</span><span class="default">$valueOne</span><span class="keyword">; </span><span class="comment">// Fatal error:&nbsp; Access to undeclared static property: Test::$valueOne<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="112068""></a>
  <div class="note">
   <strong class="user">dotslash.lu at gmail.com</strong>
   <a href="#112068" class="date">29-Apr-2013 09:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can't extract a numeric indexed array(e.g. non-assoc array).<br />
<span class="default">&lt;?php<br />
$a </span><span class="keyword">= array(<br />
&nbsp; </span><span class="default">1</span><span class="keyword">,<br />
&nbsp; </span><span class="default">2<br />
</span><span class="keyword">);<br />
</span><span class="default">extract</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(${</span><span class="default">1</span><span class="keyword">});<br />
</span><span class="default">?&gt;<br />
</span><br />
result:<br />
PHP Notice:&nbsp; Undefined variable: 1 in /Users/Lutashi/t.php on line 7<br />
<br />
Notice: Undefined variable: 1 in /Users/Lutashi/t.php on line 7<br />
NULL</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="106374""></a>
  <div class="note">
   <strong class="user">Robc</strong>
   <a href="#106374" class="date">01-Nov-2011 03:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When extracting from a row after a database query using for example:<br />
<br />
$row = mysql_fetch_array($result, MYSQL_ASSOC)<br />
extract($row);<br />
<br />
I find that the resultant variables may not match the variable type in the database.&nbsp; In particular I have found integers in the database may gettype() to string on the extracted variable.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98446""></a>
  <div class="note">
   <strong class="user">Rodrigo</strong>
   <a href="#98446" class="date">16-Jun-2010 06:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here's a way to use extract in $_FILES arrays without using register_gloabals on.<br />
<br />
I started to use extract a few weeks ago, and my codes hasn't been so clean since then. The use of the arrays $_POST and $_GET is ok, but one missed doublequote causes a lot of trouble. <br />
<br />
Besides I teach PHP in a school, and this function has made my examples easier.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(isset(</span><span class="default">$_FILES</span><span class="keyword">[</span><span class="string">"file"</span><span class="keyword">])){<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">extract</span><span class="keyword">(</span><span class="default">$_FILES</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">extract</span><span class="keyword">(</span><span class="default">$file</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$name</span><span class="keyword">.</span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$tmp_name</span><span class="keyword">.</span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$size</span><span class="keyword">.</span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "<a href="http://www.w3.org/TR/html4/loose.dtd" rel="nofollow" target="_blank">http://www.w3.org/TR/html4/loose.dtd</a>"&gt;<br />
&lt;html&gt;<br />
&lt;head&gt;<br />
&lt;title&gt;Documento sin t&amp;iacute;tulo&lt;/title&gt;<br />
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;<br />
&lt;/head&gt;<br />
<br />
&lt;body&gt;<br />
&lt;form action="" method="post" enctype="multipart/form-data" name="form1"&gt;<br />
&nbsp; &lt;p&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;input type="file" name="file"&gt;<br />
&lt;/p&gt;<br />
&nbsp; &lt;p&gt;<br />
&nbsp;&nbsp;&nbsp; &lt;input type="submit" name="Submit" value="Enviar"&gt;<br />
&lt;/p&gt;<br />
&lt;/form&gt;<br />
&lt;/body&gt;<br />
&lt;/html&gt;<br />
<br />
Hope this can help anyone.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="96370""></a>
  <div class="note">
   <strong class="user">auto493097 at hushmail dot com</strong>
   <a href="#96370" class="date">23-Feb-2010 07:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I use XDebug with NetbeansIDE to for analyzing and developing PHP Code. When debugging an extract statement no new variables appeared in the variable's list. Although all variables created by extract could be examined by explicit watch items and single variables appeared as soon as an PHP script makes use of them I am not sure weather it is a wrong configuration, a feature or a bug in XDebug.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93113""></a>
  <div class="note">
   <strong class="user">danbettles at yahoo dot co dot uk</strong>
   <a href="#93113" class="date">24-Aug-2009 01:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
When using EXTR_PREFIX_ALL - and probably all the other EXTR_PREFIX_* constants - and a numerically-indexed array, extract() will add an underscore ("_") between the prefix and the index.<br />
<br />
<span class="default">&lt;?php<br />
<br />
extract</span><span class="keyword">(array(</span><span class="string">'foo'</span><span class="keyword">, </span><span class="string">'bar'</span><span class="keyword">), </span><span class="default">EXTR_PREFIX_ALL</span><span class="keyword">, </span><span class="string">'var'</span><span class="keyword">);<br />
<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">get_defined_vars</span><span class="keyword">());&nbsp; </span><span class="comment">// Reveals $var_0 = 'foo' and $var_1 = 'bar'<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81862""></a>
  <div class="note">
   <strong class="user">benjaminATwebbutvecklarnaDOTse</strong>
   <a href="#81862" class="date">17-Mar-2008 04:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In the meantime, I'm using this:<br />
<br />
// extract alternative<br />
# extracts variables where new value is above the threshold or if old value is on or below the threshold (or var is not defined)<br />
# an associative array is obviously the sane thing to pass<br />
#<br />
# I am absolutely certain someone will find obvious problems or errors with this <br />
# I haven't even tried to compare other values than 0 so if you need to do that and surely finds obvious flaws, <br />
# please mail me, I'd really like to know. <br />
# benjaminATwebbutvecklarnaDOTse<br />
<br />
// usage example:<br />
# thrextract(mysql_fetch_assoc(mysql_query("SELECT preset_this,preset_that FROM site_preset WHERE ID = $site_id")));<br />
# thrextract(mysql_fetch_assoc(mysql_query("SELECT preset_this,preset_that FROM category_preset WHERE ID = $category_id"))); <br />
<br />
function thrextract($arr,$thr = 0){<br />
&nbsp;&nbsp;&nbsp; foreach($arr as $key =&gt; $var){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; global $$key;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if($var &gt; $thr or $$key &lt;= $thr) $$key = $var;<br />
&nbsp;&nbsp;&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81859""></a>
  <div class="note">
   <strong class="user">benjaminATwebbutvecklarnaDOTse</strong>
   <a href="#81859" class="date">17-Mar-2008 03:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Re: anon at anon dot org, about extract() and null values<br />
<br />
Personally I've found use extracting multiple resultsets from db where the latter would overwrite the previous when a variable is not null ( and optionally if its not &gt;0 )<br />
<br />
It would be useful if $extract_type was extended on top of these two:<br />
<br />
EXTR_OVERWRITE<br />
EXTR_SKIP<br />
<br />
with something like this:<br />
<br />
EXTR_OVERWRITE_NULL <br />
&nbsp;- If there is a collision, overwrite the existing variable if it is null <br />
<br />
EXTR_OVERWRITE_0<br />
&nbsp;- Same thing but == 0 or null<br />
<br />
EXTR_SKIP_NULL<br />
&nbsp;- If there is a collision, skip the new variable if the existing is not null<br />
<br />
EXTR_SKIP_0<br />
&nbsp;- Same thing but == 0 or null<br />
<br />
Those ought to cover a few good cases that aren't covered now.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="81805""></a>
  <div class="note">
   <strong class="user">Hayley Watson</strong>
   <a href="#81805" class="date">14-Mar-2008 12:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Dan O'Donnell's suggestion needs a third requirement to work as described:<br />
<br />
c) No other variables are defined - especially variables that contain potentially sensitive information.<br />
<br />
Without that condition the difference between extract() and assigning variables by hand (and the resulting security implications) should be obvious.<br />
<br />
The only valid security step there is (b) - but you should be doing that anyway.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74649""></a>
  <div class="note">
   <strong class="user">Dan O'Donnell</strong>
   <a href="#74649" class="date">21-Apr-2007 09:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Following up on ktwombley at gmail dot com's post:<br />
<br />
Presumably one easy way of dealing with this security issue is to use the EXTR_IF_EXISTS flag and make sure <br />
<br />
a) your define acceptable input variables beforehand (i.e. as empty variables)<br />
b) Sanitise any user input to avoid unacceptable variable content. <br />
<br />
If you do these two things, then I'm not sure I see the difference between extract($_REQUEST,EXTR_IF_EXISTS); and assigning each of the variables by hand.<br />
<br />
I'm not talking here about the idea of storing the variables in a database, just the immediately necessary steps to allow you to use extract on REQUEST arrays with relative safety.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73852""></a>
  <div class="note">
   <strong class="user">Dutchdavey</strong>
   <a href="#73852" class="date">13-Mar-2007 09:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I would draw your attention to the user note at the very end of this page regarding PREFIXES. The user points out that php adds a '_' to your prefixes.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="69323""></a>
  <div class="note">
   <strong class="user">ktwombley at gmail dot com</strong>
   <a href="#69323" class="date">31-Aug-2006 07:05</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's really easy to open gaping security holes using extract() on $_REQUEST, $_GET, etc. You have to be really sure of what you're doing, and use the proper flags on extract() to avoid clobbering important variables.<br />
<br />
For instance, the submission by kake26 at gmail dot com will not only perfectly emulate register globals (that's bad), but it'll store it in a database and recall the same variables every time the script runs (essentially allowing an attacker to attack your script every time it runs via one attack). Oops!<br />
<br />
To fix it, you'd have to get creative with flags. Maybe you could use EXTR_PREFIX_ALL instead of EXTR_OVERWRITE, for example. Of course, you should also sanitize the form elements to ensure there's no php code in them, and also to make sure any very important variables aren't in the form data. (like the classic $is_admin = true attack)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63234""></a>
  <div class="note">
   <strong class="user">nicolas zeh</strong>
   <a href="#63234" class="date">16-Mar-2006 06:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function provides exactly the same functionality as extract except that a parameter was added defining the extract target.<br />
This function can be used if your PHP installation does not support the required Flags or more important if you would like to extract arrays to another destination as to $GLOBALS, i.e. other arrays or objects.<br />
The only difference to extract is that extract_to moves the array pointer of $arr to the end as $arr is passed by reference to support the EXTR_REFS flag.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if( !</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'EXTR_PREFIX_ALL'</span><span class="keyword">) ) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'EXTR_PREFIX_ALL'</span><span class="keyword">, </span><span class="default">3</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if( !</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'EXTR_PREFIX_INVALID'</span><span class="keyword">) ) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'EXTR_PREFIX_INVALID'</span><span class="keyword">, </span><span class="default">4</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if( !</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'EXTR_IF_EXISTS'</span><span class="keyword">) ) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'EXTR_IF_EXISTS'</span><span class="keyword">, </span><span class="default">5</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if( !</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'EXTR_PREFIX_IF_EXISTS'</span><span class="keyword">) ) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'EXTR_PREFIX_IF_EXISTS'</span><span class="keyword">, </span><span class="default">6</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; if( !</span><span class="default">defined</span><span class="keyword">(</span><span class="string">'EXTR_REFS'</span><span class="keyword">) ) </span><span class="default">define</span><span class="keyword">(</span><span class="string">'EXTR_REFS'</span><span class="keyword">, </span><span class="default">256</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">extract_to</span><span class="keyword">( &amp;</span><span class="default">$arr</span><span class="keyword">, &amp;</span><span class="default">$to</span><span class="keyword">, </span><span class="default">$type</span><span class="keyword">=</span><span class="default">EXTR_OVERWRITE</span><span class="keyword">, </span><span class="default">$prefix</span><span class="keyword">=</span><span class="default">false </span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if( !</span><span class="default">is_array</span><span class="keyword">( </span><span class="default">$arr </span><span class="keyword">) ) return </span><span class="default">trigger_error</span><span class="keyword">(</span><span class="string">"extract_to(): First argument should be an array"</span><span class="keyword">, </span><span class="default">E_USER_WARNING </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">is_array</span><span class="keyword">( </span><span class="default">$to </span><span class="keyword">) ) </span><span class="default">$t</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else if( </span><span class="default">is_object</span><span class="keyword">( </span><span class="default">$to </span><span class="keyword">) ) </span><span class="default">$t</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; else return </span><span class="default">trigger_error</span><span class="keyword">(</span><span class="string">"extract_to(): Second argument should be an array or object"</span><span class="keyword">, </span><span class="default">E_USER_WARNING </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_SAME </span><span class="keyword">|| </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_ALL </span><span class="keyword">|| </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_INVALID </span><span class="keyword">|| </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_IF_EXISTS </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">$prefix</span><span class="keyword">===</span><span class="default">false </span><span class="keyword">) return </span><span class="default">trigger_error</span><span class="keyword">(</span><span class="string">"extract_to(): Prefix expected to be specified"</span><span class="keyword">, </span><span class="default">E_USER_WARNING </span><span class="keyword">); <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else </span><span class="default">$prefix </span><span class="keyword">.= </span><span class="string">'_'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach( </span><span class="default">$arr </span><span class="keyword">as </span><span class="default">$key</span><span class="keyword">=&gt;</span><span class="default">$val </span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$nkey </span><span class="keyword">= </span><span class="default">$key</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$isset </span><span class="keyword">= </span><span class="default">$t</span><span class="keyword">==</span><span class="default">1 </span><span class="keyword">? isset( </span><span class="default">$to</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] ) : isset( </span><span class="default">$to</span><span class="keyword">-&gt;</span><span class="default">$key </span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( ( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_SKIP </span><span class="keyword">&amp;&amp; </span><span class="default">$isset </span><span class="keyword">) <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || ( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_IF_EXISTS </span><span class="keyword">&amp;&amp; !</span><span class="default">$isset </span><span class="keyword">) )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if( ( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_SAME </span><span class="keyword">&amp;&amp; </span><span class="default">$isset </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || ( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_ALL </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || ( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_INVALID </span><span class="keyword">&amp;&amp; !</span><span class="default">preg_match</span><span class="keyword">( </span><span class="string">'#^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$#'</span><span class="keyword">, </span><span class="default">$key </span><span class="keyword">) ) )<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$nkey </span><span class="keyword">= </span><span class="default">$prefix</span><span class="keyword">.</span><span class="default">$key</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else if( </span><span class="default">$type</span><span class="keyword">==</span><span class="default">EXTR_PREFIX_IF_EXISTS </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">$isset </span><span class="keyword">) </span><span class="default">$nkey </span><span class="keyword">= </span><span class="default">$prefix</span><span class="keyword">.</span><span class="default">$key</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else continue;<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( !</span><span class="default">preg_match</span><span class="keyword">( </span><span class="string">'#^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$#'</span><span class="keyword">, </span><span class="default">$nkey </span><span class="keyword">) ) continue;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">$t</span><span class="keyword">==</span><span class="default">1 </span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">$type </span><span class="keyword">&amp; </span><span class="default">EXTR_REFS </span><span class="keyword">) </span><span class="default">$to</span><span class="keyword">-&gt;</span><span class="default">$nkey </span><span class="keyword">= &amp;</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else </span><span class="default">$to</span><span class="keyword">-&gt;</span><span class="default">$nkey </span><span class="keyword">= </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if( </span><span class="default">$type </span><span class="keyword">&amp; </span><span class="default">EXTR_REFS </span><span class="keyword">) </span><span class="default">$to</span><span class="keyword">[</span><span class="default">$nkey</span><span class="keyword">] = &amp;</span><span class="default">$arr</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else </span><span class="default">$to</span><span class="keyword">[</span><span class="default">$nkey</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$i</span><span class="keyword">++;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// e.g.:<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">extract_to</span><span class="keyword">( </span><span class="default">$myarray</span><span class="keyword">, </span><span class="default">$myobject</span><span class="keyword">, </span><span class="default">EXTR_IF_EXISTS </span><span class="keyword">);<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="62727""></a>
  <div class="note">
   <strong class="user">owk dot ch199_ph at gadz dot org</strong>
   <a href="#62727" class="date">08-Mar-2006 01:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
And if you want with PHP 5 an easy way to extract $V by reference, try this :<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$V </span><span class="keyword">as </span><span class="default">$k </span><span class="keyword">=&gt; &amp;</span><span class="default">$v</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $</span><span class="default">$k </span><span class="keyword">=&amp; </span><span class="default">$v</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span>It can be used to create special kind of "free args" functions that let you choose when you call them the way you send variables, and which ones. They are moreover very fast to call thanks to references :<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">free_args </span><span class="keyword">(&amp;</span><span class="default">$V</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach (</span><span class="default">$V </span><span class="keyword">as </span><span class="default">$k </span><span class="keyword">=&gt; &amp;</span><span class="default">$v</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $</span><span class="default">$k </span><span class="keyword">=&amp; </span><span class="default">$v</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; unset (</span><span class="default">$k</span><span class="keyword">);&nbsp; unset (</span><span class="default">$v</span><span class="keyword">);&nbsp; unset (</span><span class="default">$V</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// be careful that if you need to extract $k, $v or $V variables you should find other names for them in the lines above (ie. $__k, $__v and $__V)<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$huge_text </span><span class="keyword">= </span><span class="string">'...'</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= array (</span><span class="string">'arg1' </span><span class="keyword">=&gt; </span><span class="string">'val1'</span><span class="keyword">, </span><span class="string">'arg2' </span><span class="keyword">=&gt; &amp;</span><span class="default">$huge_text</span><span class="keyword">); </span><span class="comment">// in this call, only $arg2 will be a true reference in the function<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">free_args </span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Be warned that you can't write : "<span class="default">&lt;?php free_args </span><span class="keyword">(array (</span><span class="string">'arg1' </span><span class="keyword">=&gt; </span><span class="string">'val1'</span><span class="keyword">)); </span><span class="default">?&gt;</span>" because the array can't be referenced by the function, as it's not yet created when the function starts.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60946""></a>
  <div class="note">
   <strong class="user">moslehi&lt;atsign&gt;gmail&lt;d0t&gt;c0m</strong>
   <a href="#60946" class="date">20-Jan-2006 10:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Experimentally I found that calling extract() also shows the number of keys if the key is set and is not numeric ! Maybe there was a better definition than mine&nbsp; . Please have a look to this scripts :<br />
<br />
<span class="default">&lt;?PHP <br />
$var</span><span class="keyword">[</span><span class="string">"i"</span><span class="keyword">] = </span><span class="string">"a"</span><span class="keyword">;<br />
</span><span class="default">$var</span><span class="keyword">[</span><span class="string">"j"</span><span class="keyword">] = </span><span class="string">"b"</span><span class="keyword">;<br />
</span><span class="default">$var</span><span class="keyword">[</span><span class="string">"k"</span><span class="keyword">] = </span><span class="default">1</span><span class="keyword">;<br />
echo </span><span class="default">extract</span><span class="keyword">(</span><span class="default">$var</span><span class="keyword">); </span><span class="comment">// returns 3<br />
</span><span class="default">?&gt;<br />
</span><br />
<span class="default">&lt;?PHP <br />
$var2</span><span class="keyword">[</span><span class="string">"i"</span><span class="keyword">] = </span><span class="string">"a"</span><span class="keyword">;<br />
</span><span class="default">$var2</span><span class="keyword">[</span><span class="default">2</span><span class="keyword">] = </span><span class="string">"b"</span><span class="keyword">;<br />
</span><span class="default">$var2</span><span class="keyword">[] = </span><span class="default">1</span><span class="keyword">;<br />
echo </span><span class="default">extract</span><span class="keyword">(</span><span class="default">$var2</span><span class="keyword">); </span><span class="comment">// returns 1<br />
</span><span class="default">?&gt;<br />
</span><br />
(Arash Moslehi)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59152""></a>
  <div class="note">
   <strong class="user">Csaba at alum dot mit dot edu</strong>
   <a href="#59152" class="date">27-Nov-2005 08:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Sometimes you may want to extract only a named subset of the key/value pairs in an array.&nbsp; This keeps things more orderly and could prevent an unrelated variable from getting clobbered from an errant key.&nbsp; For example,<br />
<br />
$things = 'unsaid';<br />
$REQUEST = array(He=&gt;This, said=&gt;1, my=&gt;is, info=&gt;2, had=&gt;a,<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; very=&gt;3, important=&gt;test, things=&gt;4);<br />
$aVarToExtract = array(my, important, info);<br />
extract (array_intersect_key ($REQUEST, array_flip($aVarToExtract)));<br />
<br />
will extract<br />
$my = 'is';<br />
$important = 'test';<br />
$info = 2;<br />
<br />
but will leave certain<br />
$things = 'unsaid'<br />
<br />
Csaba Gabor from Vienna<br />
NB.&nbsp; Of course the composite request coming in from a web page is in $_REQUEST.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="53378""></a>
  <div class="note">
   <strong class="user">anon at anon dot org</strong>
   <a href="#53378" class="date">30-May-2005 09:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A warning about extract() and null values.<br />
<br />
This might be an actual Zend2 Engine bug, but it's bad programming practice, so I'm sharing it here instead.<br />
<br />
I often work in envrionments where E_STRICT (which would prevent errors like this) isn't on, and I don't have access to change it. I also use a very simple template class that in a nutshell works like this:<br />
<br />
$t = new Template('somefile.php');<br />
$t-&gt;title = $title;<br />
$t-&gt;body = $body;<br />
$t-&gt;display();<br />
<br />
display() more or less looks like this:<br />
<br />
function display(){<br />
&nbsp;&nbsp;&nbsp; extract(get_object_vars($this),EXTR_REFS);<br />
&nbsp;&nbsp;&nbsp; ob_start(); include $this-&gt;templateFileName;<br />
&nbsp;&nbsp;&nbsp; return ob_get_clean();<br />
}<br />
<br />
If any of the assigned values are null (let's say that in this case $title wasn't initialized above) it causes the engine to do all sorts of incredibly whacky stuff like certifiably lose track of variables in an incredibly inconsistent way. I traced the problem down to the fact that it's using the EXTR_REFS flag. I assume that in PHP's internal variable storage or reference counting mechanism, that trying to extract null references makes it lose track or count of something or rather.<br />
<br />
In a nutshell, if you start getting wierd behavior when using extract() make sure that the array or object you are trying to get variables out of doesn't contain null keys or values!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52436""></a>
  <div class="note">
   <strong class="user">kake26 at gmail dot com</strong>
   <a href="#52436" class="date">01-May-2005 05:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The following is a neat use for extract to store and manipulate large amounts of form data from. I basically loop through the $_POST and implode it seperating the key and value pairs by a space. Then store it in a db, the reversing function basically explodes the string to a array. Then converts the indexed array to a associative array then uses extract to seal the deal and make it easily available within a program. My main reason for sharing these are the fact I make some big web applications that store allot of forum data in a DB and these functions make it very easy to quickly and easily store and recall the data. I've contributed it because I spent many hours creating this code and recall going "I wish someone had previously submitted it to the page notes". Would have saved me allot of time and agony and I'm sure I'm not the only person that could really benefit from it, so I decided to share.<br />
<br />
<span class="default">&lt;?php<br />
$stack </span><span class="keyword">= array();<br />
foreach (</span><span class="default">$_POST </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$value</span><span class="keyword">) {<br />
</span><span class="default">array_push</span><span class="keyword">(</span><span class="default">$stack</span><span class="keyword">, </span><span class="default">$key</span><span class="keyword">, </span><span class="default">$value</span><span class="keyword">);<br />
}<br />
</span><span class="comment">// store it<br />
</span><span class="default">$block </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">(</span><span class="string">" "</span><span class="keyword">,</span><span class="default">$stack</span><span class="keyword">); </span><span class="comment">// yeilds a space delimited string<br />
// insert query to store string in DB here, like the one below<br />
</span><span class="default">$query </span><span class="keyword">= </span><span class="string">"INSERT INTO `sometable` VALUES('"</span><span class="keyword">.</span><span class="default">$seluser</span><span class="keyword">.</span><span class="string">"','"</span><span class="keyword">.</span><span class="default">addslashes</span><span class="keyword">(</span><span class="default">$block</span><span class="keyword">).</span><span class="string">"');"</span><span class="keyword">;<br />
</span><span class="default">$result </span><span class="keyword">= </span><span class="default">mysql_query</span><span class="keyword">(</span><span class="default">$query</span><span class="keyword">) or die(</span><span class="string">"Query failed for block insert: " </span><span class="keyword">. </span><span class="default">mysql_error</span><span class="keyword">());<br />
</span><span class="comment">// note $seluser in my case is a user ID associated with that block<br />
// in one of my web apps<br />
</span><span class="default">?&gt;<br />
</span><br />
The nice thing is with the above we can quickly create a string of key and value pairs from the data the script got. Without really caring what their names are. You know how if register globals are on you say $someformvar rather than $_POST["someformvar"]; , basically the code below reads this previous created block returns it to that state. Sort of like presistant register globals.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// insert query to grab the previously stored string here<br />
</span><span class="default">$query </span><span class="keyword">= </span><span class="string">"SELECT * FROM `sometable` WHERE `blockid` = '"</span><span class="keyword">.</span><span class="default">addslashes</span><span class="keyword">(</span><span class="default">$bid</span><span class="keyword">).</span><span class="string">"';"</span><span class="keyword">;<br />
</span><span class="default">$result </span><span class="keyword">= </span><span class="default">mysql_query</span><span class="keyword">(</span><span class="default">$query</span><span class="keyword">) or die(</span><span class="string">"Query failed read: " </span><span class="keyword">. </span><span class="default">mysql_error</span><span class="keyword">());<br />
</span><span class="default">$sql </span><span class="keyword">= </span><span class="default">mysql_fetch_array</span><span class="keyword">(</span><span class="default">$result</span><span class="keyword">, </span><span class="default">MYSQL_ASSOC</span><span class="keyword">);<br />
</span><span class="default">$array </span><span class="keyword">= </span><span class="default">eplode</span><span class="keyword">(</span><span class="string">" "</span><span class="keyword">,</span><span class="default">$sql</span><span class="keyword">[</span><span class="string">"data"</span><span class="keyword">]); <br />
for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">+=</span><span class="default">2</span><span class="keyword">) { <br />
</span><span class="default">$myassoc</span><span class="keyword">[</span><span class="default">$array</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]] = isset(</span><span class="default">$array</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">])?</span><span class="default">$array</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">+</span><span class="default">1</span><span class="keyword">]:</span><span class="default">NULL</span><span class="keyword">; <br />
}<br />
</span><span class="default">extract</span><span class="keyword">(</span><span class="default">$myassoc</span><span class="keyword">, </span><span class="default">EXTR_OVERWRITE</span><span class="keyword">);<br />
</span><span class="comment">// now you're key and value pairs from $_POST have been restored<br />
// instead of $_POST<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50955""></a>
  <div class="note">
   <strong class="user">pg dot perfection at gmail dot com</strong>
   <a href="#50955" class="date">14-Mar-2005 11:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a little example of how an extraction method should look like when it needs to work recursive (work on nested_arrays too)...<br />
<br />
Note that this is only an example, it can be done more easily, and more advanced too.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
&nbsp;* A nested version of the extract () function.<br />
&nbsp;*<br />
&nbsp;* @param&nbsp; &nbsp; array&nbsp; &nbsp; $array&nbsp; &nbsp; &nbsp; &nbsp; The array which to extract the variables from<br />
&nbsp;* @param&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; $type&nbsp; &nbsp; &nbsp; &nbsp; The type to use to overwrite (follows the same as extract () on PHP 5.0.3<br />
&nbsp;* @param&nbsp; &nbsp; string&nbsp; &nbsp; $prefix&nbsp; &nbsp; &nbsp; &nbsp; The prefix to be used for a variable when necessary<br />
&nbsp;*/<br />
</span><span class="keyword">function </span><span class="default">extract_nested </span><span class="keyword">(&amp;</span><span class="default">$array</span><span class="keyword">, </span><span class="default">$type </span><span class="keyword">= </span><span class="default">EXTR_OVERWRITE</span><span class="keyword">, </span><span class="default">$prefix </span><span class="keyword">= </span><span class="string">''</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; *&nbsp; Is the array really an array?<br />
&nbsp;&nbsp; &nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (!</span><span class="default">is_array </span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">trigger_error </span><span class="keyword">(</span><span class="string">'extract_nested (): First argument should be an array'</span><span class="keyword">, </span><span class="default">E_USER_WARNING</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; *&nbsp; If the prefix is set, check if the prefix matches an acceptable regex pattern <br />
&nbsp;&nbsp; &nbsp; * (the one used for variables)<br />
&nbsp;&nbsp; &nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (!empty (</span><span class="default">$prefix</span><span class="keyword">) &amp;&amp; !</span><span class="default">preg_match </span><span class="keyword">(</span><span class="string">'#^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$#'</span><span class="keyword">, </span><span class="default">$prefix</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">trigger_error </span><span class="keyword">(</span><span class="string">'extract_nested (): Third argument should start with a letter or an underscore'</span><span class="keyword">, </span><span class="default">E_USER_WARNING</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; * Check if a prefix is necessary. If so and it is empty return an error.<br />
&nbsp;&nbsp; &nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if ((</span><span class="default">$type </span><span class="keyword">== </span><span class="default">EXTR_PREFIX_SAME </span><span class="keyword">|| </span><span class="default">$type </span><span class="keyword">== </span><span class="default">EXTR_PREFIX_ALL </span><span class="keyword">|| </span><span class="default">$type </span><span class="keyword">== </span><span class="default">EXTR_PREFIX_IF_EXISTS</span><span class="keyword">) &amp;&amp; empty (</span><span class="default">$prefix</span><span class="keyword">))<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">trigger_error </span><span class="keyword">(</span><span class="string">'extract_nested (): Prefix expected to be specified'</span><span class="keyword">, </span><span class="default">E_USER_WARNING</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; * Make sure the prefix is oke<br />
&nbsp;&nbsp; &nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$prefix </span><span class="keyword">= </span><span class="default">$prefix </span><span class="keyword">. </span><span class="string">'_'</span><span class="keyword">;<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; *&nbsp; Loop thru the array<br />
&nbsp;&nbsp; &nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">foreach (</span><span class="default">$array </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$val</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; If the key isn't an array extract it as we need to do<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (!</span><span class="default">is_array </span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch (</span><span class="default">$type</span><span class="keyword">)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; default:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_OVERWRITE</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_SKIP</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = isset (</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">]) ? </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] : </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_PREFIX_SAME</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (isset (</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$prefix </span><span class="keyword">. </span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_PREFIX_ALL</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$prefix </span><span class="keyword">. </span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_PREFIX_INVALID</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!</span><span class="default">preg_match </span><span class="keyword">(</span><span class="string">'#^[a-zA-Z_\x7f-\xff]$#'</span><span class="keyword">, </span><span class="default">$key</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">}))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$prefix </span><span class="keyword">. </span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_IF_EXISTS</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (isset (</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_PREFIX_IF_EXISTS</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (isset (</span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">]))<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$prefix </span><span class="keyword">. </span><span class="default">$key</span><span class="keyword">] = </span><span class="default">$val</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case </span><span class="default">EXTR_REFS</span><span class="keyword">:<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] =&amp; </span><span class="default">$array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; *&nbsp; The key is an array... use the function on that index<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; */<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">else<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">extract_nested </span><span class="keyword">(</span><span class="default">$array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">], </span><span class="default">$type</span><span class="keyword">, </span><span class="default">$prefix</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50549""></a>
  <div class="note">
   <strong class="user">Michael Newton</strong>
   <a href="#50549" class="date">03-Mar-2005 02:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
They say "If the result is not a valid variable name, it is not imported into the symbol table."<br />
<br />
What they should say is that if _any_ of the results have invalid names, _none_ of the variables get extracted.<br />
<br />
Under 4.3.10 on Windows 2000, I was pulling some mySQL records, but needed to convert two fields into IP addresses:<br />
&lt;?<br />
extract(mysql_fetch_assoc(mysql_query('SELECT * FROM foo')));<br />
extract(mysql_fetch_assoc(mysql_query('SELECT INET_NTOA(bar) AS bar, INET_NTOA(baz) FROM foo')));<br />
?&gt;<br />
<br />
I had forgotten the second AS modifier in the SQL query.&nbsp; Because it couldn't extract a variable called INET_NTOA(baz) into the symbol table, it didn't do either of them.<br />
<br />
(BTW I don't normally stack functions up like that!&nbsp; Just to make a short example!)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50215""></a>
  <div class="note">
   
   <a href="#50215" class="date">22-Feb-2005 04:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To make this perfectly clear (hopefully), an underscore is always added when the string is prefixed.<br />
extract(array("color" =&gt; "blue"),EXTR_PREFIX_ALL,'');// note: prefix is empty<br />
is the same as<br />
$color='_blue';</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="47481""></a>
  <div class="note">
   <strong class="user">Aaron Stone</strong>
   <a href="#47481" class="date">17-Nov-2004 07:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are working porting an older application, and taking the advice above, extracting only _SERVER, _SESSING, _COOKIE, _POST, _GET, you have forgotten to extract _FILES. Putting _FILES last and using EXTR_SKIP doesn't work because the name of the file upload box is already set as a variable containing only the temporary name of the uploaded file from one of the earlier extracts (I haven't tested to see which one specifically, however). A workaround is to put _FILES last and use EXTR_OVERWRITE. This allows extract to replace that temp-name-only variable with the full array of file upload information.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46221""></a>
  <div class="note">
   <strong class="user">Adam Monsen &lt;adamm at wazamatta dot com&gt;</strong>
   <a href="#46221" class="date">03-Oct-2004 02:03</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As shown in the example, if your 'prefix' is used, a single underscore is added to the name of the extracted variable. Meaning, a prefix of 'p' becomes a prefix of 'p_', so 'blarg' prefixed would be 'p_blarg'.<br />
<br />
If you're not sure what variables you've created through extraction, you can call get_defined_vars() to see all defined variables in the current scope.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.end.html">end</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.in-array.html">in_array</a></div>
 <div class="up"><a href="ref.array.html">配列 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
