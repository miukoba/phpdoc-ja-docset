<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>リファレンスの説明</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="language.generators.comparison.html">ジェネレータと Iterator オブジェクトとの比較</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="language.references.whatare.html">リファレンスとは?</a></div>
 <div class="up"><a href="langref.html">言語リファレンス</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="language.references" class="chapter">
  <h1>リファレンスの説明</h1>
<h2>目次</h2><ul class="chunklist chunklist_chapter"><li><a href="language.references.whatare.html">リファレンスとは?</a></li><li><a href="language.references.whatdo.html">リファレンスが行うことは何ですか?</a></li><li><a href="language.references.arent.html">リファレンスが行わないこと</a></li><li><a href="language.references.pass.html">リファレンス渡し</a></li><li><a href="language.references.return.html">リファレンスを返す</a></li><li><a href="language.references.unset.html">リファレンスの解除</a></li><li><a href="language.references.spot.html">リファレンスの適用範囲</a></li></ul>


  

  
  
  
  
  

  
  
  
  
  

 </div>
<div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="113187""></a>
  <div class="note">
   <strong class="user">shooo dot xz at gmail dot com</strong>
   <a href="#113187" class="date">10-Sep-2013 09:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Hi, i've worked a abit on reference stuff.<br />
Here is what i've noticed.<br />
<br />
The problem: Sort mysql result through columns<br />
<br />
$rewrite_self = gt::recombine(array('lang', 'id'), 'value_column', $sql_result);<br />
<br />
public static function recombine($keys, $value, &amp;$arr) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $ref = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $main = &amp;$ref;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; foreach($arr as $data) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach($keys as $key) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if (!is_array($ref[$data[$key]])) $ref[$data[$key]] = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ref = &amp;$ref[$data[$key]];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ref = $data[$value];<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $ref = &amp;$main;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return $main;<br />
}<br />
<br />
array(2) {<br />
&nbsp; ["pl"]=&gt;<br />
&nbsp; array(2) {<br />
&nbsp;&nbsp;&nbsp; [2]=&gt;<br />
&nbsp;&nbsp;&nbsp; string(4) "value_column_str"<br />
&nbsp;&nbsp;&nbsp; [3]=&gt;<br />
&nbsp;&nbsp;&nbsp; string(4) "value_column_str2"<br />
&nbsp; }<br />
&nbsp; ["en"]=&gt;<br />
&nbsp; array(1) {<br />
&nbsp;&nbsp;&nbsp; [13]=&gt;<br />
&nbsp;&nbsp;&nbsp; string(7) "value_column_str3"<br />
&nbsp; }<br />
}<br />
<br />
Enjoy!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107946""></a>
  <div class="note">
   <strong class="user">sneskid at hotmail dot com</strong>
   <a href="#107946" class="date">16-Mar-2012 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is no built in method (yet) to check if two variables are references to the same piece of data, but you can do a "reference sniff" test. This is rarely needed, but can be very useful. The function bellow is a slightly modified version of this technique I saw in a forum regarding this comparison limitation.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">is_ref_to</span><span class="keyword">(&amp;</span><span class="default">$a</span><span class="keyword">, &amp;</span><span class="default">$b</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$r</span><span class="keyword">=(</span><span class="default">$b</span><span class="keyword">===(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">1</span><span class="keyword">))){ </span><span class="default">$r </span><span class="keyword">= (</span><span class="default">$b</span><span class="keyword">===(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">)); }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">$t</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$r</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">$varA </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
</span><span class="default">$varB </span><span class="keyword">= </span><span class="default">$varA</span><span class="keyword">;<br />
</span><span class="default">$varC </span><span class="keyword">=&amp;</span><span class="default">$varA</span><span class="keyword">;<br />
<br />
</span><span class="default">var_dump</span><span class="keyword">( </span><span class="default">is_ref_to</span><span class="keyword">(</span><span class="default">$varA</span><span class="keyword">, </span><span class="default">$varB</span><span class="keyword">) ); </span><span class="comment">// bool(false)<br />
</span><span class="default">var_dump</span><span class="keyword">( </span><span class="default">is_ref_to</span><span class="keyword">(</span><span class="default">$varA</span><span class="keyword">, </span><span class="default">$varC</span><span class="keyword">) ); </span><span class="comment">// bool(true)<br />
</span><span class="default">?&gt;<br />
</span><br />
The test above uses a two step process to be 100% generic.<br />
But if you are sure the variables being tested will not be a certain value, example null, then use that value to allow a one step check.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">is_ref_to_1step</span><span class="keyword">(&amp;</span><span class="default">$a</span><span class="keyword">, &amp;</span><span class="default">$b</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$r</span><span class="keyword">=(</span><span class="default">$b</span><span class="keyword">===(</span><span class="default">$a</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">$t</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$r</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100451""></a>
  <div class="note">
   <strong class="user">zoranbankovic at gmail dot com</strong>
   <a href="#100451" class="date">16-Oct-2010 10:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If someone wants to add slashes to multidimensional array directly, can use recursive (pass-by-reference) function like this:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">slashit</span><span class="keyword">(&amp;</span><span class="default">$aray</span><span class="keyword">, </span><span class="default">$db_link</span><span class="keyword">)<br />
{<br />
&nbsp; foreach (</span><span class="default">$aray </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; &amp;</span><span class="default">$value</span><span class="keyword">)<br />
&nbsp;&nbsp; if(</span><span class="default">is_array</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">)) </span><span class="default">slashit</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">, </span><span class="default">$link</span><span class="keyword">);<br />
&nbsp;&nbsp; else </span><span class="default">$aray</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">mysql_real_escape_string</span><span class="keyword">(</span><span class="default">$value</span><span class="keyword">, </span><span class="default">$db_link</span><span class="keyword">);<br />
}<br />
<br />
</span><span class="comment">// Test:<br />
</span><span class="default">$fruits </span><span class="keyword">= array (<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"fruits"&nbsp; </span><span class="keyword">=&gt; array(</span><span class="string">"a" </span><span class="keyword">=&gt; </span><span class="string">"or'ange"</span><span class="keyword">, </span><span class="string">"b" </span><span class="keyword">=&gt; </span><span class="string">"ban'ana"</span><span class="keyword">, </span><span class="string">"c" </span><span class="keyword">=&gt; </span><span class="string">"apple'"</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"numbers" </span><span class="keyword">=&gt; array(</span><span class="default">1</span><span class="keyword">, </span><span class="default">2</span><span class="keyword">, </span><span class="default">3</span><span class="keyword">, </span><span class="default">4</span><span class="keyword">, </span><span class="default">5</span><span class="keyword">, </span><span class="default">6</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"holes"&nbsp;&nbsp; </span><span class="keyword">=&gt; array(</span><span class="string">"fir'st"</span><span class="keyword">, </span><span class="default">5 </span><span class="keyword">=&gt; </span><span class="string">"sec'ond"</span><span class="keyword">, </span><span class="string">"thir'd"</span><span class="keyword">),<br />
&nbsp;&nbsp;&nbsp; </span><span class="string">"odma"&nbsp; &nbsp; </span><span class="keyword">=&gt; </span><span class="string">"jugo'slavija"<br />
</span><span class="keyword">);<br />
<br />
</span><span class="comment">// You have to make link to the database or can use addslashes instead of mysql_real_escape_string and remove $link from function definition<br />
<br />
</span><span class="default">slashit</span><span class="keyword">(</span><span class="default">$fruits</span><span class="keyword">, </span><span class="default">$dbLink</span><span class="keyword">);<br />
echo </span><span class="string">"&lt;pre&gt;"</span><span class="keyword">; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$fruits</span><span class="keyword">); echo </span><span class="string">"&lt;/pre&gt;"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
// Output:<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [fruits] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [a] =&gt; or\'ange<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [b] =&gt; ban\'ana<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [c] =&gt; apple\'<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
&nbsp;&nbsp;&nbsp; [numbers] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [1] =&gt; 2<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [2] =&gt; 3<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [3] =&gt; 4<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [4] =&gt; 5<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [5] =&gt; 6<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
&nbsp;&nbsp;&nbsp; [holes] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; fir\'st<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [5] =&gt; sec\'ond<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [6] =&gt; thir\'d<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
&nbsp;&nbsp;&nbsp; [odma] =&gt; jugo\'slavija<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="99644""></a>
  <div class="note">
   <strong class="user">gnuffo1 at gmail dot com</strong>
   <a href="#99644" class="date">28-Aug-2010 04:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you want to know the reference count of a particular variable, then here's a function that makes use of debug_zval_dump() to do so:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">refcount</span><span class="keyword">(</span><span class="default">$var</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">ob_start</span><span class="keyword">();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">debug_zval_dump</span><span class="keyword">(</span><span class="default">$var</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$dump </span><span class="keyword">= </span><span class="default">ob_get_clean</span><span class="keyword">();<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$matches </span><span class="keyword">= array();<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">preg_match</span><span class="keyword">(</span><span class="string">'/refcount\(([0-9]+)/'</span><span class="keyword">, </span><span class="default">$dump</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$count </span><span class="keyword">= </span><span class="default">$matches</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">//3 references are added, including when calling debug_zval_dump()<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">return </span><span class="default">$count </span><span class="keyword">- </span><span class="default">3</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
debug_zval_dump() is a confusing function, as explained in its documentation, as among other things, it adds a reference count when being called as there is a reference within the function. refcount() takes account of these extra references by subtracting them for the return value.<br />
<br />
It's also even more confusing when dealing with variables that have been assigned by reference (=&amp;), either on the right or left side of the assignment, so for that reason, the above function doesn't really work for those sorts of variables. I'd use it more on object instances.<br />
<br />
However, even taking into account that passing a variable to a function adds one to the reference count; which should mean that calling refcount() adds one, and then calling debug_zval_dump() adds another, refcount() seems to have aquired another reference from somewhere; hence subtracting 3 instead of 2 in the return line. Not quite sure where that comes from.<br />
<br />
I've only tested this on 5.3; due to the nature of debug_zval_dump(), the results may be completely different on other versions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="95154""></a>
  <div class="note">
   <strong class="user">Youssef Omar</strong>
   <a href="#95154" class="date">15-Dec-2009 09:27</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is to show the affect of changing property of object A through another object B when you pass object A as a property of another object B.<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;</span><span class="comment">// data class to be passed to another class as an object<br />
&nbsp;</span><span class="keyword">class </span><span class="default">A</span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; public </span><span class="default">$info</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">__construct</span><span class="keyword">(){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">= </span><span class="string">"eeee"</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}<br />
&nbsp;<br />
&nbsp;</span><span class="comment">// B class to change the info in A obj<br />
&nbsp;</span><span class="keyword">class </span><span class="default">B_class</span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; public </span><span class="default">$A_obj</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">__construct</span><span class="keyword">(</span><span class="default">$A_obj</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">A_obj </span><span class="keyword">=&nbsp; </span><span class="default">$A_obj</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; public function </span><span class="default">change</span><span class="keyword">(</span><span class="default">$newVal</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">= </span><span class="default">$newVal</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;}<br />
<br />
&nbsp;</span><span class="comment">// create data object from the A<br />
&nbsp;</span><span class="default">$A_obj </span><span class="keyword">= new </span><span class="default">A</span><span class="keyword">();<br />
&nbsp;</span><span class="comment">// print the info property<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'A_obj info: ' </span><span class="keyword">. </span><span class="default">$A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
&nbsp;<br />
&nbsp;</span><span class="comment">// create the B object and pass the A_obj we created above<br />
&nbsp;</span><span class="default">$B_obj </span><span class="keyword">= new </span><span class="default">B_class</span><span class="keyword">(</span><span class="default">$A_obj</span><span class="keyword">);<br />
&nbsp;</span><span class="comment">// print the info property through the B object to make sure it has the same value 'eeee'<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'B_obj info: ' </span><span class="keyword">. </span><span class="default">$B_obj</span><span class="keyword">-&gt;</span><span class="default">A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
&nbsp;<br />
&nbsp;</span><span class="comment">// chage the info property<br />
&nbsp;</span><span class="default">$B_obj</span><span class="keyword">-&gt;</span><span class="default">change</span><span class="keyword">(</span><span class="string">'xxxxx'</span><span class="keyword">);<br />
&nbsp;</span><span class="comment">// print the info property through the B object to make sure it changed the value to 'xxxxxx'<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'B_obj info after change: ' </span><span class="keyword">. </span><span class="default">$B_obj</span><span class="keyword">-&gt;</span><span class="default">A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
&nbsp;</span><span class="comment">// print the info property from the A_obj to see if the change through B_obj has affected it<br />
&nbsp;</span><span class="keyword">echo </span><span class="string">'A_obj info: ' </span><span class="keyword">. </span><span class="default">$A_obj</span><span class="keyword">-&gt;</span><span class="default">info </span><span class="keyword">. </span><span class="string">'&lt;br/&gt;'</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
The result:<br />
<br />
A_obj info: eeee<br />
B_obj info: eeee<br />
B_obj info after change: xxxxx<br />
A_obj info: xxxxx</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93812""></a>
  <div class="note">
   <strong class="user">strata_ranger at hotmail dot com</strong>
   <a href="#93812" class="date">30-Sep-2009 08:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that in PHP5 you generally don't need the reference operator -- at all -- when dealing with class objects, because PHP5 implements objects using Instances (which are more like C pointers than PHP's references system).<br />
<br />
For example:<br />
<span class="default">&lt;?php<br />
</span><span class="comment">//<br />
// Since PHP 5<br />
//<br />
<br />
</span><span class="default">$foo </span><span class="keyword">= new </span><span class="default">stdClass</span><span class="keyword">();<br />
<br />
</span><span class="comment">// $bar and $foo are still holding the same (single) object<br />
</span><span class="default">$bar </span><span class="keyword">= </span><span class="default">$foo</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$foo</span><span class="keyword">, </span><span class="default">$bar</span><span class="keyword">)<br />
</span><span class="comment">// object(stdClass)#1 (0) { }<br />
// object(stdClass)#1 (0) { }<br />
<br />
</span><span class="default">$bar</span><span class="keyword">-&gt;</span><span class="default">member </span><span class="keyword">= </span><span class="string">"Something"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$foo</span><span class="keyword">, </span><span class="default">$bar</span><span class="keyword">);<br />
</span><span class="comment">// object(stdClass)#1 (1) {<br />
//&nbsp; ["member"]=&gt;<br />
//&nbsp; string(9) "Something"<br />
// }<br />
// object(stdClass)#1 (1) {<br />
//&nbsp;&nbsp; ["member"]=&gt;<br />
//&nbsp;&nbsp; string(9) "Something"<br />
// }<br />
<br />
// Use the 'clone' keyword to make a separate copy of the object<br />
</span><span class="default">$bar </span><span class="keyword">= clone </span><span class="default">$foo</span><span class="keyword">;<br />
</span><span class="default">$bar</span><span class="keyword">-&gt;</span><span class="default">member </span><span class="keyword">= </span><span class="string">"Something"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$foo</span><span class="keyword">, </span><span class="default">$bar</span><span class="keyword">);<br />
</span><span class="comment">// object(stdClass)#1 (0) { }<br />
// object(stdClass)#2 (1) {<br />
//&nbsp;&nbsp; ["member"]=&gt;<br />
//&nbsp;&nbsp; string(9) "Something"<br />
// }<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93292""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#93292" class="date">01-Sep-2009 10:07</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
After hours of confusion and reading tons of posts I finally figured out that replacing PHP 4 style object creation, where new is assigned by reference:<br />
<br />
$node_obj =&amp; new someClass($somearg, $moreargs);<br />
<br />
which in PHP 5.3.0 generates an E_STRICT message telling you that "Assigning the return value of new by reference is deprecated" <br />
<br />
with the following, where &amp; has been removed:<br />
<br />
$node_obj = new someClass($somearg, $moreargs);<br />
<br />
in some cases (at least in recursive loops while creating a tree of nodes containing child nodes) requires<br />
<br />
unset($node_obj);<br />
<br />
before the actual object assignment line to avoid all child nodes becoming identical. <br />
<br />
Hope that delicate piece of information will save someone else a few hours.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92215""></a>
  <div class="note">
   <strong class="user">wernerdegroot at nospam dot gmail</strong>
   <a href="#92215" class="date">14-Jul-2009 08:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In the following case you don't have to use = &amp; operator when returning a reference:<br />
<br />
<span class="default">&lt;?php<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">class </span><span class="default">a </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public </span><span class="default">$a </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; class </span><span class="default">b </span><span class="keyword">{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; static </span><span class="default">$var</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; public static function &amp; </span><span class="default">gvar</span><span class="keyword">(</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if(!(isset(</span><span class="default">b</span><span class="keyword">::</span><span class="default">$var</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]))) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">b</span><span class="keyword">::</span><span class="default">$var</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">] = new </span><span class="default">a</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">b</span><span class="keyword">::</span><span class="default">$var</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">];<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$b </span><span class="keyword">= new </span><span class="default">b</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">b</span><span class="keyword">::</span><span class="default">gvar</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a</span><span class="keyword">-&gt;</span><span class="default">a </span><span class="keyword">= </span><span class="default">14</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$c </span><span class="keyword">= </span><span class="default">b</span><span class="keyword">::</span><span class="default">gvar</span><span class="keyword">(</span><span class="default">1</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; echo </span><span class="default">$c</span><span class="keyword">-&gt;</span><span class="default">a</span><span class="keyword">; </span><span class="comment">// 14<br />
</span><span class="default">?&gt;<br />
</span><br />
Note the $a = b::gvar(1) instead of $a = &amp; b::gvar(1)!!!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="89264""></a>
  <div class="note">
   <strong class="user">midir</strong>
   <a href="#89264" class="date">28-Feb-2009 08:44</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is a good magazine article (PDF format) that explains the internals of PHP's reference mechanism in detail: <a href="http://derickrethans.nl/files/phparch-php-variables-article.pdf" rel="nofollow" target="_blank">http://derickrethans.nl/files/phparch-php-variables-article.pdf</a><br />
<br />
It should explain some of the odd behavior PHP sometimes seems to exhibit, as well as why you can't create "references to references" (unlike in C++), and why you should never attempt to use references to speed up passing of large strings or arrays (it will make no difference, or it will slow things down).<br />
<br />
It was written for PHP 4 but it still applies. The only difference is in how PHP 5 handles objects: passing object variables by value only copies an internal pointer to the object. Objects in PHP 5 are only ever duplicated if you explicitly use the clone keyword.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="88821""></a>
  <div class="note">
   <strong class="user">bytepirate</strong>
   <a href="#88821" class="date">09-Feb-2009 11:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in additon to blakes comment. try this:<br />
<br />
<span class="default">&lt;?php<br />
$strlen</span><span class="keyword">=</span><span class="default">60000</span><span class="keyword">;<br />
</span><span class="default">$bstring</span><span class="keyword">=</span><span class="default">str_repeat</span><span class="keyword">(</span><span class="string">"X"</span><span class="keyword">,</span><span class="default">$strlen</span><span class="keyword">);<br />
</span><span class="default">$astring</span><span class="keyword">=</span><span class="default">$bstring</span><span class="keyword">;<br />
</span><span class="default">$starttime</span><span class="keyword">=</span><span class="default">microtime</span><span class="keyword">(</span><span class="default">true</span><span class="keyword">);<br />
for(</span><span class="default">$i</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">&lt;=</span><span class="default">$strlen</span><span class="keyword">;</span><span class="default">$i</span><span class="keyword">++){<br />
&nbsp; if(</span><span class="default">$i</span><span class="keyword">==</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$astring</span><span class="keyword">))<br />
&nbsp;&nbsp; &nbsp; echo </span><span class="string">"End of String&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
echo (</span><span class="default">microtime</span><span class="keyword">(</span><span class="default">true</span><span class="keyword">)-</span><span class="default">$starttime</span><span class="keyword">).</span><span class="string">" seconds expired"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
and now change '$astring=$bstring;' to '$astring=&amp;$bstring;'<br />
on my system its 200 times slower with the reference.<br />
increase $strlen and it gets even worse ;-)<br />
<br />
(PHP 5.25 on UNIX)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87532""></a>
  <div class="note">
   <strong class="user">ivan at mailinator dot com</strong>
   <a href="#87532" class="date">09-Dec-2008 02:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A little gotcha (be careful with references!):<br />
<br />
<span class="default">&lt;?php<br />
$arr </span><span class="keyword">= array(</span><span class="string">'a'</span><span class="keyword">=&gt;</span><span class="string">'first'</span><span class="keyword">, </span><span class="string">'b'</span><span class="keyword">=&gt;</span><span class="string">'second'</span><span class="keyword">, </span><span class="string">'c'</span><span class="keyword">=&gt;</span><span class="string">'third'</span><span class="keyword">);<br />
foreach (</span><span class="default">$arr </span><span class="keyword">as &amp;</span><span class="default">$a</span><span class="keyword">); </span><span class="comment">// do nothing. maybe?<br />
</span><span class="keyword">foreach (</span><span class="default">$arr </span><span class="keyword">as </span><span class="default">$a</span><span class="keyword">);&nbsp; </span><span class="comment">// do nothing. maybe?<br />
</span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Output:<br />
<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [a] =&gt; first<br />
&nbsp;&nbsp;&nbsp; [b] =&gt; second<br />
&nbsp;&nbsp;&nbsp; [c] =&gt; second<br />
)<br />
<br />
Add 'unset($a)' between the foreachs to obtain the 'correct' output:<br />
<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [a] =&gt; first<br />
&nbsp;&nbsp;&nbsp; [b] =&gt; second<br />
&nbsp;&nbsp;&nbsp; [c] =&gt; third<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="85118""></a>
  <div class="note">
   <strong class="user">blake</strong>
   <a href="#85118" class="date">15-Aug-2008 04:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To ffmandu13 at hotmail dot com, that's not correct. If you do a little research, you'll see that the Zend Engine employs "copy-on-write" logic, meaning that variables will be referenced instead of copied until it's actually written to. There's really no need to circumvent Zend's internal optimizations, since they're probably much more advanced than you think. Here's a good link to read over:<br />
<br />
<a href="http://bytes.com/forum/thread769586.html" rel="nofollow" target="_blank">http://bytes.com/forum/thread769586.html</a><br />
<br />
As stated, there's rarely (if ever) a need to use references for optimization purposes. When in doubt, remember that in most cases, the Zend Engine &gt; you.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84502""></a>
  <div class="note">
   <strong class="user">zzo38</strong>
   <a href="#84502" class="date">16-Jul-2008 10:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You can make references like pointers. Example:<br />
<span class="default">&lt;?php<br />
&nbsp; $a</span><span class="keyword">=</span><span class="default">6</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$b</span><span class="keyword">=array(&amp;</span><span class="default">$a</span><span class="keyword">); </span><span class="comment">// $b is a pointer to $a<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">=array(&amp;</span><span class="default">$b</span><span class="keyword">); </span><span class="comment">// $c is a pointer to $b<br />
&nbsp; </span><span class="default">$d</span><span class="keyword">=</span><span class="default">7</span><span class="keyword">;<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]=</span><span class="default">9</span><span class="keyword">; </span><span class="comment">// $a is 9<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">]=array(&amp;</span><span class="default">$d</span><span class="keyword">); </span><span class="comment">// $b is a pointer to $d<br />
&nbsp; </span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">]=</span><span class="default">4</span><span class="keyword">; </span><span class="comment">// $d is 4<br />
&nbsp; </span><span class="default">$b</span><span class="keyword">=array(&amp;</span><span class="default">$a</span><span class="keyword">); </span><span class="comment">// $b is a pointer to $a again<br />
&nbsp; </span><span class="keyword">echo </span><span class="default">$a</span><span class="keyword">.</span><span class="default">$b</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">].</span><span class="default">$c</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">][</span><span class="default">0</span><span class="keyword">].</span><span class="default">$d</span><span class="keyword">; </span><span class="comment">// outputs 9994<br />
</span><span class="default">?&gt;<br />
</span>These kind of pointers may even be passed to functions or returned from functions, copied and stored in multiple arrays/variables/objects, etc.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84378""></a>
  <div class="note">
   <strong class="user">jasonpvp at gmail dot com</strong>
   <a href="#84378" class="date">11-Jul-2008 01:16</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To change values in a multi-dimensional array while looping through:<br />
<br />
$var=array('a'=&gt;array(1,2,3),'b'=&gt;array(4,5,6));<br />
<br />
foreach ($var as &amp;$sub) {<br />
&nbsp; foreach ($sub as &amp;$element) {<br />
&nbsp;&nbsp;&nbsp; $element=$element+1;<br />
&nbsp; }<br />
}<br />
<br />
var_dump($var);<br />
<br />
------------------------------<br />
produces:<br />
------------------------------<br />
array(2) {<br />
&nbsp; ["a"]=&gt;<br />
&nbsp; array(3) {<br />
&nbsp;&nbsp;&nbsp; [0]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(2)<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(3)<br />
&nbsp;&nbsp;&nbsp; [2]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(4)<br />
&nbsp; }<br />
&nbsp; ["b"]=&gt;<br />
&nbsp; array(3) {<br />
&nbsp;&nbsp;&nbsp; [0]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(5)<br />
&nbsp;&nbsp;&nbsp; [1]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(6)<br />
&nbsp;&nbsp;&nbsp; [2]=&gt;<br />
&nbsp;&nbsp;&nbsp; int(7)<br />
&nbsp; }<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="84088""></a>
  <div class="note">
   <strong class="user">mpapec</strong>
   <a href="#84088" class="date">27-Jun-2008 02:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It's strange that function definition AND call to the same function must have "&amp;" before them. <br />
<br />
$arr = array();<br />
$ref =&amp; oras($arr['blah'], array());<br />
$ref []= "via ref";<br />
print_r($arr);<br />
<br />
/* result<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [blah] =&gt; Array<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; (<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [0] =&gt; via ref<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; )<br />
<br />
)<br />
*/<br />
<br />
// perl like ||=<br />
function &amp;oras (&amp;$v, $new) {<br />
&nbsp; $v or $v = $new;<br />
&nbsp; return $v;<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83737""></a>
  <div class="note">
   <strong class="user">dnhuff at acm dot org</strong>
   <a href="#83737" class="date">09-Jun-2008 09:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is discussed before (below) but bears repeating:<br />
<br />
$a = null; ($a =&amp; null; does not parse) is NOT the same as unset($a);<br />
<br />
$a = null; replaces the value at the destination of $a with the null value;<br />
<br />
If you chose to use a convention like $NULL = NULL;<br />
<br />
THEN, you could say $a =&amp; $NULL to break any previous reference assignment to $a (setting it of course to $NULL), which could still get you into trouble if you forgot and then said $a = '5'. Now $NULL would be '5'.<br />
<br />
Moral: use unset when it is called for.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83325""></a>
  <div class="note">
   <strong class="user">Dave at SymmetricDesigns dot com</strong>
   <a href="#83325" class="date">21-May-2008 08:24</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another example of something to watch out for when using references with arrays.&nbsp; It seems that even an usused reference to an array cell modifies the *source* of the reference.&nbsp; Strange behavior for an assignment statement (is this why I've seen it written as an =&amp; operator?&nbsp; - although this doesn't happen with regular variables).<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $array1 </span><span class="keyword">= array(</span><span class="default">1</span><span class="keyword">,</span><span class="default">2</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x </span><span class="keyword">= &amp;</span><span class="default">$array1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];&nbsp;&nbsp; </span><span class="comment">// Unused reference<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2 </span><span class="keyword">= </span><span class="default">$array1</span><span class="keyword">;&nbsp; </span><span class="comment">// reference now also applies to $array2 !<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="default">22</span><span class="keyword">;&nbsp; &nbsp; &nbsp; </span><span class="comment">// (changing [0] will not affect $array1)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array1</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
&nbsp;&nbsp;&nbsp; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 22&nbsp; &nbsp; // var_dump() will show the &amp; here<br />
&nbsp;&nbsp;&nbsp; )<br />
<br />
I fixed my bug by rewriting the code without references, but it can also be fixed with the unset() function:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $array1 </span><span class="keyword">= array(</span><span class="default">1</span><span class="keyword">,</span><span class="default">2</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$x </span><span class="keyword">= &amp;</span><span class="default">$array1</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2 </span><span class="keyword">= </span><span class="default">$array1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; unset(</span><span class="default">$x</span><span class="keyword">); </span><span class="comment">// Array copy is now unaffected by above reference<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$array2</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="default">22</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$array1</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span>Produces:<br />
&nbsp;&nbsp;&nbsp; Array<br />
&nbsp;&nbsp;&nbsp; (<br />
&nbsp;&nbsp;&nbsp; [0] =&gt; 1<br />
&nbsp;&nbsp;&nbsp; [1] =&gt; 2<br />
&nbsp;&nbsp;&nbsp; )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82703""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#82703" class="date">22-Apr-2008 08:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To henrik at newdawn dot dk, 28-Oct-2007<br />
<br />
No, it's not strange.<br />
$this-&gt;$var['key'] tries to look up 'key' in the array $var and then use that for the property name. $this-&gt;{$var}['key'], on the other hand...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79220""></a>
  <div class="note">
   <strong class="user">marco at greenlightsolutions dot nl</strong>
   <a href="#79220" class="date">15-Nov-2007 11:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I ran into a bit of a problem recently, with an array copy resulting in a reference copy of one of the elements instead of a clone. Sample code:<br />
<br />
<span class="default">&lt;?php<br />
$a</span><span class="keyword">=array(</span><span class="default">1 </span><span class="keyword">=&gt; </span><span class="string">"A"</span><span class="keyword">);<br />
</span><span class="default">$b</span><span class="keyword">=&amp;</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
</span><span class="default">$c</span><span class="keyword">=</span><span class="default">$a</span><span class="keyword">; </span><span class="comment">// should be a deep cloning<br />
</span><span class="default">$c</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]=</span><span class="string">"C"</span><span class="keyword">;<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]); </span><span class="comment">// yields 'C' instead of 'A'<br />
</span><span class="default">?&gt;<br />
</span><br />
After some searching, I found that it was a known bug which would be too costly to fix (see <a href="http://bugs.php.net/bug.php?id=20993" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=20993</a>). There was supposed to be some documentation on this behaviour on this page:<br />
<br />
"Due to peculiarities of the internal workings of PHP, if a reference&nbsp; is made to a single element of an array and then the array is copied, whether by assignment or when passed by value in a function call, the reference is copied as part of the array.&nbsp; This means that changes to any such elements in either array will be duplicated in the other array (and in the other references), even if the arrays have different scopes (e.g. one is an argument inside a function and the other is global)!&nbsp; Elements that did not have references at the time of the copy, as well as references assigned to those other elements after the copy of the array, will behave normally (i.e. independent of the other array)."<br />
<br />
However, this paragraph appears to have been removed from this page at some point, presumably because it was a bit obscure. The comments section seem to be a proper place for this, though.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79086""></a>
  <div class="note">
   <strong class="user">warnickr at gmail dot com</strong>
   <a href="#79086" class="date">10-Nov-2007 10:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I must say that it has been rather confusing following all of the explanations of PHP references, especially since I've worked a lot with C pointers.&nbsp; As far as I can tell PHP references are the same as C pointers for all practical purposes.&nbsp; I think a lot of the confusion comes from examples like the one shown below where people expect that a C pointer version of this would change what $bar references.&nbsp; <br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">(&amp;</span><span class="default">$var</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$var </span><span class="keyword">=&amp; </span><span class="default">$GLOBALS</span><span class="keyword">[</span><span class="string">"baz"</span><span class="keyword">];<br />
}<br />
</span><span class="default">foo</span><span class="keyword">(</span><span class="default">$bar</span><span class="keyword">); <br />
</span><span class="default">?&gt;</span> <br />
<br />
This is not the case.&nbsp; In fact, a C pointer version of this example (shown below) would behave exactly the same way (it would not modify what bar references) as the PHP reference version.<br />
<br />
int baz = 5;<br />
int* bar;<br />
void foo(int* var)<br />
{<br />
&nbsp;&nbsp;&nbsp; var = &amp;baz;<br />
}<br />
foo(bar);<br />
<br />
In this case, just as in the case of PHP references, the call foo(bar) doesn't change what bar references.&nbsp; If you wanted to change what bar references, then you would need to work with a double pointer like so:<br />
<br />
int baz = 5;<br />
int* bar;<br />
void foo(int** var)<br />
{<br />
&nbsp;&nbsp;&nbsp; *var = &amp;baz;<br />
}<br />
foo(&amp;bar);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="78789""></a>
  <div class="note">
   <strong class="user">henrik at newdawn dot dk</strong>
   <a href="#78789" class="date">28-Oct-2007 12:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A note for those of you that are using constructs like the following:<br />
return $this-&gt;$MyVarName<br />
in your objects.<br />
<br />
Consider the following:<br />
class Test {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var $MyArray = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function add($var) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $this-&gt;$var[rand(1,100)] = rand(1,100);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function show($var) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo "\nEcho from Test:\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print_r($this-&gt;$var);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
}<br />
$test = new Test();<br />
$test-&gt;show('MyArray');<br />
$test-&gt;add('MyArray');<br />
$test-&gt;add('MyArray');<br />
$test-&gt;add('MyArray');<br />
$test-&gt;show('MyArray');<br />
<br />
will output<br />
<br />
Echo from Test:<br />
Array<br />
(<br />
)<br />
<br />
Fatal error: Cannot access empty property in /home/webroot/framework_devhost_dk/compiler/test2.php on line 5<br />
<br />
For this to work properly you have to use a construct similar to this:<br />
class Test {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var $MyArray = array();<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function add($var) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $tmp =&amp; $this-&gt;$var; //This is the trick... strange but true ;)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; $tmp[rand(1,100)] = rand(1,100);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; function show($var) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; echo "\nEcho from Test:\n";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print_r($this-&gt;$var);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
<br />
}<br />
$test = new Test();<br />
$test-&gt;show('MyArray');<br />
$test-&gt;add('MyArray');<br />
$test-&gt;add('MyArray');<br />
$test-&gt;add('MyArray');<br />
$test-&gt;show('MyArray');<br />
<br />
Will output:<br />
Echo from Test:<br />
Array<br />
(<br />
)<br />
<br />
Echo from Test:<br />
Array<br />
(<br />
&nbsp;&nbsp;&nbsp; [19] =&gt; 17<br />
&nbsp;&nbsp;&nbsp; [53] =&gt; 57<br />
&nbsp;&nbsp;&nbsp; [96] =&gt; 43<br />
)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75635""></a>
  <div class="note">
   <strong class="user">eduardofleury at uol dot com dot br</strong>
   <a href="#75635" class="date">09-Jun-2007 03:58</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
$foo </span><span class="keyword">= </span><span class="string">'Hello'</span><span class="keyword">; <br />
</span><span class="default">$bar </span><span class="keyword">= </span><span class="string">'World'</span><span class="keyword">;&nbsp; <br />
print </span><span class="default">$foo </span><span class="keyword">. </span><span class="string">" " </span><span class="keyword">. </span><span class="default">$bar</span><span class="keyword">;</span><span class="comment">// Hello World<br />
<br />
</span><span class="default">$foo </span><span class="keyword">= &amp;</span><span class="default">$bar</span><span class="keyword">;<br />
</span><span class="default">$bar </span><span class="keyword">= </span><span class="string">'Hello My World'</span><span class="keyword">;<br />
<br />
print </span><span class="default">$foo</span><span class="keyword">;</span><span class="comment">// Hello My World<br />
</span><span class="keyword">print </span><span class="default">$bar</span><span class="keyword">;</span><span class="comment">// Hello My World<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="75056""></a>
  <div class="note">
   <strong class="user">maghiel at mdijksman dot nl</strong>
   <a href="#75056" class="date">10-May-2007 01:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Note that:<br />
<br />
Call-time pass-by-reference has been deprecated - argument passed by value; If you would like to pass it by reference, modify the declaration of xxxxx. If you would like to enable call-time pass-by-reference, you can set allow_call_time_pass_reference to true in your INI file. However, future versions may not support this any longer</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="74950""></a>
  <div class="note">
   <strong class="user">trucex at gmail dot com</strong>
   <a href="#74950" class="date">05-May-2007 10:49</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In response to Xor and Slava:<br />
<br />
I recommend you read up a bit more on the way PHP handles memory management. Take the following code for example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$data </span><span class="keyword">= </span><span class="default">$_POST</span><span class="keyword">[</span><span class="string">'lotsofdata'</span><span class="keyword">];<br />
</span><span class="default">$data2 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
</span><span class="default">$data3 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
</span><span class="default">$data4 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
</span><span class="default">$data5 </span><span class="keyword">= </span><span class="default">$data</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Assuming we post 10MB of data to this PHP file, what will PHP do with the memory? <br />
<br />
PHP uses a table of sorts that maps variable names to the data that variable refers to in memory. The $_POST superglobal will actually be the first instance of that data in the execution, so it will be the first variable referenced to that data in the memory. It will consume 10MB. Each $data var will simply point to the same data in memory. Until you change that data PHP will NOT duplicate it.<br />
<br />
Passing a variable by value does just what I did with each $data var. There is no significant overhead to assigning a new name to the same data. It is only when you modify the data passed to the function that it must allocate memory for the data. Passing a variable by reference will do essentially the same thing when you pass the data to the function, only modifying it will modify the data that is in the memory already versus copying it to a new location in memory.<br />
<br />
If for learning purposes you choose to disregard the obvious pointlessness in benchmarking the difference between these two methods of passing arguments, you will need to modify the data when it is passed to the function in order to obtain more accurate results.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73663""></a>
  <div class="note">
   <strong class="user">sneskid at hotmail dot com</strong>
   <a href="#73663" class="date">06-Mar-2007 09:47</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
(v5.1.4)<br />
One cool thing about var_dump is it shows which variables are references (when dumping arrays), symbolized by '∫' for int/null, and by '&amp;' for boolean/double/string/array/object. I don't know why the difference in symmmmbolism.<br />
After playing around I found a better way to implement detaching (twas by accident). var_dump can show what's going on.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function &amp;</span><span class="default">detach</span><span class="keyword">(</span><span class="default">$v</span><span class="keyword">=</span><span class="default">null</span><span class="keyword">){return </span><span class="default">$v</span><span class="keyword">;}<br />
<br />
</span><span class="default">$A</span><span class="keyword">=array(</span><span class="string">'x' </span><span class="keyword">=&gt; </span><span class="default">123</span><span class="keyword">, </span><span class="string">'y' </span><span class="keyword">=&gt; </span><span class="default">321</span><span class="keyword">);<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">] = &amp;</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">];<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">);<br />
</span><span class="comment">/* x became it's own reference...<br />
array(2) {<br />
&nbsp; ["x"]=&gt; ∫(123)<br />
&nbsp; ["y"]=&gt; int(321)<br />
}*/<br />
<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'y'</span><span class="keyword">]=&amp;</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">];<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">);<br />
</span><span class="comment">/* now both are references<br />
array(2) {<br />
&nbsp; ["x"]=&gt; ∫(123)<br />
&nbsp; ["y"]=&gt; ∫(123)<br />
}*/<br />
<br />
</span><span class="default">$z </span><span class="keyword">= </span><span class="string">'hi'</span><span class="keyword">;<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'y'</span><span class="keyword">]=&amp;</span><span class="default">detach</span><span class="keyword">(&amp;</span><span class="default">$z</span><span class="keyword">);<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">);<br />
</span><span class="comment">/* x is still a reference, y and z share<br />
array(2) {<br />
&nbsp; ["x"]=&gt; ∫(123)<br />
&nbsp; ["y"]=&gt; &amp;string(2) "hi"<br />
}*/<br />
<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">] = </span><span class="default">$A</span><span class="keyword">[</span><span class="string">'x'</span><span class="keyword">];<br />
</span><span class="default">$A</span><span class="keyword">[</span><span class="string">'y'</span><span class="keyword">]=&amp;</span><span class="default">detach</span><span class="keyword">();<br />
</span><span class="default">var_dump</span><span class="keyword">(</span><span class="default">$A</span><span class="keyword">,</span><span class="default">$z</span><span class="keyword">);<br />
</span><span class="comment">/* x returned to normal, y is on its own, z is still "hi"<br />
array(2) {<br />
&nbsp; ["x"]=&gt; int(123)<br />
&nbsp; ["y"]=&gt; NULL<br />
}*/<br />
</span><span class="default">?&gt;<br />
</span><br />
For detach to work you need to use '&amp;' in the function declaration, and every time you call it.<br />
<br />
Use this when you know a variable is a reference, and you want to assign a new value without effecting other vars referencing that piece of memory. You can initialize it with a new constant value, or variable, or new reference all in once step.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="70852""></a>
  <div class="note">
   <strong class="user">sneskid at hotmail dot com</strong>
   <a href="#70852" class="date">01-Nov-2006 06:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in addition to what 'jw at jwscripts dot com' wrote about unset; it can also be used to "detach" the variable alias so that it may work on a unique piece of memory again.<br />
<br />
here's an example<br />
<br />
<span class="default">&lt;?php<br />
define</span><span class="keyword">(</span><span class="string">'NL'</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">);<br />
<br />
</span><span class="default">$v1 </span><span class="keyword">= </span><span class="string">'shared'</span><span class="keyword">;<br />
</span><span class="default">$v2 </span><span class="keyword">= &amp;</span><span class="default">$v1</span><span class="keyword">;<br />
</span><span class="default">$v3 </span><span class="keyword">= &amp;</span><span class="default">$v2</span><span class="keyword">;<br />
</span><span class="default">$v4 </span><span class="keyword">= &amp;</span><span class="default">$v3</span><span class="keyword">;<br />
<br />
echo </span><span class="string">'before:'</span><span class="keyword">.</span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v1=' </span><span class="keyword">. </span><span class="default">$v1 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v2=' </span><span class="keyword">. </span><span class="default">$v2 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v3=' </span><span class="keyword">. </span><span class="default">$v3 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v4=' </span><span class="keyword">. </span><span class="default">$v4 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
<br />
</span><span class="comment">// detach messy<br />
</span><span class="default">$detach </span><span class="keyword">= </span><span class="default">$v1</span><span class="keyword">;<br />
unset(</span><span class="default">$v1</span><span class="keyword">);<br />
</span><span class="default">$v1 </span><span class="keyword">= </span><span class="default">$detach</span><span class="keyword">;<br />
<br />
</span><span class="comment">// detach pretty, but slower<br />
</span><span class="keyword">eval(</span><span class="default">detach</span><span class="keyword">(</span><span class="string">'$v2'</span><span class="keyword">));<br />
<br />
</span><span class="default">$v1 </span><span class="keyword">.= </span><span class="string">'?'</span><span class="keyword">;<br />
</span><span class="default">$v2 </span><span class="keyword">.= </span><span class="string">' no more'</span><span class="keyword">;<br />
</span><span class="default">$v3 </span><span class="keyword">.= </span><span class="string">' sti'</span><span class="keyword">;<br />
</span><span class="default">$v4 </span><span class="keyword">.= </span><span class="string">'ll'</span><span class="keyword">;<br />
<br />
echo </span><span class="default">NL</span><span class="keyword">.</span><span class="string">'after:'</span><span class="keyword">.</span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v1=' </span><span class="keyword">. </span><span class="default">$v1 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v2=' </span><span class="keyword">. </span><span class="default">$v2 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v3=' </span><span class="keyword">. </span><span class="default">$v3 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
echo </span><span class="string">'v4=' </span><span class="keyword">. </span><span class="default">$v4 </span><span class="keyword">. </span><span class="default">NL</span><span class="keyword">;<br />
<br />
function </span><span class="default">detach</span><span class="keyword">(</span><span class="default">$v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">= </span><span class="string">'$detach = ' </span><span class="keyword">. </span><span class="default">$v </span><span class="keyword">. </span><span class="string">';'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">.= </span><span class="string">'unset('</span><span class="keyword">.</span><span class="default">$v</span><span class="keyword">.</span><span class="string">');'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$e </span><span class="keyword">.= </span><span class="default">$v </span><span class="keyword">. </span><span class="string">' = $detach;'</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$e</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
output {<br />
before:<br />
v1=shared<br />
v2=shared<br />
v3=shared<br />
v4=shared<br />
<br />
after:<br />
v1=shared?<br />
v2=shared no more<br />
v3=shared still<br />
v4=shared still<br />
}<br />
<br />
<a href="http://www.obdev.at/developers/articles/00002.html says there" rel="nofollow" target="_blank">http://www.obdev.at/developers/articles/00002.html says there</a>'s no such thing as an "object reference" in PHP, but with detaching it becomes possible.<br />
<br />
Hopefully detach, or something like it, will become a language construct in the future.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="68747""></a>
  <div class="note">
   <strong class="user">gunter dot sammet at gmail dot com</strong>
   <a href="#68747" class="date">09-Aug-2006 10:23</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I tried to create an array with n depth using a recursive function passing array references around. So far I haven't had much luck and I couldn't find anything on the web. So I ended up using eval() and it seems to work well:<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="keyword">foreach(</span><span class="default">array_keys</span><span class="keyword">(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">quantity_array</span><span class="keyword">) AS </span><span class="default">$key</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if(</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">quantity_array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] &gt; </span><span class="default">0</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$combinations </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'-'</span><span class="keyword">, </span><span class="default">$key</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$eval_string </span><span class="keyword">= </span><span class="string">'$eval_array'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach(</span><span class="default">array_keys</span><span class="keyword">(</span><span class="default">$combinations</span><span class="keyword">) AS </span><span class="default">$key2</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$option_key_value </span><span class="keyword">= </span><span class="default">explode</span><span class="keyword">(</span><span class="string">'_'</span><span class="keyword">, </span><span class="default">$combinations</span><span class="keyword">[</span><span class="default">$key2</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$eval_string </span><span class="keyword">.= </span><span class="string">'['</span><span class="keyword">.</span><span class="default">$option_key_value</span><span class="keyword">[</span><span class="default">0</span><span class="keyword">].</span><span class="string">']['</span><span class="keyword">.</span><span class="default">$option_key_value</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">].</span><span class="string">']'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$eval_string </span><span class="keyword">.= </span><span class="string">' = '</span><span class="keyword">.</span><span class="default">$this</span><span class="keyword">-&gt;</span><span class="default">quantity_array</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">].</span><span class="string">';'</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eval(</span><span class="default">$eval_string</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
</span><span class="default">?&gt;<br />
</span><br />
This produces an n dimensional array that will be available in the $eval_array variable. Hope it helps somebody!</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60986""></a>
  <div class="note">
   <strong class="user">Ed</strong>
   <a href="#60986" class="date">22-Jan-2006 08:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Responding to Slava Kudinov.&nbsp; The only reason why your script takes longer when you pass by reference is that you do not at all modify the array that your passing to your functions.&nbsp; If you do that the diffrences in execution time will be a lot smaller.&nbsp; In fact&nbsp; passing by reference will be faster if just by a little bit.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="60979""></a>
  <div class="note">
   <strong class="user">Slava Kudinov &lt;skudinov gmail com&gt;</strong>
   <a href="#60979" class="date">22-Jan-2006 11:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In addition to the "array vs &amp;array" example below, php 5.1.2. It seems passing an array by reference slower than by value, consider:<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">test_ref</span><span class="keyword">(&amp;</span><span class="default">$arr</span><span class="keyword">) {<br />
&nbsp;&nbsp; </span><span class="default">$size </span><span class="keyword">= </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
&nbsp;&nbsp; for(</span><span class="default">$n</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">&lt;</span><span class="default">$size</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">$x </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
function </span><span class="default">test_val</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">) {<br />
&nbsp;&nbsp; </span><span class="default">$size </span><span class="keyword">= </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$arr</span><span class="keyword">);<br />
&nbsp;&nbsp; for(</span><span class="default">$n</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">&lt;</span><span class="default">$size</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="default">$x </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; }<br />
}<br />
<br />
</span><span class="comment">// fill array<br />
</span><span class="keyword">for(</span><span class="default">$n</span><span class="keyword">=</span><span class="default">0</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">&lt;</span><span class="default">2000</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">++) {<br />
&nbsp;&nbsp; </span><span class="default">$ar</span><span class="keyword">[] = </span><span class="string">"test"</span><span class="keyword">.</span><span class="default">$n</span><span class="keyword">;<br />
}<br />
</span><span class="default">$time </span><span class="keyword">= </span><span class="default">microtime</span><span class="keyword">();<br />
</span><span class="default">test_ref</span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br />
echo </span><span class="string">"&lt;br /&gt;The function using a reference took "</span><span class="keyword">.(</span><span class="default">microtime</span><span class="keyword">() - </span><span class="default">$time</span><span class="keyword">).</span><span class="string">" s"</span><span class="keyword">;<br />
</span><span class="default">$time </span><span class="keyword">= </span><span class="default">microtime</span><span class="keyword">();<br />
</span><span class="default">test_val</span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br />
echo </span><span class="string">"&lt;br /&gt;The funktion using a value took: "</span><span class="keyword">.(</span><span class="default">microtime</span><span class="keyword">() - </span><span class="default">$time</span><span class="keyword">).</span><span class="string">" s"</span><span class="keyword">;<br />
echo </span><span class="string">"&lt;br /&gt;Done"</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span>output:<br />
The function using a reference took 0.002694 s<br />
The funktion using a value took: 0.000847 s</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="59611""></a>
  <div class="note">
   <strong class="user">cesoid at yahoo dot com</strong>
   <a href="#59611" class="date">11-Dec-2005 03:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Responding to post from nathan (who was responding to iryoku).<br />
<br />
It is important to note the difference between what php is doing from the programmer's point of view and what it is doing internally. The note that nathan refers to, about how (for example) $something = $this makes a "copy" of the current object, is talking about making a "copy" from the programmer's perspective. That is, for the programmer, for all practical purposes, $something is a copy, even if internally nothing has been copied yet. For example, changing the data in member $something-&gt;somethingVar will not change your current object's data (i.e. it will not change $this-&gt;somethingVar).<br />
<br />
What it does internally is a totally different story. I've tested&nbsp; "copying" an object which contains a 200,000 element array, it takes almost no time at all until you finally change something in one of the copies, because internally it only makes the copy when it becomes necessary. The original assignment takes less than a millisecond, but when I alter one of the copies, it takes something like a quarter of a second. But this only happens if I alter the 200,000 element array, if I alter a single integer of the object, it takes less than a microsecond again, so the interpretter seems to be smart enough to make copies of some of the objects variables and not others.<br />
<br />
The result is that when you change a function to pass by reference, it will only become more efficient if, inside the function, the passed variable is having its data altered, in which case passing by reference causes your code to alter the data of the original copy. If you are passing an object and calling a function in that object, that function may alter the object without you even knowing, which means that you should pass an object by reference as long as it is ok for the original copy to be effected by what you do with the object inside the function.<br />
<br />
I think the real moral of the story is this:<br />
1) Pass by reference anything that should refer to and affect the original copy.<br />
2) Pass not by reference things that will definitely not be altered in the function (for an object, it may be impossible to know whether it alters itself upon calling one of its functions).<br />
3) If something needs to be altered inside a function without effecting the original copy, pass it not by reference, and pass the smallest practical part that needs to change, rather than passing, for example, a huge array of which one little integer will be altered.<br />
<br />
Or a shorter version: Only pass things by reference when you need to refer to the original copy! (And don't pass huge arrays or long strings when you need to change just a small part of them!)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57732""></a>
  <div class="note">
   <strong class="user">mramirez (at) star (minus) dev (dot) com</strong>
   <a href="#57732" class="date">12-Oct-2005 06:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
For php programmers that come from pascal,<br />
in object pascal (delphi),<br />
variable references are used with the "absolute" keyword.<br />
<br />
PHP example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">global </span><span class="default">$myglobal</span><span class="keyword">;<br />
<br />
</span><span class="default">$myglobal </span><span class="keyword">= </span><span class="default">5</span><span class="keyword">;<br />
<br />
function </span><span class="default">test</span><span class="keyword">()<br />
{<br />
global </span><span class="default">$myglobal</span><span class="keyword">;<br />
<br />
</span><span class="comment">/*local*/ </span><span class="default">$mylocal </span><span class="keyword">=&amp; </span><span class="default">$myglobal</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"local: " </span><span class="keyword">. </span><span class="default">$mylocal </span><span class="keyword">. </span><span class="string">"\n"</span><span class="keyword">;<br />
echo </span><span class="string">"gloal: " </span><span class="keyword">. </span><span class="default">$myglobal </span><span class="keyword">. </span><span class="string">"\n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">test</span><span class="keyword">();<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Pascal example:<br />
<br />
program dontcare;<br />
<br />
var myglobal: integer;<br />
<br />
procedure test;<br />
var mylocal ABSOLUTE myglobal;<br />
begin<br />
&nbsp; write("local: ", mylocal);<br />
&nbsp; write("global: ", myglobal);<br />
end;<br />
<br />
begin<br />
&nbsp; myglobal := 5;<br />
&nbsp; test;<br />
end.<br />
<br />
By the way, a "local" keyword in php for local variables,<br />
could be welcome :-)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57550""></a>
  <div class="note">
   <strong class="user">y007pig at yahoo dot com dot cn</strong>
   <a href="#57550" class="date">07-Oct-2005 08:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In reply to pike at kw dot nl, '&amp;' is only apply to PHP 4.<br />
PHP 5 changed the behavior and the object is defaultly passed by references and if you turn on E_STRICT, you will get a notice:<br />
Strict Standards: Assigning the return value of new by reference is deprecated in xxxx<br />
If you want to *copy* object in PHP 5, use object clone.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57365""></a>
  <div class="note">
   <strong class="user">pike at kw dot nl</strong>
   <a href="#57365" class="date">01-Oct-2005 03:08</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
if your object seems to "forget" assignments you make after instantiation, realize that in<br />
<br />
$foo = new Bar()<br />
<br />
the variable on the left hand is a *copy* of the variable on the right hand. As a result, &amp; references made during instantiation may point to the righthandside version of Bar() and not to $foo. you'd better use<br />
<br />
$foo = &amp; new Bar()</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56115""></a>
  <div class="note">
   <strong class="user">php at REMOVEMEkennel17 dot co dot uk</strong>
   <a href="#56115" class="date">24-Aug-2005 03:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I found a very useful summary of how references work in PHP4 (and some of the common pitfalls) in this article: <a href="http://www.obdev.at/developers/articles/00002.html" rel="nofollow" target="_blank">http://www.obdev.at/developers/articles/00002.html</a><br />
<br />
It deals with some subtle situations and I recommend it to anyone having difficulty with their references.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="55766""></a>
  <div class="note">
   <strong class="user">grayson at uiuc dot edu</strong>
   <a href="#55766" class="date">12-Aug-2005 05:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I found a subtle feature of references that caused a bug in one of my PHP applications.&nbsp; In short, if an object passes one of its members to an external function that takes a reference as an argument, the external function can turn that member into a reference to an anonymous point in memory.<br />
<br />
Why is this a problem?&nbsp; Later, when you copy the object with $a = $b, the copy and the original share memory.<br />
<br />
Solution: If you want to have a function that uses references to modify a member of your object, your object should never pass the member to the function directly. It should first make a copy of the member. Then give that copy to the function.&nbsp; Then copy the new value of that copy in to your original object member.<br />
<br />
Below is some code that can reporoduce the this feature and demonstrate the workaround.<br />
<br />
function modify1 ( &amp;$pointer_obj ){<br />
&nbsp; $pointer_obj-&gt;property = 'Original Value';<br />
}<br />
<br />
function modify2 ( &amp;$pointer_obj ){<br />
&nbsp; $newObj-&gt;property = 'Original Value';<br />
&nbsp; $pointer_obj = $newObj;<br />
}<br />
<br />
class a {<br />
&nbsp; var $i;&nbsp;&nbsp; # an object with properties<br />
<br />
&nbsp; function corrupt1(){<br />
&nbsp;&nbsp;&nbsp; modify1 ($this-&gt;i);<br />
&nbsp; }<br />
<br />
&nbsp; function doNotCorrupt1(){<br />
&nbsp;&nbsp;&nbsp; $tmpi = $this-&gt;i;<br />
&nbsp;&nbsp;&nbsp; modify1 ($tmpi);<br />
&nbsp;&nbsp;&nbsp; $this-&gt;i = $tmpi;<br />
&nbsp; }<br />
<br />
&nbsp; function corrupt2(){<br />
&nbsp;&nbsp;&nbsp; modify2 ($this-&gt;i);<br />
&nbsp; }<br />
<br />
&nbsp; function doNotCorrupt2(){<br />
&nbsp;&nbsp;&nbsp; $tmpi = $this-&gt;i;<br />
&nbsp;&nbsp;&nbsp; modify2 ($tmpi);<br />
&nbsp;&nbsp;&nbsp; $this-&gt;i = $tmpi;<br />
&nbsp; }<br />
<br />
}<br />
<br />
$functions = array ('corrupt1', 'corrupt2', 'doNotCorrupt1', 'doNotCorrupt2');<br />
<br />
foreach ($functions as $func){<br />
<br />
&nbsp; $original = new a;<br />
<br />
&nbsp; ### Load some data in to the orginal with one of the four $functions<br />
&nbsp; $original-&gt;$func();<br />
<br />
&nbsp; $copy = $original;<br />
<br />
&nbsp; $copy-&gt;i-&gt;property = "Changed after the copy was made.";<br />
<br />
&nbsp; echo "\n{$func}: \$original-&gt;i-&gt;property = '" . $original-&gt;i-&gt;property . "'";<br />
}<br />
<br />
The script generates output:<br />
<br />
corrupt1: $original-&gt;i-&gt;property = 'Changed after the copy was made.'<br />
corrupt2: $original-&gt;i-&gt;property = 'Changed after the copy was made.'<br />
doNotCorrupt1: $original-&gt;i-&gt;property = 'Original Value'<br />
doNotCorrupt2: $original-&gt;i-&gt;property = 'Original Value'</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52926""></a>
  <div class="note">
   <strong class="user">rlynch at lynchmarks dot com</strong>
   <a href="#52926" class="date">17-May-2005 11:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
And, further...<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; $intSize </span><span class="keyword">= </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$arrData</span><span class="keyword">);<br />
<br />
&nbsp;&nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$intSize</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="comment">// Do stuff<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
</span><span class="default">?&gt;</span> <br />
<br />
Can be shortened even further by using the often overlooked 'decrement until zero' concept.&nbsp; I don't much like decrementing to get a job done, but it can make a lot of sense when the evaluation-of-doneness is time-costly:<br />
<br />
<span class="default">&lt;?php<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$arrData</span><span class="keyword">); </span><span class="default">$i</span><span class="keyword">-- &gt; </span><span class="default">0 </span><span class="keyword">; ) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// Do stuff&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">}<br />
</span><span class="default">?&gt;</span> <br />
<br />
One less variable to toss on the heap.&nbsp; NOTE that rather inconveniently, the $i goes to and hits zero only in the case where it starts out positive.&nbsp; When it is zero to begin with, it will become -1.&nbsp; Bug or feature?&nbsp; I've used it as a feature as a quick test of whether the $arrData array was empty to begin with.&nbsp; If you don't plan on using $i after the loop for anything, it makes no difference.<br />
<br />
If you need to be doing something ascending-sequential though, then the temporary variable suggestions that others have made makes the most sense.<br />
<br />
Finally (and important) ... if the $arrData array is somehow being dynamically modified in size due to the //Do-Stuff routine underneath, then you may have little-to-no recourse except to use the sizeof() method/function in the loop.&nbsp; Or, keep up the temporary variable in the loop as you push and pop things into and off the array.&nbsp; <br />
<br />
(sigh... this is the notable failing of deeply linked internal data structures: to figure out the size of any linked list of arbitrarily composed elements, the entire array needs to be "walked" every time the sizeof() or count() method is used.&nbsp; But compared to the flexibility of associative arrays, the cost is mitigated by careful use.)<br />
<br />
GoatGuy</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50994""></a>
  <div class="note">
   <strong class="user">nslater at gmail dot com</strong>
   <a href="#50994" class="date">16-Mar-2005 04:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
In addition to the note made by "Francis dot a at gmx dot net" you should not normally be using a function such as sizeof() or count() in a control structure such as FOR because the same value is being calculated repeatedly for each iteration. This can slow things down immensely, regardless of whether you pass by value or reference.<br />
<br />
It is generally much better to calculate the static values before the defining the looping control structure.<br />
<br />
Example:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$intSize </span><span class="keyword">= </span><span class="default">sizeof</span><span class="keyword">(</span><span class="default">$arrData</span><span class="keyword">);<br />
<br />
for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">$intSize</span><span class="keyword">; </span><span class="default">$n</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// Do stuff<br />
</span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="50950""></a>
  <div class="note">
   <strong class="user">Carlos</strong>
   <a href="#50950" class="date">14-Mar-2005 09:09</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
in the example below, you would get the same result if you change the function to something like:<br />
<br />
function test_ref(&amp;$arr) {<br />
&nbsp;&nbsp; $time = time();<br />
&nbsp;&nbsp; $size = sizeof($arr);&nbsp; &nbsp; &nbsp;&nbsp; // &lt;--- this makes difference...<br />
&nbsp;&nbsp; for($n=0; $n&lt;$size; $n++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; $x = 1;<br />
&nbsp;&nbsp; }<br />
<br />
&nbsp;&nbsp; echo "&lt;br /&gt;The function using a reference took ".(time() - $time)." s";<br />
}</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49829""></a>
  <div class="note">
   <strong class="user">Francis dot a at gmx dot net</strong>
   <a href="#49829" class="date">09-Feb-2005 07:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I don't know if this is a bug (I'm using PHP 5.01) but you should be careful when using&nbsp; references on arrays.<br />
I had a for-loop that was incredibly slow and it took me some time to find out that most of the time was wasted with the&nbsp; function sizeof() at every loop, and even more time I spent&nbsp; finding out that this problem it must be somehow related to the fact, that I used a reference of the array. Take a look at the following example:<br />
<br />
function test_ref(&amp;$arr) {<br />
&nbsp;&nbsp;&nbsp; $time = time();<br />
&nbsp;&nbsp;&nbsp; for($n=0; $n&lt;sizeof($arr); $n++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $x = 1;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; echo "&lt;br /&gt;The function using a reference took ".(time() - $time)." s";<br />
}<br />
<br />
function test_val($arr) {<br />
&nbsp;&nbsp;&nbsp; $time = time();<br />
&nbsp;&nbsp;&nbsp; for($n=0; $n&lt;sizeof($arr); $n++) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; $x = 1;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; echo "&lt;br /&gt;The funktion using a value took: ".(time() - $time)." s";<br />
}<br />
<br />
// fill array<br />
for($n=0; $n&lt;2000; $n++) {<br />
&nbsp;&nbsp;&nbsp; $ar[] = "test".$n;<br />
}<br />
<br />
test_ref($ar);<br />
test_val($ar);<br />
echo "&lt;br /&gt;Done";<br />
<br />
When I tested it, the first function was done after 9 seconds, while the second (although the array must be copied) was done in not even one.<br />
<br />
The difference is inproportional smaller when the array size is reduced:<br />
When using 1000 loops the first function was running for 1 second, when using 4000 it wasn't even done after 30 Seconds.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46590""></a>
  <div class="note">
   <strong class="user">jw at jwscripts dot com</strong>
   <a href="#46590" class="date">16-Oct-2004 02:18</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Re-using variables which where references before, without unsetting them first, leads to unexpected behaviour.<br />
<br />
The following code:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$numbers </span><span class="keyword">= array();<br />
<br />
for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&lt; </span><span class="default">4</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">++) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$numbers</span><span class="keyword">[] = </span><span class="default">null</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$num </span><span class="keyword">= </span><span class="default">count</span><span class="keyword">(</span><span class="default">$numbers</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$index </span><span class="keyword">=&amp; </span><span class="default">$numbers</span><span class="keyword">[</span><span class="default">$num </span><span class="keyword">? </span><span class="default">$num </span><span class="keyword">- </span><span class="default">1 </span><span class="keyword">: </span><span class="default">$num</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$index </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">;<br />
}<br />
<br />
foreach (</span><span class="default">$numbers </span><span class="keyword">as </span><span class="default">$index</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; print </span><span class="string">"</span><span class="default">$index</span><span class="string">\n"</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Does not produce:<br />
1<br />
2<br />
3<br />
<br />
But instead:<br />
1<br />
2<br />
2<br />
<br />
Applying unset($index) before re-using the variable fixes this and the expected list will be produced:<br />
1<br />
2<br />
3</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45696""></a>
  <div class="note">
   <strong class="user">hkmaly at bigfoot dot com</strong>
   <a href="#45696" class="date">15-Sep-2004 05:11</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
It seems like PHP has problems with references, like that it can't work properly with circular references or free properly structure with more references. See <a href="http://bugs.php.net/?id=30053." rel="nofollow" target="_blank">http://bugs.php.net/?id=30053.</a><br />
<br />
I have big problem with this and I hope someone from PHP add proper warning with explanation IN manual, if they can't fix it.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="44203""></a>
  <div class="note">
   <strong class="user">jlaing at gmail dot com</strong>
   <a href="#44203" class="date">18-Jul-2004 05:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
While trying to do object references with the special $this variable I found that this will not work:<br />
class foo {<br />
&nbsp; function bar() {<br />
&nbsp;&nbsp;&nbsp; ...<br />
&nbsp;&nbsp;&nbsp; $this =&amp; $some_other_foo_obj;<br />
&nbsp; }<br />
}<br />
<br />
If you want to emulate this functionality you must iterate through the vars of the class and assign references like this:<br />
<br />
$vars = get_class_vars('foo');<br />
foreach (array_keys($vars) as $field) {<br />
&nbsp; $this-&gt;$field =&amp; $some_other_foo_obj-&gt;$field;<br />
}<br />
<br />
Now if you modify values within $this they will be modified within $some_other_foo_obj and vice versa.<br />
<br />
Hope that helps some people!<br />
<br />
p.s.<br />
developer at sirspot dot com's note about object references doesn't seem correct to me.<br />
<br />
&nbsp; $temp =&amp; $object;<br />
&nbsp; $object =&amp; $temp-&gt;getNext();<br />
<br />
Does the same exact thing as:<br />
<br />
&nbsp; $object =&amp; $object-&gt;getNext();<br />
<br />
when you refernce $temp to $object all it does is make $temp an alias to the same memory as $object, so doing $temp-&gt;getNext(); and $object-&gt;getNext(); are calling the same function on the same object.&nbsp; Try it out if you don't believe me.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="42192""></a>
  <div class="note">
   <strong class="user">thenewparadigm at hotmail dot com</strong>
   <a href="#42192" class="date">07-May-2004 09:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
one very useful aspect for reference that i don't think i saw documented was the ability to skip a few steps with objects stored in objects.<br />
<br />
for example:<br />
<br />
assuming the object structure is correctly constructed (and mind you i haven't tried this in php, but it does work in most other high-end programming languages), instead of using this structure to get a variable/function<br />
<br />
//start<br />
<br />
$obj1 -&gt; obj2 -&gt; obj3 -&gt; varX = 0;<br />
$obj1 -&gt; obj2 -&gt; obj3 -&gt; varY = 0;<br />
$obj1 -&gt; obj2 -&gt; obj3 -&gt; functionX();<br />
$obj1 -&gt; obj2 -&gt; obj3 -&gt; functionY();<br />
<br />
//end<br />
<br />
you can use this method:<br />
<br />
//start<br />
<br />
$tempObj = &amp; $obj1 -&gt; obj2 -&gt; obj3;<br />
<br />
$tempObj -&gt; varX = 0;<br />
$tempObj -&gt; varY = 0;<br />
$tempObj -&gt; functionX();<br />
$tempObj -&gt; functionY();<br />
<br />
//end<br />
<br />
note, if you want to use a shortcut variable to modify the original object you must include the ampersand (&amp;) to reference the variable, otherwise if you used this line of code<br />
<br />
//start<br />
<br />
$tempObj = $obj1 -&gt; obj2 -&gt; obj3;<br />
<br />
//end<br />
<br />
any changes you make to $tempObj will not change the original object and may compromise the object structure, not to mention that it takes up extra memory.&nbsp; however, if you are just using the shortcut variable for read-only purposes, not using a reference wont cause any problems.<br />
<br />
another alternative in programming languages is the 'with' structure as seen below<br />
<br />
//start<br />
<br />
with($obj1 -&gt; obj2 -&gt; obj3) {<br />
&nbsp;&nbsp;&nbsp; varX = 0;<br />
&nbsp;&nbsp;&nbsp; varY = 0;<br />
&nbsp;&nbsp;&nbsp; functionX();<br />
&nbsp;&nbsp;&nbsp; functionY();<br />
}<br />
<br />
//end<br />
<br />
however, i don't expect this will work because as far as i've seen the 'with' structure is not supported in php.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41300""></a>
  <div class="note">
   <strong class="user">nathan</strong>
   <a href="#41300" class="date">06-Apr-2004 07:53</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
On the post that says php4 automagically makes references, this appears to *not* apply to objects:<br />
<br />
<a href="http://www.php.net/manual/en/language.references.whatdo.php" rel="nofollow" target="_blank">http://www.php.net/manual/en/language.references.whatdo.php</a><br />
<br />
"Note:&nbsp; Not using the &amp; operator causes a copy of the object to be made. If you use $this in the class it will operate on the current instance of the class. The assignment without &amp; will copy the instance (i.e. the object) and $this will operate on the copy, which is not always what is desired. Usually you want to have a single instance to work with, due to performance and memory consumption issues."</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="41114""></a>
  <div class="note">
   <strong class="user">iryoku at terra dot es</strong>
   <a href="#41114" class="date">30-Mar-2004 07:22</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You should have in mind that php4 keep assigned variables "automagically" referenced until they are overwritten. So the variable copy is not executed on assignment, but on modification. Say you have this:<br />
<br />
$var1 = 5;<br />
$var2 = $var1; // In this point these two variables share the same memory location<br />
$var1 = 3; // Here $var1 and $var2 have they own memory locations with values 3 and 5 respectively<br />
<br />
Don't use references in function parameters to speed up aplications, because this is automatically done. I think that this should be in the manual, because it can lead to confusion.<br />
<br />
More about this here:<br />
<a href="http://www.zend.com/zend/art/ref-count.php" rel="nofollow" target="_blank">http://www.zend.com/zend/art/ref-count.php</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="39588""></a>
  <div class="note">
   <strong class="user">developer at sirspot dot com</strong>
   <a href="#39588" class="date">03-Feb-2004 07:30</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Since references are more like hardlinks than pointers, it is not possible to change a reference to an object by using that same reference.&nbsp; For example:<br />
<br />
The following WILL NOT WORK as expected and may even crash the PHP interpreter:<br />
<br />
$object =&amp; $object-&gt;getNext();<br />
<br />
However, by changing the previous statement to use a temporary reference, this WILL WORK:<br />
<br />
$temp =&amp; $object;<br />
$object =&amp; $temp-&gt;getNext();</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="language.generators.comparison.html">ジェネレータと Iterator オブジェクトとの比較</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="language.references.whatare.html">リファレンスとは?</a></div>
 <div class="up"><a href="langref.html">言語リファレンス</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
