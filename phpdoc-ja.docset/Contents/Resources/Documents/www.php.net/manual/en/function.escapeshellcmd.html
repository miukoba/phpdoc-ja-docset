<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>シェルのメタ文字をエスケープする</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.escapeshellarg.html">escapeshellarg</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.exec.html">exec</a></div>
 <div class="up"><a href="ref.exec.html">プログラム実行関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.escapeshellcmd" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">escapeshellcmd</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">escapeshellcmd</span> &mdash; <span class="dc-title">シェルのメタ文字をエスケープする</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.escapeshellcmd-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">string</span> <span class="methodname"><strong>escapeshellcmd</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$command</code></span>
   )</div>

  <p class="para rdfs-comment">
    <span class="function"><strong>escapeshellcmd()</strong></span> は、文字列中においてシェルコマンドを
   だまして勝手なコマンドを実行する可能性がある文字をエスケープします。
   この関数は、ユーザーに入力されたデータを関数
    <span class="function"><a href="function.exec.html" class="function">exec()</a></span> または  <span class="function"><a href="function.system.html" class="function">system()</a></span> または、
   <a href="language.operators.execution.html" class="link">バックティック演算子</a>
   に渡す前に全てエスケープを行う場合に使用するべきです。
  </p>
  <p class="para">
   <em>#&amp;;`|*?~&lt;&gt;^()[]{}$\</em>、<em>\x0A</em>
   および <em>\xFF</em> については、その文字の前にバックスラッシュが
   追加されます。<em>&#039;</em> および <em>&quot;</em>
   は、対になっていない場合にのみエスケープされます。Windows では、
   これらの文字に加えて <em>%</em> がスペースに置き換えられます。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.escapeshellcmd-parameters">
  <h3 class="title">パラメータ</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><em><code class="parameter">command</code></em></span>
     <dd>

      <p class="para">
       エスケープされるコマンド
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.escapeshellcmd-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
   エスケープされた文字列
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.escapeshellcmd-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-3656">
    <p><strong>例1  <span class="function"><strong>escapeshellcmd()</strong></span> の例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br /></span><span style="color: #FF8000">//&nbsp;意図的に、任意の数の引数を指定できるようにしています<br /></span><span style="color: #0000BB">$command&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">'./configure&nbsp;'</span><span style="color: #007700">.</span><span style="color: #0000BB">$_POST</span><span style="color: #007700">[</span><span style="color: #DD0000">'configure_options'</span><span style="color: #007700">];<br /><br /></span><span style="color: #0000BB">$escaped_command&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">escapeshellcmd</span><span style="color: #007700">(</span><span style="color: #0000BB">$command</span><span style="color: #007700">);<br />&nbsp;<br /></span><span style="color: #0000BB">system</span><span style="color: #007700">(</span><span style="color: #0000BB">$escaped_command</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.escapeshellcmd-notes">
   <div class="warning"><strong class="warning">警告</strong>
    <p class="para">
      <span class="function"><strong>escapeshellcmd()</strong></span>
     はコマンド文字列全体に適用しなければなりません。
     また、そうしたところで、まだ任意の数の引数を渡すことによる攻撃を許してしまいます。
     単一の引数をエスケープするには、かわりに  <span class="function"><a href="function.escapeshellarg.html" class="function">escapeshellarg()</a></span>
     を使わねばなりません。
    </p>
   </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.escapeshellcmd-seealso">
  <h3 class="title">参考</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"> <span class="function"><a href="function.escapeshellarg.html" class="function" rel="rdfs-seeAlso">escapeshellarg()</a> - シェル引数として使用される文字列をエスケープする</span></li>
    <li class="member"> <span class="function"><a href="function.exec.html" class="function" rel="rdfs-seeAlso">exec()</a> - 外部プログラムを実行する</span></li>
    <li class="member"> <span class="function"><a href="function.popen.html" class="function" rel="rdfs-seeAlso">popen()</a> - プロセスへのファイルポインタをオープンする</span></li>
    <li class="member"> <span class="function"><a href="function.system.html" class="function" rel="rdfs-seeAlso">system()</a> - 外部プログラムを実行し、出力を表示する</span></li>
    <li class="member"><a href="language.operators.execution.html" class="link">バックティック演算子</a></li>
   </ul>
  </p>
 </div>

</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="108322""></a>
  <div class="note">
   <strong class="user">phpcomment at reversiblemaps dot ath dot cx</strong>
   <a href="#108322" class="date">17-Apr-2012 08:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
escaping strings for a shell is tricky.<br />
<br />
&nbsp; If your target system is windows give up now.&nbsp; windows isn't even self consisitent in how to escape stuff.<br />
<br />
&nbsp; if unix convert everything to octal - although this is hardest to implement it's the easiest to implement correctly - there are no special cases..<br />
.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="102152""></a>
  <div class="note">
   <strong class="user">nicholas at nicholaswilson dot me dot uk</strong>
   <a href="#102152" class="date">30-Jan-2011 04:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
There is a quirk to be aware of regarding use of echo. If you have a command which you want to execute which takes input from STDIN, you would normally do:<br />
<br />
<span class="default">&lt;?php $output </span><span class="keyword">= </span><span class="default">shell_exec</span><span class="keyword">(</span><span class="string">"echo </span><span class="default">$input</span><span class="string"> | /the/command"</span><span class="keyword">); </span><span class="default">?&gt;<br />
</span><br />
Unfortunately, this is a *bad idea* and will make your script unportable, providing a very hard-to-trace bug on some systems. Depending on how the server is set up, /bin/sh will either call /bin/bash or /bin/dash, and these have very different versions of echo. Never use echo; use printf instead which is consistent. How do you escape for printf? Do this:<br />
<br />
<span class="default">&lt;?php<br />
$input </span><span class="keyword">= </span><span class="string">'string to be passed *exactly* to the command'</span><span class="keyword">;<br />
</span><span class="comment">//Escape only what is needed to get by PHP's parser; we want<br />
//the string data PHP is holding in its buffer to be passed<br />
//exactly to stdin buffer of the command.<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">'%'</span><span class="keyword">), array(</span><span class="string">'\\\\'</span><span class="keyword">, </span><span class="string">'%%'</span><span class="keyword">), </span><span class="default">$input</span><span class="keyword">);<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$cmd</span><span class="keyword">);<br />
<br />
</span><span class="default">$output </span><span class="keyword">= </span><span class="default">shell_exec</span><span class="keyword">(</span><span class="string">"printf </span><span class="default">$cmd</span><span class="string"> | /path/to/command"</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
For the paranoid, this torture test verifies that both shell escaping and printf's own escaping are handled correctly. Use with confidence!<br />
<br />
<span class="default">&lt;?php<br />
<br />
$test </span><span class="keyword">= </span><span class="string">'stuff bash interprets, space: # &amp; ; ` | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ \ \x0A \xFF. \' " %'</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'stuff bash interprets, no space: #&amp;;`|*?~&lt;&gt;^()[]{}$\\x0A\xFF.\'\"%'</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'stuff bash interprets, with leading backslash: \# \&amp; \; \` \| \* \? \~ \&lt; \&gt; \^ \( \) \[ \] \{ \} \$ \\\ \\\x0A \\\xFF. \\\' \" \%'</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="string">'printf codes: % \ (used to form %.0#-*+d, or \\ \a \b \f \n \r \t \v \" \? \062 \0062 \x032 \u0032 and \U00000032)'</span><span class="keyword">;<br />
<br />
echo </span><span class="string">"These are the strings we are testing with:"</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">.</span><span class="default">$test</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">;<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">$test</span><span class="keyword">;<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(array(</span><span class="string">'\\'</span><span class="keyword">, </span><span class="string">'%'</span><span class="keyword">), array(</span><span class="string">'\\\\'</span><span class="keyword">, </span><span class="string">'%%'</span><span class="keyword">), </span><span class="default">$test</span><span class="keyword">);<br />
</span><span class="default">$cmd </span><span class="keyword">= </span><span class="default">escapeshellarg</span><span class="keyword">(</span><span class="default">$cmd</span><span class="keyword">);<br />
<br />
echo </span><span class="default">PHP_EOL</span><span class="keyword">.</span><span class="string">"This is the output using the escaping mechanism given:"</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">;<br />
echo `</span><span class="string">printf </span><span class="default">$cmd</span><span class="string"> | cat</span><span class="keyword">`.</span><span class="default">PHP_EOL</span><span class="keyword">;<br />
<br />
echo </span><span class="default">PHP_EOL</span><span class="keyword">.</span><span class="string">"They should match exactly"</span><span class="keyword">.</span><span class="default">PHP_EOL</span><span class="keyword">;<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="98580""></a>
  <div class="note">
   <strong class="user">carlos at wfmh dot org dot pl dot REMOVE dot COM</strong>
   <a href="#98580" class="date">24-Jun-2010 01:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Mind it does not escape ! (exclamation mark). So if you want to i.e. printf() commands for later use in shell (i.e. by pasting to the console) you need to escape all exclamation marks or shell will try to process ! as history reference. This approach shall suffice:<br />
<br />
<span class="default">&lt;?php $scaped </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">(</span><span class="string">'!'</span><span class="keyword">, </span><span class="string">'\!'</span><span class="keyword">, </span><span class="default">escapeshellarg</span><span class="keyword">( </span><span class="default">$str </span><span class="keyword">) ); </span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80299""></a>
  <div class="note">
   <strong class="user">davidwhthomas</strong>
   <a href="#80299" class="date">08-Jan-2008 11:21</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To extract an archive file to a specific folder using exec() :<br />
<br />
<span class="default">&lt;?php<br />
$result </span><span class="keyword">= </span><span class="default">exec</span><span class="keyword">(</span><span class="default">escapeshellcmd</span><span class="keyword">(</span><span class="string">"tar -xvvf /path/to/archive.tar -C /path/to/extract/to/"</span><span class="keyword">));<br />
</span><span class="default">?&gt;<br />
</span><br />
escapeshellcmd() is used here because I am getting the file path via user input / upload.<br />
<br />
DT</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73169""></a>
  <div class="note">
   <strong class="user">Leon</strong>
   <a href="#73169" class="date">12-Feb-2007 01:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function is great -- except when you need to legitimately use an escaped character as part of your command.&nbsp; The code below leaves the parts of the command that are enclosed within single quotes alone, but escapes the rest eg:<br />
<br />
"echo Never use the '&lt;blink&gt;' tag ; cat /etc/passwd"<br />
becomes:<br />
"echo Never use the '&lt;blink&gt;' tag \; cat /etc/passwd"<br />
and not:<br />
"echo Never use the '\&lt;blink\&gt;' tag \; cat /etc/passwd"<br />
<br />
i.e, we really want the ';' escaped, but not the HTML tag.&nbsp; I really needed the code below in order to run the external ImageMagick's 'convert' command properly and safely...<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="comment">// Escape whole string<br />
</span><span class="default">$cmdQ </span><span class="keyword">= </span><span class="default">escapeshellcmd</span><span class="keyword">(</span><span class="default">$cmd</span><span class="keyword">);<br />
<br />
&nbsp;</span><span class="comment">// Build array of quoted parts, and the same escaped<br />
</span><span class="default">preg_match_all</span><span class="keyword">(</span><span class="string">'/\'[^\']+\'/'</span><span class="keyword">, </span><span class="default">$cmd</span><span class="keyword">, </span><span class="default">$matches</span><span class="keyword">);<br />
</span><span class="default">$matches </span><span class="keyword">= </span><span class="default">current</span><span class="keyword">(</span><span class="default">$matches</span><span class="keyword">);<br />
</span><span class="default">$quoted </span><span class="keyword">= array();<br />
foreach( </span><span class="default">$matches </span><span class="keyword">as </span><span class="default">$match </span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$quoted</span><span class="keyword">[</span><span class="default">escapeshellcmd</span><span class="keyword">(</span><span class="default">$match</span><span class="keyword">)] = </span><span class="default">$match</span><span class="keyword">;<br />
<br />
</span><span class="comment">// Replace sections that were single quoted with original content<br />
</span><span class="keyword">foreach( </span><span class="default">$quoted </span><span class="keyword">as </span><span class="default">$search </span><span class="keyword">=&gt; </span><span class="default">$replace </span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$cmdQ </span><span class="keyword">= </span><span class="default">str_replace</span><span class="keyword">( </span><span class="default">$search</span><span class="keyword">, </span><span class="default">$replace</span><span class="keyword">, </span><span class="default">$cmdQ </span><span class="keyword">);<br />
<br />
return </span><span class="default">$cmdQ</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="67811""></a>
  <div class="note">
   <strong class="user">abennett at clarku dot edu</strong>
   <a href="#67811" class="date">05-Jul-2006 08:59</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I've got a php script that needs to pass a username and password via exec to a perl script.&nbsp; The problem is valid password characters were getting escaped...<br />
<br />
Here's a little perl function I wrote to fix it.<br />
<br />
sub unescape_string {<br />
&nbsp;&nbsp; &nbsp;&nbsp; my $string = shift;<br />
&nbsp;&nbsp; &nbsp;&nbsp; # all these interpolated regex's are slow, so if there's no<br />
&nbsp;&nbsp; &nbsp;&nbsp; # backslash in the string don't bother with it<br />
&nbsp;&nbsp; &nbsp;&nbsp; # index() is faster then a regex<br />
&nbsp;&nbsp; &nbsp;&nbsp; if ( ! index($string,'\\\\') ) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; return $string;<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; my @characters = ('#', '&amp;', ';', '`', '|', '*', '?', '~', '&lt;', '&gt;', '^', '(', ')',<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; '[', ']', '{', '}', '$', '\\', ',', ' ', '\x0A', '\xFF' );<br />
&nbsp;&nbsp; &nbsp;&nbsp; my $character;<br />
&nbsp;&nbsp; &nbsp;&nbsp; foreach $character (@characters) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $character = quotemeta($character);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; my $pattern = "\\\\(" . $character . ")";<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $string =~ s/$pattern/$1/g;<br />
&nbsp;&nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp;&nbsp; return $string;<br />
}<br />
<br />
Hope this is useful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="63179""></a>
  <div class="note">
   <strong class="user">ceejay at trashfactory dot de</strong>
   <a href="#63179" class="date">15-Mar-2006 01:43</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Well guys, i find it very hard that escapeshellarg and escapeshellcmd are forcely run when passing a command to exec, system or popen, when safe_mode is turned on.<br />
<br />
Right now, i did not find any working solution to pass commands like this:<br />
cmd -arg1 -arg2 "&lt;BLA varname=\"varvalue\" varname1=\"varvalue1\" /&gt;"<br />
<br />
it is just the case, that the parameter for arg2 which is a string that looks like an HTML-Tag with various attributes set, all attributes of the string in arg2 gets splitted by the whitespaces within. this wont happen with safe_mode turned off, so it must be one of the escapefunctions, that breaks functionality. <br />
<br />
In order to circumvent this, i have made a temporary solution, which dynamically creates a skriptfile (by fopen), which just contains the whole command with arguments, and then execute that skriptfile. i dont like that solution, but in the other hand, safe_mode cannot be easily turned off on that server.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="56720""></a>
  <div class="note">
   <strong class="user">cast3r</strong>
   <a href="#56720" class="date">13-Sep-2005 02:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
"normal any user on linux can view almost any directory so:<br />
ls / -als will print a complete list of any file in the linux filesystem including its size, security and hidden files as well."<br />
ls / -alsR is the whole filesystem.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="51827""></a>
  <div class="note">
   <strong class="user">docey</strong>
   <a href="#51827" class="date">12-Apr-2005 02:56</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
the main reason for quoting a command is that it not multiple&nbsp; command can be joined. i don't know for sure if this is the right syntax but remeber that this can do some nice security breaks. here's one way of how to know exactly what your trying to break into for.<br />
<br />
normal any user on linux can view almost any directory so:<br />
ls / -als will print a complete list of any file in the linux filesystem including its size, security and hidden files as well.<br />
<br />
now the output would only become known to php and never will the user be able to view this data unless the php script would actual start to print it out. like passtru does!! but a good php coder knows never to use passtru unless not otherwise possible. <br />
<br />
but what would happen if you can direct the output from ls also from that same commandline to a file in the webroot most webserver still default their base-webroot to /var/www/ so storing it there in text file to download it later and you can simply take coffee while checking wich files can be read by php security mode and then simply use the cp command to copy those to the webroot and download them to your own hard-disk. without a list of the files you can only guess where to copy from! and thats harder then guessing the root password. <br />
<br />
so if the first command was quoted it is not possible to attach another command because of a syntax error. think of all the thinks you can do once you got a complete list of every file on the filesystem. including mounted once via NFS and others. security starts at keeping the door hidden.<br />
<br />
also another nice command for hanging the webserver can be "php <span class="default">&lt;?php </span><span class="keyword">while(</span><span class="default">true</span><span class="keyword">){ </span><span class="default">exec</span><span class="keyword">(</span><span class="string">'ls / -als'</span><span class="keyword">); }; </span><span class="default">?&gt;</span>" this keeps creating a file list on the entire filesystem wich not only keeps the hard-disk(s) bussy but also memory and cpu&nbsp;&nbsp; wich must store the returned list. so keeping in mind not all command accepted from users can be used blind. <br />
<br />
actualy never accept any command from external sources only proven built-in predefined commands should be executed.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="49527""></a>
  <div class="note">
   <strong class="user">trisk at earthling dot net</strong>
   <a href="#49527" class="date">31-Jan-2005 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This function does not work as shown in the php.net examples.<br />
<br />
If you put your encoded filename into double-quotes as they suggest, then it will break on certain characters in filenames, such as ampersand.<br />
<br />
For example if you have a filename called "foo &amp; bar.jpg" and you use this function on it, your resulting filename when double-quoted will produce this and not be found:<br />
<br />
"foo \&amp; bar.jpg"<br />
<br />
If you need to have a single argument where spaces are included then do not use this function with added double-quotes, use escapeshellarg() which encloses the whole string in single quotes.<br />
<br />
I do not understand which purpose this particular function is intended for.&nbsp; I can't see any use for it, unless you pass it through another function and convert spaces " " to "\ ", which would allow you to use the string directly on the command line.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.escapeshellarg.html">escapeshellarg</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.exec.html">exec</a></div>
 <div class="up"><a href="ref.exec.html">プログラム実行関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
